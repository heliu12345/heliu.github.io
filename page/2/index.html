<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="hello-world"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="hello-world"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - hello-world</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


<link rel="alternate" href="/atom.xml" title="hello-world" type="application/atom+xml">
</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">hello-world</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/11/11/dshc/Maven%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AE%A4%E8%AF%86/">
                Maven入门与认识
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-11-11</span>
            
            
            
                <span class="category">
                    <a href="/categories/工具环境/">工具环境</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Maven入门与认识"><a href="#Maven入门与认识" class="headerlink" title="Maven入门与认识"></a>Maven入门与认识</h1><h2 id="Maven有什么用"><a href="#Maven有什么用" class="headerlink" title="Maven有什么用"></a>Maven有什么用</h2><ol>
<li>Maven可以管理jar包，解决jar包之间冲突，版本冲突，解决人工手动导jar包等麻烦问题</li>
<li>Maven可以像Eclipse、IDEA等，实现Java文件的实时编译</li>
<li>Maven可以替开发者做各种单元测试，直接找出bug所在，快速测试检验代码</li>
<li>maven可以快速整合打包项目资源</li>
</ol>
<h2 id="Maven核心功能"><a href="#Maven核心功能" class="headerlink" title="Maven核心功能"></a>Maven核心功能</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><ul>
<li>依赖管理就是Maven工程对jar包的管理过程</li>
<li>由于多个项目，每个项目都会导入多个Jar包，会产生每个项目可能会有重复Jar包，所以Maven具有一个Jar包仓库，用于管理所有项目会用到的Jar包，Maven工程中只需要储存jar包坐标即可(pom.xml)</li>
<li>Maven通过Jar包的坐标在Jar包仓库中寻找对应的Jar包</li>
</ul>
<h3 id="一键构建"><a href="#一键构建" class="headerlink" title="一键构建"></a>一键构建</h3><ul>
<li>使用自身集成的Tomcat插件，完成编译、测试、运行、打包、安装、部署等一系列过程</li>
<li>CMD进入Maven工程根目录下使用命令<code>mvn tomcat:run</code>即可运行本项目</li>
</ul>
<h2 id="Maven环境配置"><a href="#Maven环境配置" class="headerlink" title="Maven环境配置"></a>Maven环境配置</h2><ol>
<li><p>登录 <a href="http://maven.apache.org/" target="_blank" rel="noopener">http://maven.apache.org/</a> 下载并解压安装Apache Maven，<a href="http://doc.tedu.cn/resource/apache-maven-3.5.2-bin.zip" target="_blank" rel="noopener">达内内网立即下载</a></p>
</li>
<li><p>解压Maven到没有空格、没有中文的目录下</p>
</li>
<li><p>【可选】打开<code>maven目录/conf/settings.xml</code>配置文件，配置阿里镜像地址(配置到<code>&lt;mirrors&gt;</code>标签里)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;aliyun&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;aliyun Maven&lt;/name&gt;</span><br><span class="line">    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量：新建<code>MAVEN_HOME:Maven根目录</code>，修改Path添加<code>5MAVEN_HOME%\bin</code>(注意：Maven依赖环境变量中有JAVA_HOME)，CMD输入<code>mvn -v</code>验证</p>
</li>
<li><p>【Eclipse】配置Maven，<code>Preferences--&gt;Maven--&gt;User Setting--&gt;Global Setting</code>中选择Maven/conf下的setting.xml文件</p>
</li>
<li><p>【Eclipse】接着点击下方按钮<code>Update Settings</code>，进行更新Maven设置</p>
</li>
<li><p>【Eclipse】验证镜像地址可以通过<code>Window--&gt;Show View--&gt;Other...--&gt;Maven视图</code></p>
</li>
<li><p>【Eclipse】项目强制更新程序依赖jar包，项目右键<code>Maven--&gt;Update Project</code>，勾选Force Update of Snapshots/Releases选项确定</p>
</li>
<li><p>【IDEA】配置Maven，<code>Settings--&gt;Maven--&gt;Maven home directory</code>中设置Maven根目录</p>
</li>
<li><p>【IDEA】接着下面<code>User Setting file</code>选择Maven/conf下的setting.xml文件，下方本地仓库路径会自动更新</p>
</li>
<li><p>【IDEA】进入<code>Settings--&gt;Maven--&gt;Runner--&gt;VM Options</code>添加参数<code>-DarchetypeCatalog=internal</code></p>
</li>
</ol>
<h2 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h2><ul>
<li>Maven中有三种仓库：本地仓库、中央仓库、远程仓库(私服)</li>
<li>Maven默认在系统用户目录下<code>\.m2\repository</code>设置本地仓库，在网络中存在中央仓库</li>
<li>Maven项目默认在本地仓库寻找jar包，如果本地仓库没有的话，就会去中央仓库寻找</li>
<li>公司中一般会配置远程仓库(也叫私服)，寻找jar包如果本地仓库不存在，则会去远程仓库(私服)寻找</li>
<li>远程仓库(私服)如果也没有，私服就会去中央仓库下载，或者通过本地上传</li>
</ul>
<h2 id="Maven项目标准目录结构"><a href="#Maven项目标准目录结构" class="headerlink" title="Maven项目标准目录结构"></a>Maven项目标准目录结构</h2><ul>
<li>传统的项目在创建和测试过程中，一定会产生四种文件部分：核心代码部分、配置文件部分、测试代码部分、测试配置文件</li>
<li>但是传统的目录结构仅仅是<code>项目名\src\</code>，如果需要另外储存其他文件，自己创建文件夹名称差异化特别大，所以Maven规范化了项目目录结构</li>
<li>Maven项目标准目录结构：</li>
</ul>
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>src/main/java</td>
<td>核心代码部分</td>
</tr>
<tr>
<td>src/main/resources</td>
<td>配置文件部分</td>
</tr>
<tr>
<td>src/test/java</td>
<td>测试代码部分</td>
</tr>
<tr>
<td>src/test/resources</td>
<td>测试配置文件</td>
</tr>
<tr>
<td>src/main/webapp</td>
<td>页面资源,js,css,图片等</td>
</tr>
</tbody></table>
<h2 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h2><ul>
<li>mvn clean ：把已经编译好的项目的所有信息</li>
<li>mvn compile ：把核心代码部分编译后，放置在target目录下</li>
<li>mvn test ：把测试代码部分编译后，放置在target目录下(同时执行了compile)</li>
<li>mvn package ：将Maven项目进行打包，放置在target目录下(同时执行了test)</li>
<li>mvn install ：将刚刚项目打完的包安装到本地仓库(同时执行了package)</li>
</ul>
<h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><ul>
<li>清理生命周期：清楚项目编译信息(clean)</li>
<li>默认生命周期：编译(compile)、测试(test)、打包(package)、安装(install)、发布(deploy)</li>
<li>站点生命周期：—</li>
</ul>
<h2 id="Maven概念模型图"><a href="#Maven概念模型图" class="headerlink" title="Maven概念模型图"></a>Maven概念模型图</h2><ul>
<li>项目对象模型(POM)：储存了三类信息<ol>
<li>项目自身信息</li>
<li>项目运行所依赖的jar包信息</li>
<li>项目运行环境信息，如jdk,tomcat等</li>
</ol>
</li>
<li>依赖管理模型(Dependency)：Jar包坐标信息<ol>
<li>公司组织名称–groupId</li>
<li>项目名–artifactId</li>
<li>版本号–version</li>
</ol>
</li>
<li>Build lifecycle &amp; phases ：默认生命周期命令对应的各种插件</li>
</ul>
<h2 id="Maven导入jar包"><a href="#Maven导入jar包" class="headerlink" title="Maven导入jar包"></a>Maven导入jar包</h2><ul>
<li>阿里在线搜索添加Jar组件”坐标”网址： <a href="https://maven.aliyun.com/mvn/search" target="_blank" rel="noopener">https://maven.aliyun.com/mvn/search</a></li>
<li>在pom.xml文件中添加Jar组件：在<code>&lt;dependencies&gt;</code>标签内添加Jar坐标</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/11/11/dshc/Web%E5%9F%BA%E7%A1%80-CSS%E8%AF%AD%E8%A8%80/">
                Web基础-CSS语言
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-11-11</span>
            
            
            
                <span class="category">
                    <a href="/categories/语言编程/">语言编程</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Web基础-CSS语言"><a href="#Web基础-CSS语言" class="headerlink" title="Web基础-CSS语言"></a>Web基础-CSS语言</h1><h2 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h2><h3 id="什么是CSS"><a href="#什么是CSS" class="headerlink" title="什么是CSS"></a>什么是CSS</h3><ul>
<li>CSS(Cascading Style Sheets)层叠样式表</li>
<li>CSS是修饰美化HTML的</li>
</ul>
<h3 id="导入CSS方法"><a href="#导入CSS方法" class="headerlink" title="导入CSS方法"></a>导入CSS方法</h3><ul>
<li>总共有三种方式：内联方式、内部样式表、外部样式表</li>
<li>内联方式：定义在单个的HTML元素中，元素的style属性</li>
<li>内部样式表：定义在HTML的头元素中<ul>
<li>头部<code>style</code>标签，属性<code>type=&quot;text/css&quot;</code>，在标签体内书写</li>
<li>例如：<code>&lt;style type=&quot;text/css&quot;&gt;css代码&lt;/style&gt;</code></li>
</ul>
</li>
<li>外部样式表：定义在一个外部的CSS文件中，HTML页面引用<ul>
<li>头部<code>link</code>标签，属性<code>rel=&quot;stylesheet&quot; href=&quot;css文件&quot;</code></li>
<li>例如：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css文件&quot; /&gt;</code></li>
<li>个别规定，属性中还要写入<code>style=&quot;text/css&quot;</code></li>
</ul>
</li>
<li>样式优先级：以最后一次定义的为准，所以内联方式优先级最高，外部与内部样式表根据其代码定义先后，定义在后者的优先级高于前者</li>
<li>某样式表内如果有css冲突，则根据选择器优先级判断优先</li>
<li>强制优先级规定：某句样式代码后面增加语句 <code>!important</code> 可使此样式优先级最高，但是<strong>不建议使用</strong>，会混乱代码</li>
</ul>
<h3 id="CSS规则特性"><a href="#CSS规则特性" class="headerlink" title="CSS规则特性"></a>CSS规则特性</h3><ul>
<li>语法规则：<code>选择器{声明1;声明2}</code>，声明的内容<code>属性:值</code></li>
<li>继承性：元素可以继承上级元素<strong>文本</strong>和<strong>字体</strong>相关的样式，部分标签自带效果不受继承影响，比如：超链接的字体颜色，h1-h6字体大小</li>
<li>层叠性：同一个元素若存在多个css规则，对于不冲突的声明可以叠加</li>
<li>优先级：各个选择器之间的优先级，作用越小，优先级越高，ID选择器&gt;类选择器&gt;元素选择器&gt;继承(简介选中)</li>
<li>选择器组：多个选择器公用一段css代码，选择器与选择器使用逗号隔开</li>
</ul>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="常用选择器"><a href="#常用选择器" class="headerlink" title="常用选择器"></a>常用选择器</h3><h4 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h4><ul>
<li>使用井号加ID名进行选择</li>
<li>例如：<code>#id{}</code></li>
<li>根据元素的id属性进行选择</li>
</ul>
<h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><ul>
<li>使用一个点加类名进行选择</li>
<li>例如：<code>.className{}</code></li>
<li>根据元素的class属性进行选择</li>
<li>组合示例：<code>div.className{}</code> 选择的是所有类名为className的div标签</li>
</ul>
<h4 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h4><ul>
<li>也叫标签名选择器：通过标签的名字进行选择</li>
<li>例如：<code>body{}</code> 或 <code>div{}</code></li>
</ul>
<h4 id="选择器组"><a href="#选择器组" class="headerlink" title="选择器组"></a>选择器组</h4><ul>
<li>多个选择器公用一段css代码，选择器与选择器使用逗号隔开</li>
<li>例如：<code>div.className,#id{}</code> 同时选择了：名为id的元素，所有类名为className的div元素</li>
</ul>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ul>
<li>根据元素属性进行选择</li>
<li>例如：<code>[attribute]</code>带有指定属性的元素 或 <code>[attribute 符号 value]</code>带有指定属性和值某种关系的元素</li>
</ul>
<table>
<thead>
<tr>
<th>选择器</th>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[attribute]</td>
<td></td>
<td>用于选取带有指定属性的元素</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td><code>=</code></td>
<td>用于选取带有指定属性和值的元素</td>
</tr>
<tr>
<td>[attribute~=value]</td>
<td><code>~=</code></td>
<td>用于选取属性值中包含指定词汇的元素</td>
</tr>
<tr>
<td>[attribute</td>
<td>=value]</td>
<td>`</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td><code>^=</code></td>
<td>匹配属性值以指定值开头的每个元素</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td><code>$=</code></td>
<td>匹配属性值以指定值结尾的每个元素</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td><code>*=</code></td>
<td>匹配属性值中包含指定值的每个元素</td>
</tr>
</tbody></table>
<h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>父标签 后代标签{}</td>
<td>父标签下所有后代标签（使用空格）</td>
</tr>
<tr>
<td>父标签&gt;子标签{}</td>
<td>只是子标签，不包含孙标签等（注意样式继承）</td>
</tr>
<tr>
<td>E元素+F元素{}</td>
<td>紧跟着E元素后的那一个F元素的样式</td>
</tr>
<tr>
<td>E元素~F元素{}</td>
<td>紧跟着E元素后的所有F元素的样式（无论中间有其他）</td>
</tr>
</tbody></table>
<h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>元素名:first-letter{}</td>
<td>该元素的第一个字</td>
</tr>
<tr>
<td>元素名:first-line{}</td>
<td>第一行的元素</td>
</tr>
<tr>
<td>元素名:before {content}</td>
<td>元素之前插入内容</td>
</tr>
<tr>
<td>元素名:after{content}</td>
<td>元素之后插入内容</td>
</tr>
<tr>
<td>元素名:selection{}</td>
<td>元素被选择后的样式</td>
</tr>
</tbody></table>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><table>
<thead>
<tr>
<th><strong>结构性伪类选择器</strong></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*{}</td>
<td>选择所有的元素</td>
</tr>
<tr>
<td>：root{}</td>
<td>选择文档的跟元素</td>
</tr>
<tr>
<td>E:first-child{}</td>
<td>第一个子元素E</td>
</tr>
<tr>
<td>E:last-child{}</td>
<td>最后一个子元素E</td>
</tr>
<tr>
<td>E:only-child{}</td>
<td>唯一一个子元素E</td>
</tr>
<tr>
<td>E:only-of-type{}</td>
<td>唯一个类型的子元素E</td>
</tr>
<tr>
<td>E:nth-child(n) {}</td>
<td>第n个子元素E—-n可以数字，可以公式，可以奇odd偶even</td>
</tr>
<tr>
<td>E:nth-last-child(n) {}</td>
<td>第n个子元素E</td>
</tr>
<tr>
<td>E:first-of-type{}</td>
<td>同类型第一个元素E</td>
</tr>
<tr>
<td>E:last-of-type{}</td>
<td>同类型最后一个元素E</td>
</tr>
<tr>
<td>E:nth-of-type(n){}</td>
<td>同类型第n个元素E</td>
</tr>
<tr>
<td>E:nth-last-of-type(n){}</td>
<td>同类型倒数第n个元素E</td>
</tr>
<tr>
<td>E:empty{}</td>
<td>选择没有任何子元素的元素E（内容也不可以有 空的元素E）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>UI伪类选择器及其他</strong></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>E:active{}</td>
<td>被激活的(鼠标按下时)</td>
</tr>
<tr>
<td>E:hover{}</td>
<td>鼠标悬浮时</td>
</tr>
<tr>
<td>E:link{}</td>
<td>未被访问过的</td>
</tr>
<tr>
<td>E:visited{}</td>
<td>已被访问过的</td>
</tr>
<tr>
<td>E:hover{}</td>
<td>鼠标悬浮时</td>
</tr>
<tr>
<td>E:focus{}</td>
<td>获取焦点时</td>
</tr>
<tr>
<td>E:lang(){}</td>
<td>带有lang属性的元素E</td>
</tr>
<tr>
<td>Input:checked {}</td>
<td>被选中的input</td>
</tr>
<tr>
<td>Input:disable {}</td>
<td>被禁用的input</td>
</tr>
<tr>
<td>Input:enable {}</td>
<td>启用的input</td>
</tr>
<tr>
<td>Input:checked {}</td>
<td>鼠标悬浮时</td>
</tr>
<tr>
<td>#E:target{}</td>
<td>当前活动的元素，被链接的元素</td>
</tr>
<tr>
<td>:not(E)</td>
<td>除了元素E以外的所有元素</td>
</tr>
</tbody></table>
<h2 id="CSS声明-样式"><a href="#CSS声明-样式" class="headerlink" title="CSS声明 - 样式"></a>CSS声明 - 样式</h2><h3 id="CSS基本单位与对象"><a href="#CSS基本单位与对象" class="headerlink" title="CSS基本单位与对象"></a>CSS基本单位与对象</h3><ul>
<li>样式单位：<code>%</code>百分比；<code>in</code>英寸；<code>cm</code>厘米；<code>mm</code>毫米；<code>pt</code>磅；<code>px</code>像素；<code>em</code>字体尺寸；</li>
<li>颜色常量：对应英文单词表示</li>
<li>颜色RGB表示：根据rbg值，红蓝绿，各255；十进制表示<code>rgb(255,0,255)</code>、十六进制表示<code>#ff00ff</code>或<code>#f0f</code>、百分比表示<code>rgb(100%,0%,100%)</code></li>
<li>颜色RGBA表示：同上，多一个透明值，十进制表示<code>rgba(255,0,255,0.5)</code> a∈[0,1]</li>
<li>颜色HSL表示：根据hsl值，色调 饱和度 亮度；十进制表示<code>hsl(100,0.5,0.5)</code> 分别取值范围是[0,360] [0,1] [0,1]</li>
<li>颜色HSLA表示：同上上</li>
</ul>
<h3 id="文本格式化"><a href="#文本格式化" class="headerlink" title="文本格式化"></a>文本格式化</h3><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>text-align</td>
<td>center/left/right<br>justify/inherit</td>
<td>水平对齐方式，后两个效果为两段对齐、继承父元素的属性值</td>
</tr>
<tr>
<td>text-decoration</td>
<td>none/underline/overline<br>line-through/blink/inherit</td>
<td>文本的装饰效果：没有，文本上下中的一条线，闪烁的文本，继承父元素的属性值</td>
</tr>
<tr>
<td>color</td>
<td>对应颜色值</td>
<td>文本颜色</td>
</tr>
<tr>
<td>text-shadow</td>
<td>[color][length][lenth][opacity]</td>
<td>颜色，水平off，垂直off，模糊效果；后三者单位常用px</td>
</tr>
<tr>
<td>line-height</td>
<td>normal/百分比/value</td>
<td>定义行高</td>
</tr>
<tr>
<td>font-size</td>
<td>absolute-size/relative-size<br>相对父元素百分比</td>
<td>设置字体大小</td>
</tr>
<tr>
<td>font-weight</td>
<td>normal/bold/value</td>
<td>定义字体粗体</td>
</tr>
<tr>
<td>font-style</td>
<td>normal/italic/oblique</td>
<td>定义字体倾斜，正常，倾斜，倾斜的字体(无斜体变量特殊字体使用)</td>
</tr>
<tr>
<td>font-family</td>
<td>字体名称1，字体名,2…</td>
<td>设置字体名称，可以写多个字体，从第一个匹配，如果系统没有改字体，向下寻找</td>
</tr>
<tr>
<td>font</td>
<td>[size] [family]</td>
<td>简易书写方式</td>
</tr>
<tr>
<td>Letter-spacing</td>
<td></td>
<td>设置中文字间距</td>
</tr>
<tr>
<td>word-spacing</td>
<td></td>
<td>设置单词词间距</td>
</tr>
<tr>
<td>Text-transform:uppercase</td>
<td></td>
<td>转换大小写lowercase,首字母大写capitalize</td>
</tr>
<tr>
<td>Text-shadow</td>
<td>length length len color</td>
<td>设置文字阴影 x偏移量 y偏移量 模糊度 颜色</td>
</tr>
<tr>
<td>White-space</td>
<td></td>
<td>空白处理方式 pre空白保留,nowrap不会换行，pre-wrap保留空白会换行,pre-line合并空白会换行</td>
</tr>
<tr>
<td>Direction</td>
<td></td>
<td>ltr左对齐，rtl右对齐</td>
</tr>
<tr>
<td>Word-wrap</td>
<td></td>
<td>break-word当某行单词超过宽度，将自己分割</td>
</tr>
<tr>
<td>Word-break</td>
<td></td>
<td>break-all当某单词太长，将自己分割</td>
</tr>
<tr>
<td>Text-stroke</td>
<td>length color</td>
<td>字体描边-宽度 颜色</td>
</tr>
<tr>
<td>Text-fill-color</td>
<td></td>
<td>填充颜色</td>
</tr>
<tr>
<td>Text-overflow</td>
<td></td>
<td>当内容被裁减的解决方式，cllixi显示省略号……</td>
</tr>
</tbody></table>
<h3 id="背景色-图background"><a href="#背景色-图background" class="headerlink" title="背景色/图background"></a>背景色/图background</h3><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>background-color</td>
<td>表示颜色的表达式</td>
<td>设置背景颜色</td>
</tr>
<tr>
<td>background-image</td>
<td>url(“路径”)</td>
<td>设置背景图片</td>
</tr>
<tr>
<td>background-size</td>
<td>width值 height值</td>
<td>设置背景图片大小</td>
</tr>
<tr>
<td>background-repeat</td>
<td>(repeat)默认 / no-repeat<br>repeat-x / repeat-y</td>
<td>设置背景图片是否可重复</td>
</tr>
<tr>
<td>background-position</td>
<td>两种方式如下</td>
<td>设置背景图片显示位置</td>
</tr>
<tr>
<td>background-attachment</td>
<td>scroll/fixed</td>
<td>scroll(默认):背景会随文档滚动<br>fixed:背景图像固定，并不会随着页面的其余部分滚动，常用实现称为水印的图像</td>
</tr>
</tbody></table>
<ul>
<li>背景图片位置取值：<ol>
<li>位置值：left、center、right、top、bottom</li>
<li>分量值：水平位置 垂直位置；这里的位置可以使用百分比，也可使用绝对值</li>
</ol>
</li>
</ul>
<h3 id="显示方式display"><a href="#显示方式display" class="headerlink" title="显示方式display"></a>显示方式display</h3><ul>
<li>元素都有自己的默认的显示方式：<ul>
<li>块元素(block)：可设置宽高，独占一行，如：h1、p、div 等</li>
<li>行内元素(inline)：不可设置宽高，共享一行，如：span、a 等(模型盒特殊)</li>
<li>行内块(inline-block)：可设置宽高，共享一行，如：input、img 等</li>
</ul>
</li>
<li>属性值display：可用于更改显示方式，取值为 none 、 block 、 inline 、 inline-block</li>
<li>分别对应，不显示该元素、块元素、行内元素、行内块</li>
</ul>
<h2 id="CSS声明-模型盒"><a href="#CSS声明-模型盒" class="headerlink" title="CSS声明 - 模型盒"></a>CSS声明 - 模型盒</h2><h3 id="模型盒概念"><a href="#模型盒概念" class="headerlink" title="模型盒概念"></a>模型盒概念</h3><ul>
<li>CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式</li>
<li>其中他们的排列顺序是：宽高&gt;内边距(padding)&gt;边框(border)&gt;外边距(margin)</li>
<li>注意行内元素：<ul>
<li>margin在水平方向有效，垂直方向无效</li>
<li>padding在水平方向有效，垂直方向可以有视觉效果，但是不影响其他元素，不会撑开盒子</li>
<li>高度height和宽度width的设置是无效的，高度可用line-height设置</li>
</ul>
</li>
<li>特别的：img元素的padding、margin是有效的</li>
</ul>
<h3 id="边框border"><a href="#边框border" class="headerlink" title="边框border"></a>边框border</h3><ul>
<li>border属性：用来设置元素的边框</li>
<li>语法：<code>border值: width值 style值 color值</code><ul>
<li>border值：border四边设置、border-left左边设置、border-right右边设置、border-top顶边设置、border-bottom底边设置</li>
<li>width值：根据样式单位进行设置，常用px像素值表示，也可用none</li>
<li>style值：none/hidden定义无边框 solid实线 dotted点状边框dashed虚线 double双线</li>
<li>color值：根据上述颜色设置方式赋值</li>
</ul>
</li>
<li>border-radius属性：用来设置边框圆角，数值越大，曲度越大，单位px</li>
</ul>
<h3 id="内边距padding"><a href="#内边距padding" class="headerlink" title="内边距padding"></a>内边距padding</h3><ul>
<li>高度与宽度外侧还有多个属性</li>
<li>设置属性内边距：<ul>
<li>padding 简写属性：作用是在一个声明中设置元素的所内边距属性</li>
<li>padding-bottom：设置元素的下内边距</li>
<li>padding-left：设置元素的左内边距</li>
<li>padding-right：设置元素的右内边距</li>
<li>padding-top：设置元素的上内边距</li>
</ul>
</li>
<li>简写方式中：一个值为四周，两个值分别为上下、右左，三个值分别表示上、右左、下，四个值分别为上右下左顺时针赋值</li>
<li>值赋值为auto：表示水平居中长度</li>
<li>模型盒溢出属性：overflow  overflow-x  overflow-y Visible<ul>
<li>overflow对应值：Visible 默认值不裁剪；hidden 裁剪；scroll 直接加滚动条；auto 自动判断是否滚动条</li>
</ul>
</li>
<li><font color="red">添加内边距会影响元素的宽高</font></li>
</ul>
<h3 id="外边距margin"><a href="#外边距margin" class="headerlink" title="外边距margin"></a>外边距margin</h3><ul>
<li>高度与宽度外侧还有多个属性</li>
<li>设置属性外边距：<ul>
<li>margin 简写属性：在一个声明中设置所有外边距属性</li>
<li>margin-bottom：设置元素的下外边距</li>
<li>margin-left：设置元素的左外边距</li>
<li>margin-right：设置元素的右外边距</li>
<li>margin-top：设置元素的上外边距</li>
</ul>
</li>
<li>简写方式中：一个值为四周，两个值分别为上下、右左，三个值分别表示上、右左、下，四个值分别为上右下左顺时针赋值</li>
<li>值赋值为auto：表示水平居中长度</li>
<li>模型盒溢出属性：overflow  overflow-x  overflow-y Visible<ul>
<li>overflow对应值：Visible 默认值不裁剪；hidden 裁剪；scroll 直接加滚动条；auto 自动判断是否滚动条</li>
</ul>
</li>
<li><font color="red">div套div，内层div的margin-top会无法识别</font>，解决方案：让父元素生成一个块级格式化范围（BFC） 一个BFC是一个HTML盒子并且至少<strong>满足下列条件中的任何一个</strong>：<ol>
<li>float的值不为none</li>
<li>position的值不为static或者relative</li>
<li>display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个</li>
<li>overflow的值不为visible</li>
</ol>
</li>
<li>我们常用，使父元素添加属性<code>overflow:hidden;</code></li>
</ul>
<h2 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h2><h3 id="position静态定位-文档流定位"><a href="#position静态定位-文档流定位" class="headerlink" title="position静态定位(文档流定位)"></a>position静态定位(文档流定位)</h3><ul>
<li>元素默认的定位方式，特点：块级元素从上到下排列，行内元素从左到右排序</li>
<li>其通过外边距控制元素所在位置</li>
<li>格式：position:static</li>
</ul>
<h3 id="position相对定位"><a href="#position相对定位" class="headerlink" title="position相对定位"></a>position相对定位</h3><ul>
<li>特点：元素不脱离文档流(元素移动位置，原来文档流中的位置保留，新位置不影响其他元素)</li>
<li>通过使用 left属性、right属性、top属性、bottom属性 相对于原元素初始位置做偏移</li>
<li>格式：position:relative</li>
<li>唯一一个不脱离文档流的定位方式</li>
</ul>
<h3 id="position绝对定位"><a href="#position绝对定位" class="headerlink" title="position绝对定位"></a>position绝对定位</h3><ul>
<li>特点：元素脱离文档流</li>
<li>通过  left属性、right属性、top属性、bottom属性 相对于 <strong>窗口</strong>或<strong>非默认(static)定位的上级元素</strong> 做偏移</li>
<li>格式：position:absolute</li>
</ul>
<h3 id="position固定定位"><a href="#position固定定位" class="headerlink" title="position固定定位"></a>position固定定位</h3><ul>
<li>特点：元素脱离文档流，固定在相对位置，不随文档滚动而移动位置</li>
<li>通过  left属性、right属性、top属性、bottom属性 相对于 <strong>窗口</strong>做偏移</li>
<li>格式：position:fixed</li>
</ul>
<h3 id="浮动定位"><a href="#浮动定位" class="headerlink" title="浮动定位"></a>浮动定位</h3><ul>
<li>特点：元素脱离文档流</li>
<li>通过属性设定，使元素从所在行位置，向左或向右浮动，当撞到上级元素边框或其他浮动元素时为止</li>
<li>特殊的：如果当行浮动元素宽度超过上级元素边框，则他会自动换行，换行规则是，先下移，再水平移，所以会出现一种情况：前者高度稍高，会将换行元素卡行</li>
<li>特殊的：如果元素全部浮动，则上级标签自动识别的高度为0，通过<code>overflow:hidden;</code>解决问题</li>
<li>格式：float:none/left/right</li>
<li>属性clear：定义了元素的哪个边不允许出现浮动元素，取值为none、left、right、both</li>
<li>应用场景：当纵向排列的元素需要横向排列的时候使用，如一行几个div、无序列表导航栏等</li>
</ul>
<h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><ul>
<li>属性z-index：控制元素框出现的重叠顺序，数值越大，表示离用户越近</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/11/11/dshc/Web%E5%9F%BA%E7%A1%80-HTML%E8%AF%AD%E8%A8%80/">
                Web基础-HTML语言
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-11-11</span>
            
            
            
                <span class="category">
                    <a href="/categories/语言编程/">语言编程</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Web基础-HTML语言"><a href="#Web基础-HTML语言" class="headerlink" title="Web基础-HTML语言"></a>Web基础-HTML语言</h1><h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><h3 id="HTML介绍"><a href="#HTML介绍" class="headerlink" title="HTML介绍"></a>HTML介绍</h3><ul>
<li>HTML(HyperText Markup Language)：超文本标记语言，一种纯文本类型的语言</li>
<li>一种特殊的XML文件，以 .html .htm 为后缀</li>
<li></li>
<li>由浏览器解释执行，可以嵌套脚本语言编写程序段(JavaScript)</li>
</ul>
<h3 id="HTML工作原理"><a href="#HTML工作原理" class="headerlink" title="HTML工作原理"></a>HTML工作原理</h3><ul>
<li>HTML是部署在服务器上的文本文件</li>
<li>根据HTTP协议，浏览器发出请求给服务器，服务器给出响应，给浏览器返回一个HTML</li>
<li>浏览器解释执行HTML，从而显示出内容</li>
<li><strong>HTML部署在服务器上，运行在浏览器上</strong></li>
</ul>
<h2 id="HTML语法"><a href="#HTML语法" class="headerlink" title="HTML语法"></a>HTML语法</h2><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><ul>
<li>HTML标记通常也称为HTML标签(HTML tag)</li>
<li>由于HTML是XML的一种扩展，所以基本的，标签要有闭合</li>
<li>特殊的，HTML也有对XML的一些扩展，个别标签允许没有闭合，如：meta input img等</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>由于HTML是XML的一种扩展，所以HTML的注释语法与XML的注释语法相同</li>
<li>语法：<code>&lt;!--注释的内容--&gt;</code></li>
<li>通过以上语法进行编辑注释</li>
</ul>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul>
<li>文档声明，告诉浏览器使用哪个版本的HTML标准进行解析</li>
<li><code>&lt;!DOCTYPE html&gt;</code>表示使用HTML5标准进行解析</li>
<li>文档声明常写在HTML文件中的第一行</li>
<li><code>&lt;!DOCTYPE&gt;</code>声明不是HTML标签，它为浏览器提供一项信息</li>
</ul>
<h2 id="HTML中各种标签"><a href="#HTML中各种标签" class="headerlink" title="HTML中各种标签"></a>HTML中各种标签</h2><h3 id="结构标签"><a href="#结构标签" class="headerlink" title="结构标签"></a>结构标签</h3><ul>
<li><code>&lt;html&gt;</code> 根标签，是HTML文档中最外层的跟标签</li>
<li><code>&lt;head&gt;</code> 头标签，是所有头部元素的容器<ul>
<li>头标签提示浏览器在何处可以找到样式表，包含的脚本，等等</li>
<li>头标签下常用子标签：<code>&lt;title&gt; &lt;meta&gt; &lt;link&gt; &lt;style&gt; &lt;script&gt;</code></li>
</ul>
</li>
<li><code>&lt;body&gt;</code> 体标签，定义文档的主体，默认距离四个边框留白8个像素</li>
</ul>
<h3 id="head标签子标签"><a href="#head标签子标签" class="headerlink" title="head标签子标签"></a>head标签子标签</h3><table>
<thead>
<tr>
<th>标签名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>定义在标签内，表明浏览器工具栏中的标题</td>
</tr>
<tr>
<td>meta</td>
<td>提供关于HTML文档的元数据，元数据不会显示在页面上，是对机器可读的<br>常用属性有<code>content</code>、<code>http-equiv</code>、<code>charset</code>其中charset字符集最常用</td>
</tr>
<tr>
<td>link</td>
<td>定义文档与外部资源的关系，最常见的用途是链接样式表<br>常用属性<code>href</code>表示被链接文档位置；<code>type</code>规定被链接文档的MIME_type</td>
</tr>
<tr>
<td>style</td>
<td>用于为HTML文档定义样式信息，<code>type</code>属性是必需的，定义style元素的内容。唯一可能的值是 “text/css”</td>
</tr>
<tr>
<td>script</td>
<td>用于定义客户端脚本，<code>type</code>属性是必需的，定义style元素的内容。唯一可能的值是 “text/css”<br>其既可以包含脚本语句，也可以使用外部脚本文件，使用属性<code>src</code>指向文件位置；</td>
</tr>
</tbody></table>
<h3 id="块行标签"><a href="#块行标签" class="headerlink" title="块行标签"></a>块行标签</h3><table>
<thead>
<tr>
<th>标签名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>h1</strong></td>
<td>标题标签 独占一行，自带上下间距</td>
</tr>
<tr>
<td><strong>div</strong></td>
<td>块分区标签 独占一行 常一个页面分为三大区</td>
</tr>
<tr>
<td><strong>p</strong></td>
<td>段落标签 独占一行，自带上下间距</td>
</tr>
<tr>
<td><strong>span</strong></td>
<td>行内分区标签，设置同一行文字内的不同格式(将文字包裹，属性设置CSS样式)</td>
</tr>
<tr>
<td><strong>a</strong></td>
<td>超链接标签</td>
</tr>
</tbody></table>
<ul>
<li><strong>br</strong>：换行标签、<strong>hr</strong>：水平分割线、<strong>b</strong>：加粗标签、<strong>i</strong>：斜体标签、<strong>small</strong>：小字标签 </li>
<li>通用属性：align 对齐方式，其值为：left、right、center、justify，<strong>不建议使用</strong>，建议用样式取代它</li>
<li>实体引用：<code>&amp;nbsp;</code>空格、<code>&amp;lt;</code>小于号、<code>&amp;gt;</code>大于号 记忆方法：你不是P 老铁 干他</li>
<li>HTML5新增块分许标签：header 头部、footer 底部、article 正文、section 区块、nav 导航</li>
</ul>
<h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><table>
<thead>
<tr>
<th>标签名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ul</strong>(unordered list)</td>
<td>无序列表 列表内每条为li标签</td>
</tr>
<tr>
<td></td>
<td>常用属性 1.<code>type</code>(每条信息前显示的样式) circle 空心圆/disc 实心圆/square 方框，<strong>不建议使用</strong>，建议用样式取代它</td>
</tr>
<tr>
<td><strong>ol</strong>(ordered list)</td>
<td>有序列表 列表内每条为li标签</td>
</tr>
<tr>
<td></td>
<td>常用属性 1.<code>type</code>(每条信息前显示的样式) 1/A/a/I/i 2.<code>start</code>(规定起始值) 3.<code>reversed</code>(设置倒序)</td>
</tr>
<tr>
<td><strong>dl</strong>(definition list)</td>
<td>定义列表 列表内标题与描述不同如下</td>
</tr>
<tr>
<td>dl内子标签<strong>dt</strong></td>
<td>在定义列表下，定义一个标题</td>
</tr>
<tr>
<td>dl内子标签<strong>dd</strong></td>
<td>在定义列表下，定义一个描述</td>
</tr>
</tbody></table>
<h3 id="图片元素img"><a href="#图片元素img" class="headerlink" title="图片元素img"></a>图片元素img</h3><ul>
<li>语法定义：<code>&lt;img&gt;</code>无闭合，支持图片格式 jpg jpeg png gif</li>
<li>属性<code>alt</code>：规定代替该资源的文本，当图片不能正常显示的时候文字代替</li>
<li>属性<code>title</code>：设定鼠标停留时显示的提示文本</li>
<li>常用属性<code>width height</code>：规定资源宽度、高度，可以使用<strong>像素</strong>或<strong>上级标签量的百分比</strong>表示，如”50%”，表示是上级标签长度的一般像素</li>
<li>必须属性<code>src</code>：规定资源路径，有两种方式：相对路径、绝对路径<ul>
<li>相对路径：相对于同级目录可以直接写资源名，相对于上级目录使用<code>../资源名</code>，相对于下级目录使用<code>目录名/资源名</code></li>
<li>绝对路径：一般访问站外资源使用，直接填入网址即可，可以节省本站资源但有找不到图片风险</li>
</ul>
</li>
</ul>
<h3 id="超链接a"><a href="#超链接a" class="headerlink" title="超链接a"></a>超链接a</h3><ul>
<li>语法定义：<code>&lt;a&gt;</code>正常闭合，如果设置了href属性，未访问为蓝色，访问过为紫色，带有下划线的连接为红色；否则没有默认颜色(黑色)</li>
<li>属性<code>href</code>(hypertext reference)：同样两种方式表示，可以表示站内或站外网站、本网页锚点、内外站资源等</li>
<li>属性<code>target</code>：规定在何处打开 action URL，其值：_blank/_self/_parent/_top/framename/#id(锚点)</li>
<li>a标签的锚点使用方式：设置锚点 <code>&lt;a name=&quot;anchorname&quot;&gt;锚点&lt;/&gt;</code>；使用锚点 <code>&lt;a href=&quot;#anchorname&quot;&gt;&lt;/a&gt;</code></li>
</ul>
<h3 id="表格table"><a href="#表格table" class="headerlink" title="表格table"></a>表格table</h3><ul>
<li>语法定义：<code>&lt;table&gt;</code>正常闭合，内部使用<code>&lt;caption&gt;</code>表示标题，<code>&lt;th&gt;</code>表示表头，<code>&lt;tr&gt;</code>表示一行，<code>&lt;td&gt;</code>表示一列</li>
<li>属性<code>border</code>：规定表格(外)边框的宽度，注意会有内格边框和外表边框间距，使用以下属性设置</li>
<li>属性<code>cellspacing</code>：规定单元格之间的间距，设置为0则没有边距</li>
<li>标签<code>&lt;td&gt;</code>属性<code>colspan</code>：规定单元格可横跨的列数</li>
<li>标签<code>&lt;td&gt;</code>属性<code>rowspan</code>：规定单元格可横跨的行数</li>
<li>标签<code>&lt;td&gt;</code>属性<code>nowrap</code>：规定单元格中的内容是否折行，<strong>不建议使用</strong>，建议用样式取代它</li>
</ul>
<h3 id="表单form"><a href="#表单form" class="headerlink" title="表单form"></a>表单form</h3><ul>
<li>语法定义：<code>&lt;form&gt;</code>正常闭合，获取用户输入的各种信息，提交到服务器</li>
<li>表单能够包含 input 元素，比如文本字段、复选框、单选框、提交按钮等等</li>
<li>表单还可以包含 menus、textarea、fieldset、legend 和 label 元素</li>
<li>属性<code>action</code>：规定当提交表单时向何处发送表单数据</li>
<li>属性<code>method</code>：规定用于发送 form-data 的 HTTP 方法(get/post)</li>
</ul>
<h3 id="输入控件input"><a href="#输入控件input" class="headerlink" title="输入控件input"></a>输入控件input</h3><ul>
<li>语法定义：<code>&lt;input&gt;</code>无闭合，通过其 type 属性设置其功能</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>必须<code>type</code></td>
<td>多种</td>
<td><code>button</code>按钮 <code>checkbox</code>多选框 <code>file</code>选择文件 <code>hidden</code>隐藏域 <code>image</code>图片按钮 <code>password</code>密码框 <code>radio</code>单选框 <code>reset</code>重置表单 <code>submit</code>执行表单 <code>text</code>输入框 <code>date</code>日期选择器</td>
</tr>
<tr>
<td><code>name</code></td>
<td>String</td>
<td>定义 input 元素的名称，提交表单时，是提交数据=左侧key值。在单选多选框中，name相同的控件为一组</td>
</tr>
<tr>
<td><code>value</code></td>
<td>String</td>
<td>规定 input 元素的值，提交表单时，是提交数据=右侧value值。常用做输入框的默认值 或 单选多选框的提交值</td>
</tr>
<tr>
<td><code>placeholder</code></td>
<td>Stirng</td>
<td>规定帮助用户填写输入字段的提示</td>
</tr>
<tr>
<td><code>id</code></td>
<td>String</td>
<td>规定该控件的id名称，有时用于lable标签的for属性指向该id</td>
</tr>
<tr>
<td><code>autocomplete</code></td>
<td>on(默认)/off</td>
<td>浏览器是否记录本次输入信息</td>
</tr>
<tr>
<td><code>checked</code></td>
<td>不写/“checked”</td>
<td>规定此 input 元素首次加载时应当被选中</td>
</tr>
<tr>
<td><code>accept</code></td>
<td>mime_type值</td>
<td>规定通过文件上传来提交的文件的类型。常用做上传文件</td>
</tr>
<tr>
<td><code>multiple</code></td>
<td>不写/“multiple”</td>
<td>如果使用该属性，则允许一个以上的值。常用做上传文件</td>
</tr>
</tbody></table>
<h3 id="下拉控件select"><a href="#下拉控件select" class="headerlink" title="下拉控件select"></a>下拉控件select</h3><ul>
<li>语法定义：<code>&lt;select&gt;</code>正常闭合，内部标签<code>&lt;option&gt;</code>添加下拉菜单</li>
<li>常用属性<code>name</code>，子标签<code>&lt;option&gt;</code>常用属性<code>&lt;value&gt;</code>表示选中的值，如果不写则默认标签内部值</li>
</ul>
<h2 id="HTML各种标签2"><a href="#HTML各种标签2" class="headerlink" title="HTML各种标签2"></a>HTML各种标签2</h2><ul>
<li><p>datalist标签：文本框下三角候选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;&quot; list=&quot;mydatalist&quot;&gt;</span><br><span class="line">		&lt;datalist id=&quot;mydatalist&quot;&gt;</span><br><span class="line">			&lt;option&gt;&lt;/option&gt;</span><br><span class="line">			&lt;option&gt;&lt;/option&gt;</span><br><span class="line">			&lt;option&gt;&lt;/option&gt;</span><br><span class="line">		&lt;/datalist&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>label标签：for=”ID”绑定到某的标签</p>
<ul>
<li>label也可以输入属性</li>
</ul>
</li>
<li><p>textarea标签：多行显示文本</p>
</li>
<li><p>output标签：JS可以设置其值</p>
</li>
<li><p>progress标签：进度条</p>
</li>
<li><p>meter标签：度量条</p>
</li>
<li><p>fieldset元素：类似控件组框 ，legend元素设定其标题</p>
</li>
<li><p>Keygen元素：建立一个密钥生成器</p>
</li>
<li><p>details元素：将闭合标签内容合在一起，open元素可以默认打开。summary元素给其添加标题</p>
</li>
<li><p>video元素，audio元素，source元素为子元素，解决兼容问题。</p>
</li>
<li><p>embed元素：嵌入对象比如flash—object也是嵌入对象</p>
</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/11/11/dshc/Java%E5%9F%BA%E7%A1%80-JavaSE(%E4%B8%8B)/">
                Java基础-JavaSE(下)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-11-11</span>
            
            
            
                <span class="category">
                    <a href="/categories/语言编程/">语言编程</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Java基础-JavaSE-下"><a href="#Java基础-JavaSE-下" class="headerlink" title="Java基础-JavaSE(下)"></a>Java基础-JavaSE(下)</h1><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><ul>
<li>主线程：JVM启动主线程,主线程运行main()方法</li>
<li>用户线程：开启的新的线程，也称为子线程。子线程默认优先级为父线程优先级</li>
<li>守护线程：守护线程是为其他线程提供服务的线程，不能独立运行，当JVM中只有守护线程时，守护线程全部结束，JVM退出</li>
</ul>
<h3 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h3><ul>
<li><p>通过继承Thread类，重写run()方法，实例化创建线程</p>
</li>
<li><p>通过实现Runnable接口，重写run()方法，实例化Thread时传入Thread的构造函数</p>
</li>
<li><p>一般使用以上两种，还有一种如下，但不常用，一般用在线程池</p>
</li>
<li><p>通过实现Callable<T>接口，重写call()方法；call()方法相比run()方法有返回值，通过Callable的泛型指定返回值类型</p>
<ul>
<li>不可以直接实例化Thread时传入Thread的构造函数，因为自己并不继承Runnable接口</li>
<li>通过FutureTask<T>类，将自己的实例对象传入到Thread的构造方法中(因为FutureTask<T>类实现了Runnable接口)</li>
<li>创建时构造函数传入Callable的实现类对象<code>FutureTask&lt;T&gt; task = new FutureTask&lt;&gt;(Callable的实现类对象)</code> 通过调用<code>task.get()</code>方法，获得返回结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; callable = new Callable&lt;&gt;()&#123;</span><br><span class="line">    public String call()throws Exception&#123;return &quot;&quot;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;T&gt; task = new FutureTask&lt;&gt;(callable);</span><br><span class="line">Thread t = new Thread(task);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>Runnable接口</code>与<code>Callable&lt;T&gt;接口</code>的区别：1.Callable主要用在线程池；2.在于不同执行体的方法：run()与call(),前者没有返回值且不抛出异常，后者有返回值且抛出异常</p>
</li>
</ul>
<h3 id="java-lang-Thread"><a href="#java-lang-Thread" class="headerlink" title="java.lang.Thread"></a>java.lang.Thread</h3><ul>
<li>优先级，1-10级，10最高，类中提供3个敞亮表示低高默认</li>
<li>Thread.MIN_PRIORITY/Thread.MAX_PRIORITY/Thread.NORM_PRIORITY</li>
<li><code>Thread(ThreadGroup GroupName,Runnable target,String name)</code></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>long getId()</td>
<td>返回该线程的标识符(标识符是唯一的)</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回该线程的名称</td>
</tr>
<tr>
<td>int getPriority()</td>
<td>返回线程的优先级</td>
</tr>
<tr>
<td>void setPriority(int priority)</td>
<td>设置线程的优先级</td>
</tr>
<tr>
<td>static int activeCount()</td>
<td>返回当前活动线程的数量</td>
</tr>
<tr>
<td>static Thread currentThread()</td>
<td>返回当前线程</td>
</tr>
<tr>
<td>Thread.state getState()</td>
<td>获取当前线程的状态，可以拼接字符串使用</td>
</tr>
<tr>
<td>boolean isAlive()</td>
<td>新建、死亡返回false；就绪、运行、阻塞返回true</td>
</tr>
<tr>
<td>boolean isDaemon()</td>
<td>测试线程是否为守护线程</td>
</tr>
<tr>
<td>static void sleep(long millis)</td>
<td>静态方法，线程休眠，有中断异常会被interrupt()方法中断</td>
</tr>
<tr>
<td>void interrupt()</td>
<td>中断线程，中断处于睡眠/等待中的线程</td>
</tr>
<tr>
<td>static boolean interrupt()</td>
<td>测试线程是否被中断</td>
</tr>
<tr>
<td>boolean isInterrupted()</td>
<td>测试线程是否已经被中断</td>
</tr>
<tr>
<td>void setDaemon(boolean b)</td>
<td>将调用该方法的线程设置为守护进程，只能在start()方法之前使用，否则无效</td>
</tr>
<tr>
<td>void join()</td>
<td>线程加入，等待调用该方法的线程执行完毕后，当前线程再继续执行</td>
</tr>
<tr>
<td>static void yield()</td>
<td>线程让步，主动让出CPU，当前进程进入就绪状态，重新争取CPU使用权(可能还是它)</td>
</tr>
<tr>
<td>ClassLoader getContextClassLoader()</td>
<td>返回线程的上下文加载器</td>
</tr>
<tr>
<td>void run()</td>
<td>线程执行体</td>
</tr>
<tr>
<td>void start()</td>
<td>开启线程</td>
</tr>
<tr>
<td>void stop()</td>
<td>终止线程，过时语法，不建议使用</td>
</tr>
</tbody></table>
<ul>
<li>wait([long timeout])、notify()、notifyAll()方法是Object类的方法，他们需要在同步代码块中，通过锁对象调用</li>
<li>如果调用wait()包含超时时间的方法，则时间过后会抛出超时异常</li>
<li>Thread.state：枚举定义的数据类型，包含：NEW、RUNNABLE、BLOCKED、WAITTING、TIMED_WATTING、TERMINATED</li>
<li>BLOCKED：等待锁对象时的状态。WAITTING：wait和join方法没有超时时。TIMED_WATTING：sleep方法或wait和join方法超时时</li>
</ul>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><ul>
<li>Java线程的生命周期存在：创建（<strong>New</strong>）、就绪（<strong>Runnable</strong>）、运行（<strong>Running</strong>）、阻塞（<strong>Blocked</strong>）和死亡（<strong>Terminated</strong>）五种状态</li>
<li>新建–&gt;就绪&lt;–&gt;运行–&gt;死亡</li>
<li>就绪&lt;–阻塞&lt;–运行</li>
</ul>
<h4 id="新建状态New"><a href="#新建状态New" class="headerlink" title="新建状态New"></a>新建状态New</h4><ul>
<li>使用new关键字新建一个线程后，处于新建状态，仅仅分配了内存，线程对象不会表现出任何线程的动态特征</li>
<li>新建状态的线程不可以重复调用start()方法，否则报错IllegalThreadStateException</li>
</ul>
<h4 id="就绪状态Runnable"><a href="#就绪状态Runnable" class="headerlink" title="就绪状态Runnable"></a>就绪状态Runnable</h4><ul>
<li>当对象调用了start()方法后，线程进入就绪状态，等待线程调度</li>
<li>注意：start()只表明线程准备完毕，并不一定立即执行</li>
</ul>
<h4 id="运行状态Running"><a href="#运行状态Running" class="headerlink" title="运行状态Running"></a>运行状态Running</h4><ul>
<li>当就绪状态线程获取到了CPU后进入运行状态</li>
<li>运行状态会执行run()方法，执行run()方法内的代码块</li>
</ul>
<h4 id="阻塞状态Blocked"><a href="#阻塞状态Blocked" class="headerlink" title="阻塞状态Blocked"></a>阻塞状态Blocked</h4><ul>
<li>线程调用sleep()方法、join()方法，使线程进入等待状态(等待时间/线程执行完毕)</li>
<li>调用wait()方法使对象进入等待池(释放锁对象)，当调用notify()方法、notifyAll()方法，线程进入等待锁对象池</li>
<li>线程试图获得一个同步监视器，但该监视器被其他线程持有，线程进入等待同步锁对象池，进入阻塞状态(BLOCKED)</li>
<li>线程调用了一个阻塞式IO方法，在该方法返回以前，该线程被阻塞</li>
<li>线程调用suspend()方法将该线程挂起。但这个方法容易导致死锁，不建议使用。后期使用resume()方法可以恢复</li>
</ul>
<h4 id="死亡状态Terminated"><a href="#死亡状态Terminated" class="headerlink" title="死亡状态Terminated"></a>死亡状态Terminated</h4><ul>
<li>run()/call()方法执行完成，线程正常结束</li>
<li>线程抛出一个未捕获的Exception或Error</li>
<li>直接调用线程的stop()方法结束该线程——该方法容易导致死锁，通常不建议使用</li>
<li>死亡状态的线程不可以再调用start()方法，否则报错IllegalThreadStateException</li>
</ul>
<h3 id="线程同步锁"><a href="#线程同步锁" class="headerlink" title="线程同步锁"></a>线程同步锁</h3><ul>
<li>多个线程同时访问修改：栈区(实例变量)、方法区(静态变量)</li>
<li>使用关键字<code>synchronized</code>实现同步</li>
<li>同步代码块：<code>synchronized(同步监视器对象) {需要多线程同步执行的代码片段}</code></li>
<li>同步方法：synchronized作为修饰词修饰方法，默认同步监视器对象为this</li>
<li>同步监视器常使用常量作为锁对象，有时使用this或当前类对象作为锁对象</li>
<li>同步监视器为this时，同步为对象同步，但是静态方法上的synchronized是类同步(监视器对象为该类的类对象)</li>
<li>注意:静态方法中的同步代码块指定的同步监视器对象不能用this，一般使用Boo.class</li>
</ul>
<h3 id="Timer计时器类"><a href="#Timer计时器类" class="headerlink" title="Timer计时器类"></a>Timer计时器类</h3><ul>
<li>构造方法：无参构造 或 传入布尔值构造，布尔为true时设置定时器为守护线程</li>
<li>方法：<code>timer.schedule(task,time)</code> 在指定的时间time实行任务task</li>
<li>方法：<code>timer.schedule(task,delay)</code> 延迟dalay毫秒后，执行任务task</li>
<li>方法：<code>timer.schedule(task,firstTime,period)</code> 指定task任务第一次执行的时间，以后每间隔period执行一次task</li>
</ul>
<h2 id="线程池技术"><a href="#线程池技术" class="headerlink" title="线程池技术"></a>线程池技术</h2><h3 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h3><ul>
<li>线程在Java中是一个对象，每一个Java线程都需要一个操作系统线程支持</li>
<li>线程创建、销毁需要时间，如果 创建时间+销毁时间&gt;执行任务时间 就很不合算</li>
<li>系统调度频繁切换上下文，过多线程的调度影响性能，所以要使用线程池技术</li>
<li>线程池常用在tomcat、dubbo、spring等</li>
</ul>
<h3 id="线程池相关类与接口"><a href="#线程池相关类与接口" class="headerlink" title="线程池相关类与接口"></a>线程池相关类与接口</h3><ul>
<li>java.util.concurrent.Executors（类）:是线程池的一个工具类，常用<code>static ExecutorService newFixedThreadPool(int nThreads)</code>创建固定最大数量的线程池</li>
<li>java.util.concurrent.Executor（接口）：是线程池的顶级接口，内部只有一个抽象方法 <code>void execute(Runnable command)</code></li>
<li>java.util.concurrent.ExecutorService（接口）：继承上面这个接口</li>
<li>java.util.concurrent.ThreadPoolExecutor（类）：实现了以上两个接口，构造方法 corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue</li>
</ul>
<h3 id="ThreadPoolExecutor构造含义"><a href="#ThreadPoolExecutor构造含义" class="headerlink" title="ThreadPoolExecutor构造含义"></a>ThreadPoolExecutor构造含义</h3><ul>
<li>java.util.concurrent.ThreadPoolExecutor（类）：构造方法 corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue</li>
<li>例：<code>ThreadPoolExecutor pool = new ThreadPoolExecutor(5, 10, 3, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(10));</code></li>
<li>建立了一个线程池，其中：核心线程数5 最大线程数10 线程存活时间3 存活时间单位second 任务队列最大长度为10</li>
<li>使用其重写Executor接口的<code>void execute(Runnable command)</code>方法，向任务队列中添加任务</li>
</ul>
<h4 id="其运行过程"><a href="#其运行过程" class="headerlink" title="其运行过程"></a>其运行过程</h4><ul>
<li>当任务队列数量没有达到队列最大值时，最多运行的线程数为5</li>
<li>当任务队列数量达到队列最大值时，此时开始启用临时线程，但控制所有线程数量最多为10<ul>
<li>当临时线程没有任务时，存活3s，销毁掉临时线程，核心线程一直存在</li>
</ul>
</li>
<li>特殊的：如果任务投入超过队列最大长度，且此时线程总数已经达到了最大线程数，则再进入的任务，线程池拒绝服务(抛出异常)</li>
<li>比如这个例子中：execute 10个任务，会启用5个线程；execute 20个任务，会启用10个线程；execute 超过20个任务，则从第21个任务开始决绝服务</li>
</ul>
<h3 id="ThreadPoolExecutor内部原理剖析"><a href="#ThreadPoolExecutor内部原理剖析" class="headerlink" title="ThreadPoolExecutor内部原理剖析"></a>ThreadPoolExecutor内部原理剖析</h3><ul>
<li>内部类worker继承Thread来创建线程</li>
<li>worker内部的线程任务，通过不停的调用自身<code>run()</code>方法进行循环</li>
<li>循环过程中通过绝对线程安全Queue队列的<code>take()</code>阻塞方法，等待取出任务 new 自己 进行执行该任务</li>
<li><code>execute()</code>方法中含有判断队列，线程数等方法，new worker 或者 向队列插入 task任务</li>
</ul>
<h2 id="集合Collection"><a href="#集合Collection" class="headerlink" title="集合Collection"></a>集合Collection</h2><ul>
<li>JDK1.5新增特性For each，泛型都是编译器认可，源码中foreach还是迭代器，泛型还是会造型操作</li>
<li>泛型只能使用引用数据类型，如果是基本数据类型使用包装类</li>
<li>Arrays类中 static List asList()方法，将数组作为List操作，所以：<ul>
<li>集合只能引用数据类型，不能使用基本数据类型（byte,short,int,long,float,double,boolean）</li>
<li>因为是将数组作为List操作，该方法将数组与列表连接起来，Map或Array操作他们其中之一时，相当于也在操作另一个(数据相通)</li>
<li>又因为数组是定长的，所以List不支持add和remove方法</li>
</ul>
</li>
</ul>
<h3 id="java-util-Collection"><a href="#java-util-Collection" class="headerlink" title="java.util.Collection"></a>java.util.Collection</h3><ul>
<li>Colletion接口实现Iterator接口，下面有两个常用的子接口：java.util.List、java.util.Set</li>
<li>Collection是集合框架顶级接口，里面定义了所有集合都应当具备的相关操作方法</li>
<li>构造方法中可以直接传入一个Collection,将传入的集合的元素传入新建的集合中</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E e)</td>
<td>向集合添加给定元素，成功返回true</td>
</tr>
<tr>
<td>int size()</td>
<td>返回当前集合的元素个数</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>是否为空集，当集合不含有任何原属时为空集(并非集合为null)</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空当前元素</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>根据equals查找有没有该元素</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>根据equals删除该元素(如果为list只删除第一个)</td>
</tr>
<tr>
<td>boolean addAll(collection c)</td>
<td>将给定集合中的所有元素添加到当前集合,Set中不会重复</td>
</tr>
<tr>
<td>boolean containsAll(collection c)</td>
<td>判断当前集合是否包含给定集合中的所有元素</td>
</tr>
<tr>
<td>boolean removeAll(Collection c)</td>
<td>删除当前集合中与给定集合的共有元素,参数给定的集合元素不受影响</td>
</tr>
<tr>
<td>Iterator iterator()</td>
<td>该方法返回一个Iterator的实现类，迭代器</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>该方法可以将集合返回数组，注意为对象数组</td>
</tr>
<tr>
<td>T[] toArray(T[] array)</td>
<td>将元素存入传入的某类型数组中,并返回</td>
</tr>
<tr>
<td></td>
<td>数组长度不足则toArray方法另外new数组返回，长度超过则会填null</td>
</tr>
</tbody></table>
<h3 id="java-util-Iterator"><a href="#java-util-Iterator" class="headerlink" title="java.util.Iterator"></a>java.util.Iterator</h3><ul>
<li>java.util.Iterator 接口</li>
<li>不同的集合实现类都提供了一个迭代器实现类用于遍历自身元素</li>
<li>迭代器在集合遍历的过程中是不可以通过<strong>集合的方法</strong>增删元素的</li>
<li>游标概念：用于指向元素的指针，当新建对象的时候，游标恢复默认</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>判断是否有下一个元素</td>
</tr>
<tr>
<td>E next()</td>
<td>获取下一个元素</td>
</tr>
<tr>
<td>void remove()</td>
<td>删除next()方法取出的元素</td>
</tr>
</tbody></table>
<h3 id="java-util-List"><a href="#java-util-List" class="headerlink" title="java.util.List"></a>java.util.List</h3><ul>
<li>java.util.List 接口：实现Collection接口，线性表。是一组可以放重复元素的集合，特点是有序，可以通过下标操作元素</li>
<li>常用实现类：ArrayList,Vector,LinkedList</li>
<li>List中contains()、remove()等方法都要用到equals()方法，重写必须的</li>
<li>ArrayList,Vector底层都是数组实现的，新建时长度为10，但扩容时前者扩大1.5倍，后者2倍，并且后者是线程安全的</li>
<li>LinkedList是链表形式，可以当做List，可以当做Queue/Deque，也可以当做栈使用</li>
<li>性能要求不大，常用ArrayList，线程安全现在常用CopyOnWriteArrayList类</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>E get(int i)</td>
<td>获取指定下标处对应的元素</td>
</tr>
<tr>
<td>E set(int index,E e)</td>
<td>将给定的元素设置到指定位置，返回值为原位置对应的元素（替换元素操作）</td>
</tr>
<tr>
<td>void add(int index,E e)</td>
<td>将给定元素插入到指定位置</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>删除并返回给定位置的元素</td>
</tr>
<tr>
<td>List subList(int fromIndex, int toIndex)</td>
<td>List可以返回指定范围内的子集[的引用],更改后原集合也会改动</td>
</tr>
<tr>
<td>subList()特性</td>
<td>快速去除中间某段元素，可以使用subList()获取子集后clear()</td>
</tr>
</tbody></table>
<h3 id="java-util-Set"><a href="#java-util-Set" class="headerlink" title="java.util.Set"></a>java.util.Set</h3><ul>
<li>java.util.Set 接口：实现Collection接口，不可重复集.大部分实现类是无序的，常用类：HashSet</li>
<li>无序：添加顺序有可能和排列顺序不同</li>
<li>Set与HashSet并没有其他特殊方法，HashSet的底层其实是HashMap，将值添加到Key中</li>
</ul>
<h3 id="java-util-TreeSet"><a href="#java-util-TreeSet" class="headerlink" title="java.util.TreeSet"></a>java.util.TreeSet</h3><ul>
<li>java.util.TreeSet 类：Set接口&lt;–SortedSet接口&lt;–NavigableSet接口&lt;–TreeSet类</li>
<li>TreeSet具有元素自然排序的集合，所以在创建时可以添加一个比较器(优先) 或 添加的元素都实现了Comparable接口</li>
<li>TreeSet的底层其实是TreeMap，将值添加到Key中</li>
<li>注意：因为Set不可添加相同元素，TreeSet中会根据<font color="red">排序结果</font>是否相同判断是否为相同元素</li>
</ul>
<h3 id="java-util-Queue"><a href="#java-util-Queue" class="headerlink" title="java.util.Queue"></a>java.util.Queue</h3><ul>
<li>java.util.Queue 接口(队列)：实现Collection接口，规定了队列出入队的相关方法，队列储存元素必须遵循先进先出原则，常用类：LinkedList</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean offer()</td>
<td>入队操作,添加元素的方法</td>
</tr>
<tr>
<td>E poll()</td>
<td>出队操作,将队首元素移除并返回</td>
</tr>
<tr>
<td>E pick()</td>
<td>引用队首元素</td>
</tr>
</tbody></table>
<h3 id="java-util-Deque"><a href="#java-util-Deque" class="headerlink" title="java.util.Deque"></a>java.util.Deque</h3><ul>
<li>java.util.Deque 接口(双端队列)：实现Queue接口，是两段都可以做进出队的队列。常用实现类：LinkedList</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean offerFirst()</td>
<td>入队操作,从队首添加元素的方法</td>
</tr>
<tr>
<td>boolean offerLast()</td>
<td>入队操作,从队尾添加元素的方法(等同offer)</td>
</tr>
<tr>
<td>E pollFirst()</td>
<td>出队操作,将队首元素移除并返回(等同poll)</td>
</tr>
<tr>
<td>E pollLast()</td>
<td>出队操作,将队尾元素移除并返回</td>
</tr>
<tr>
<td>E pickFirst()</td>
<td>引用队首元素(等同pick)</td>
</tr>
<tr>
<td>E pickLast()</td>
<td>引用队尾元素</td>
</tr>
<tr>
<td>如果看做栈</td>
<td>当做栈来使用的话</td>
</tr>
<tr>
<td>void push()</td>
<td>入栈操作(等同offerFirst)</td>
</tr>
<tr>
<td>E pop()</td>
<td>出栈操作(等同poll)</td>
</tr>
</tbody></table>
<h3 id="java-util-Collections"><a href="#java-util-Collections" class="headerlink" title="java.util.Collections"></a>java.util.Collections</h3><ul>
<li>java.util.Collections 类，是集合框架的工具类</li>
<li>提供了很多把集合转为线程安全的集合的方法<code>synchronizedXXX(XXX)</code>,但现不常用改用java.until.concurrent包内的线程安全集合，比如：List集合用CopyonWriteArrayList,Set集合用concurrentSkipListSet</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static void sort(List<T> list)</td>
<td>该方法是用来对List集合进行自然排序的（从小到大<br>排序元素必须实现Comparable接口才可编译通过</td>
</tr>
<tr>
<td>static void sort(List<T> list,Comparator<T> c)</td>
<td>通过比较器来比较两元素，重写compare方法，返回正负零值代表大小</td>
</tr>
</tbody></table>
<h2 id="集合Map"><a href="#集合Map" class="headerlink" title="集合Map"></a>集合Map</h2><ul>
<li>查找表Map成对保存数据（key-value对），并且是根据key来获取对用的value，常用Map总实现类：HashMap,TreeMap,LinkedHashMap</li>
<li><code>Map</code>接口&lt;–<code>ConcurrentMap</code>接口(应用于多线程环境，常用实现类:ConcurrentHashMap)&lt;–<code>ConcurrentNavigableMap</code>接口(具有自然排序功能，其常用实现类:ConcurrentSkipListMap),因为其也实现了<code>NavigableMap</code>接口</li>
<li><code>Map</code>接口&lt;–<code>SortedMap</code>接口(自然排序功能)&lt;–<code>NavigableMap</code>接口(具有自然排序功能，其常用实现类:TreeMapp)</li>
<li>不需要根据键排序，一般使用HashMap；需要根据键来排序，一般使用TreeMap</li>
<li>特别注意自然排序的实例其比较键是否相同是根据比较方法比较后是否为0决定的</li>
</ul>
<h3 id="java-util-Map"><a href="#java-util-Map" class="headerlink" title="java.util.Map"></a>java.util.Map</h3><ul>
<li>java.util.Map 接口，所有查找表的顶级接口，查找表</li>
<li>常用实现类：<code>HashMap</code>和<code>HashTable</code></li>
<li>Map没有重复Key元素，如果有重复Key元素，该key对应的value将会被替换</li>
<li>内部类Entry，具有方法<code>K getKey()</code>、<code>V getValue()</code>、<code>V setValue(V value)</code></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>V put(K key,V value)</td>
<td>将给定的key-value对保存到Map中，若key存在返回替换掉的原value,若不重复返回null</td>
</tr>
<tr>
<td>V get(K key)</td>
<td>根据key获取对应的value，若给定的key在Map中不存在，则返回null</td>
</tr>
<tr>
<td>V remove(Object keyp[,Object value])</td>
<td>根据给定的key[和value]删除这组键值对，返回为该key对应的value</td>
</tr>
<tr>
<td>V replace(K keyp,V value)</td>
<td>根据给定的key替换value并返回旧value</td>
</tr>
<tr>
<td>boolean replace(K key,V oldValue,V newValue)</td>
<td>替换匹配到的&lt;键，值&gt;对</td>
</tr>
<tr>
<td>Set<K> keySet()</td>
<td>将当前Map中所有的key以一个Set集合形式返回</td>
</tr>
<tr>
<td>Set<Entry> entrySet()</td>
<td>返回Entry实例，Entry的每一个实例表示当前Map中的一组键值对</td>
</tr>
<tr>
<td>Collection values()</td>
<td>将当前Map中所有的value以一个集合的形式返回</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>判断是否包含指定的键</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>判断是否包含指定的值</td>
</tr>
<tr>
<td>void clear()</td>
<td>清除所有的&lt;键，值&gt;对</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td>返回&lt;键，值&gt;对的数量</td>
</tr>
</tbody></table>
<h3 id="java-util-HashMap-HashTable"><a href="#java-util-HashMap-HashTable" class="headerlink" title="java.util.HashMap/HashTable"></a>java.util.HashMap/HashTable</h3><ul>
<li>java.util.HashMap 类，实现Map接口</li>
<li>有个常用的子类：java.util.LinkedHashMap，其特点是存储的数据具有顺序性，添加顺序就是存储顺序</li>
<li>java.util.HashTable 类，实现Map接口</li>
<li>有个常用的子类：java.util.Properties，其特点是键值对类型都是String,常用作设置/读取属性</li>
</ul>
<h4 id="HashMap工作原理"><a href="#HashMap工作原理" class="headerlink" title="HashMap工作原理"></a>HashMap工作原理</h4><ul>
<li>底层是哈希表(散列表)，哈希就是一个数组，数组的每个元素指向一个单向链表，其储存该单向链表第一个结点的引用</li>
<li>每个单向链表中有多个结点，每个结点由四部分组成，<code>hash,key,value,next</code>分别是哈希值，键，值，下一个结点的引用</li>
</ul>
<h5 id="hashmap-put-“key”-value"><a href="#hashmap-put-“key”-value" class="headerlink" title="hashmap.put(“key”,value)"></a>hashmap.put(“key”,value)</h5><ol>
<li>根据key的哈希码，即key的hashCode()方法的返回值，计算在数组中的索引值,i=2(如何计算的先不管)</li>
<li>访问table[i]，如果该元素为null，就会根据&lt;”key”,value&gt;键值对生成一个新的结点，存储到table[i]这个位置</li>
<li>如果数组中该元素不为null，就会遍历table[i]单向链表中的每个结点<ul>
<li>当有个结点的键与当前键”key”equals相等，就使用新的值value替换结点原来的value值</li>
<li>如果遍历完单向链表所有结点都没有匹配的结点，就会创建一个新的结点插入到链表的头部，table[i]储存的引用改为刚刚新结点的引用</li>
</ul>
</li>
</ol>
<h5 id="hashmap-get-“key”"><a href="#hashmap-get-“key”" class="headerlink" title="hashmap.get(“key”)"></a>hashmap.get(“key”)</h5><ol>
<li>根据key的哈希码，即key的hashCode()方法的返回值，计算在数组中的索引值,i=2(如何计算的先不管)</li>
<li>访问table[i]，如果该元素为null，就返null</li>
<li>如果数组中有table[i]这个元素，则会遍历table[i]中链表的每个结点<ul>
<li>当有个结点的键与当前键”key”equals相等，就把结点的value值返回</li>
<li>如果完单向链表中所有结点都没有匹配，就返回null</li>
</ul>
</li>
</ol>
<h4 id="装载因子HashMap优化"><a href="#装载因子HashMap优化" class="headerlink" title="装载因子HashMap优化"></a>装载因子HashMap优化</h4><ul>
<li>Capacity：容量，hash表里bucket(桶)的数量，也就是散列数组大小</li>
<li>Initaial capacity：初始容量，创建hash表时，初始bucket的数量，默认构建容量是16，也可以使用特定数量</li>
<li>Size：大小，当前散列表中储存数据的数量</li>
<li>Load factor：加载因子，默认值0.75(就是75%)，当向散列表增加数据时，如果size/capacity的值大于Load factor则发生扩容并重新散列</li>
<li>性能优化：加载因子较小时，散列查找性能会提高，同时也浪费了散列桶空间容量。0.75时性能和红箭相对平衡的结果。在创建散列表时指定合理容量，减少rehash提高性能</li>
</ul>
<h4 id="HashMap与HashTable的对比"><a href="#HashMap与HashTable的对比" class="headerlink" title="HashMap与HashTable的对比"></a>HashMap与HashTable的对比</h4><ol>
<li>底层都是哈希表(散列表)，HashTable是线程安全的，而HashMap不是线程安全的</li>
<li>HashMap的父类是AbstractMap，HashTable的父类是Dictionary</li>
<li>HashMap的默认初始值：16，HashTable的默认初始值：11</li>
<li>加载因子：0.75，当&lt;键，值&gt;对的数量 大于 数组的容量(哈希桶的容量) * 加载因子时，数组要扩容</li>
<li>HashMap扩容默认：2倍大小； HashTable扩容：2倍+1</li>
<li>HashMap的键与值可以为null，HashTable的键与值不能为null</li>
<li>HashMap在创建时，可以制定一个初始化容量，系统会调整为2的幂次方(比如21会返回32，因为16&lt;21&lt;32)(为了快速计算出数组的下标：2的幂次方减1与hash相与)，HashTable也可以指定初始化容量，系统不调整</li>
</ol>
<h3 id="java-util-properties"><a href="#java-util-properties" class="headerlink" title="java.util.properties"></a>java.util.properties</h3><ul>
<li>java.util.properties 类：是HashTable类的常用子类，特点是键值对类型都是String，其常用作设置/读取属性</li>
<li>一般单独创建一个资源包(resources)，在该包中添加后缀名为properties配置文件来进行操作，文件中的键值表示为<code>key value/key=value/key:value</code>空格或:或=</li>
<li>有两个常用方法<code>String getProperties(String key)</code>和<code>Object putProperties(String key, String value)</code>（替换返回旧值，否则null）</li>
<li>读取配置文件的方法有两种：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = new Properties()//不需要泛型</span><br><span class="line">InputStream inStream = XXX.class.getResourceAsStream(&quot;/XXX&quot;);//XXX是src以下的相对路径</span><br><span class="line">InputStream inStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;XXX&quot;)//注意这个开头没有&quot;/&quot;</span><br><span class="line">//以上第一种常为一般用途，第二种常用在多线程中</span><br><span class="line">properties.load(inStream)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResourceBundle bundle = ResourceBundle.getBundle(&quot;XXX&quot;)</span><br><span class="line">//注意这个开头没有&quot;/&quot;,且不需要写扩展名，但是文件必须是properties类型</span><br><span class="line">//关于&quot;/&quot;写不写的问题，可以试，如果报错找不到文件，那应该就是路径中&quot;/&quot;的问题</span><br></pre></td></tr></table></figure>

<h3 id="java-util-TreeMap"><a href="#java-util-TreeMap" class="headerlink" title="java.util.TreeMap"></a>java.util.TreeMap</h3><ul>
<li>TreeMap 类：实现了SortedMap接口，可以根据键自然排序，排序原理是二叉树原理，采用的是中序遍历</li>
</ul>
<h2 id="涉及到的专业术语"><a href="#涉及到的专业术语" class="headerlink" title="涉及到的专业术语"></a>涉及到的专业术语</h2><p>这里流连接的操作分别为：</p>
<ol>
<li>先将给定对象通过对象流写出，此时对象流会将该对象转换为一组字节这个过程称为<strong>对象序列化</strong></li>
<li>序列化后的字节再通过文件流写入了文件，即：写入磁盘中，这个过程称为<strong>数据持久化</strong></li>
<li>签名接口：<code>java.io.Serializable//java.lang.Cloneable</code>编译器敏感，编译器发现时，自动添加功能方法，从而完成功能</li>
<li>侵入性：当我们使用某个API时，他要求我们为其修改其他额外代码</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/11/11/dshc/Java%E5%9F%BA%E7%A1%80-JavaSE(%E4%B8%8A)/">
                Java基础-JavaSE(上)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-11-11</span>
            
            
            
                <span class="category">
                    <a href="/categories/语言编程/">语言编程</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Java基础-JavaSE-上"><a href="#Java基础-JavaSE-上" class="headerlink" title="Java基础-JavaSE(上)"></a>Java基础-JavaSE(上)</h1><h2 id="JavaSE基础"><a href="#JavaSE基础" class="headerlink" title="JavaSE基础"></a>JavaSE基础</h2><h3 id="Java包结构"><a href="#Java包结构" class="headerlink" title="Java包结构"></a>Java包结构</h3><table>
<thead>
<tr>
<th>包名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>java.lang</td>
<td>最基础的类JVM默认导入可以直接使用的</td>
</tr>
<tr>
<td>java.util</td>
<td>常用工具，如集合、随机数、日历、时钟等</td>
</tr>
<tr>
<td>java.io</td>
<td>文件操作、输入/输出操作</td>
</tr>
<tr>
<td>java.net</td>
<td>网络操作</td>
</tr>
<tr>
<td>java.math</td>
<td>数学运算相关操作</td>
</tr>
<tr>
<td>java.security</td>
<td>安全相关操作</td>
</tr>
<tr>
<td>java.sql</td>
<td>数据库访问</td>
</tr>
<tr>
<td>java.text</td>
<td>处理文字、日期、数字、信息的格式</td>
</tr>
</tbody></table>
<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>使用<code>/** */</code>进行标注</p>
<table>
<thead>
<tr>
<th>常用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@author</td>
<td>作者，一般英文名</td>
</tr>
<tr>
<td>@since</td>
<td>始于某JDK开发环境</td>
</tr>
<tr>
<td>@version</td>
<td>版本号，如1.0</td>
</tr>
<tr>
<td>@see</td>
<td>与某些类有关系，建议查看类，如java.lang.String</td>
</tr>
<tr>
<td>@param</td>
<td>用于说明传入的参数信息</td>
</tr>
<tr>
<td>@return</td>
<td>用于说明返回值</td>
</tr>
</tbody></table>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><ul>
<li>被final修饰，不能被继承</li>
<li>内部储存的是char数组-char[]</li>
<li>储存的对象不可更改-final<blockquote>
<p>源代码<code>private final char value[]</code></p>
</blockquote>
</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>Java推荐我们使用字面量形式创建字符串对象，因为只有使用字面量创建时才会检查要不要被重用</li>
<li>new String()创建对象时一定会新生成一个对象，而且字符串对象在改变时(计算)时一定会创建新的字符串对象(就算值相同，就算在创建时，都不会重用)</li>
<li>编译器：在编译期会计算好能确定一个计算表达式结果的值，并将结果编译到class文件中，不会影响执行性能，如<code>String s=&quot;123&quot;+&quot;abc&quot;</code>编译到class是<code>String s=&quot;123abc&quot;</code></li>
<li>一定注意char与int的加减再与String拼接问题（注意单双引号），如：<code>&#39;a&#39;+1+&quot;b&quot; : 98b</code></li>
</ol>
<h3 id="java-lang-String"><a href="#java-lang-String" class="headerlink" title="java.lang.String"></a>java.lang.String</h3><ul>
<li>构造方法：<code>String 名 = &quot;xx&quot;</code></li>
<li>构造方法：<code>String 名 = new String(String str)</code></li>
<li>构造方法：<code>String 名 = new String(Byte data[,int start,int length][,String cs])</code>默认/cs指定字符集将字节数组转为String</li>
</ul>
<table>
<thead>
<tr>
<th>String类的API名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int length()</td>
<td>获取当前字符串长度(字符个数)</td>
</tr>
<tr>
<td>int indexOf(String str[,int index])</td>
<td>[从index位置开始]查找str在字符串中首位的位置，如果没有返回-1</td>
</tr>
<tr>
<td>int lastIndexOf(String str)</td>
<td>查找str在字符串中最后出现的首位的位置，如果没有返回-1</td>
</tr>
<tr>
<td>String substring(int start[,int end])</td>
<td>截取范围内的字符串，含头不含尾;不写end直接截取到末尾</td>
</tr>
<tr>
<td>String trim()</td>
<td>去除当前字符串两边的空白字符</td>
</tr>
<tr>
<td>char charAt(int index)</td>
<td>获取当前字符串中指定位置的字符</td>
</tr>
<tr>
<td>boolean startsWith(String str)<br>boolean endsWith(String str)</td>
<td>判断当前字符是否是以给定的字符串开始或结尾的</td>
</tr>
<tr>
<td>String toUpperCase()<br>String toLowerCase()</td>
<td>将当前字符串中的英文部分转换为全大写或全小写</td>
</tr>
<tr>
<td>String static valueOf()</td>
<td>转化为字符串，还有一种方法<code>+&quot;&quot;</code>，但代码性能更好</td>
</tr>
<tr>
<td>byte[] getBytes([String cs])</td>
<td>将当前字符串按照系统默认/cs指定字符集转换为字节</td>
</tr>
<tr>
<td>boolean matches(RegEx)</td>
<td>将一个字符串与正则表达式匹配</td>
</tr>
<tr>
<td>String[] split(String RegEx)</td>
<td>将字符串根据正则表达式拆分分隔成字符串数组</td>
</tr>
<tr>
<td>String replaceAll(String RegEx,String replacecement)</td>
<td>将字符串中匹配到的字符串替换成replacecement</td>
</tr>
</tbody></table>
<h3 id="java-lang-StringBuilder-StringBuffer"><a href="#java-lang-StringBuilder-StringBuffer" class="headerlink" title="java.lang.StringBuilder/StringBuffer"></a>java.lang.StringBuilder/StringBuffer</h3><p>String字符串只要一改变就会创建新对象，Java对String的优化<strong>只针对重用不针对修改</strong>，因此java提供了一个类：java.lang.StringBuilder，该类内部维护了一个可变的字符数组，修改都在这里进行，因此解决了字符串修改带来的问题。</p>
<blockquote>
<p>注：StringBuilder本身不是字符串类，只是用来修改字符串的API,提供了修字符串的操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = new StringBuilder([String])</span><br><span class="line">String s = builder.toString();</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>StringBuilder类的API名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuilder append(String str)</td>
<td>追加字符串</td>
</tr>
<tr>
<td>StringBuilder insert(int dstOffset,String s)</td>
<td>插入字符串</td>
</tr>
<tr>
<td>StringBuilder delete(int start,int end)</td>
<td>删除字符串</td>
</tr>
<tr>
<td>StringBuilder replace(int start,int end,String str)</td>
<td>替换字符串</td>
</tr>
<tr>
<td>StringBuilder reverse()</td>
<td>字符串反转</td>
</tr>
</tbody></table>
<blockquote>
<p>StringBuilder类型的方法返回的都是StringBuilder的类型，返回的都是自己的引用，所以可以简化连续操作为：<code>builder.append().insert().delete()</code><br>字符串的拼接操作是通过StringBuilder的append方法实现的</p>
</blockquote>
<table>
<thead>
<tr>
<th>.</th>
<th>.</th>
<th>.</th>
<th>.</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuffer</td>
<td>线程安全的</td>
<td>同步处理的</td>
<td>性能稍慢</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>线程非安全的</td>
<td>并发处理的</td>
<td>性能稍快</td>
</tr>
</tbody></table>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><table>
<thead>
<tr>
<th>字符集合</th>
<th>说明</th>
<th>量词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[abc]</td>
<td>a或b或c</td>
<td>{n}</td>
<td>出现n次</td>
</tr>
<tr>
<td>[^abc]</td>
<td>不是a/b/c</td>
<td>{n,m}</td>
<td>出现n-m次</td>
</tr>
<tr>
<td>[a-zA-Z0-9]</td>
<td>字母及数字</td>
<td>{n,}</td>
<td>出现最少n次</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[^bc]]</td>
<td>除了b/c的小写字母</td>
<td>{0,m}</td>
<td>出现最多m次</td>
</tr>
<tr>
<td>\d</td>
<td>=[0-9]</td>
<td>?</td>
<td>一次或者没有={0,1}</td>
</tr>
<tr>
<td>\w</td>
<td>=[a-zA-Z0-9_]</td>
<td>+</td>
<td>至少出现一次={1,}</td>
</tr>
<tr>
<td>\s</td>
<td>空白=[\t\n\x0B\f\r]</td>
<td>*</td>
<td>出现任意次={0,}</td>
</tr>
<tr>
<td>注意：</td>
<td><code>.</code>表示任意字符，<code>^</code>、<code>&amp;</code>表示开始与结束<br><code>\D\W\S</code>是与之小写相反的含义</td>
<td>()</td>
<td>用于分组同时</td>
</tr>
</tbody></table>
<ul>
<li>\w  原词：word   含义： 查找单词字符</li>
<li>\b   原词：border  含义：匹配单词边界</li>
<li>\d   原词：digital    含义：查找数字</li>
<li>\s   原词：space    含义：查找空白字符</li>
<li>\n  原词：newline  含义：查找换行符</li>
<li>\f   原词：form feed  含义：查找换页符</li>
<li>\r   原词：retrun 含义：查找回车符</li>
<li>\t   原词：tab      含义：查找制表符</li>
<li>\v  原词：Vertical tab  含义：垂直制表符</li>
</ul>
<blockquote>
<p>Java中会看到<code>\\.</code>是因为Java为正则表达式的转义斜线进行了转义<br><code>.</code>在正则表达式中表示所有字符<code>\.</code>是正则表达式来转义为普通的点<code>\\.</code>是因为java认为<code>\.</code>语法有问题，需要把<code>\</code>转义为普通<code>\</code></p>
</blockquote>
<h2 id="Object、包装类"><a href="#Object、包装类" class="headerlink" title="Object、包装类"></a>Object、包装类</h2><h3 id="Object-toString"><a href="#Object-toString" class="headerlink" title="Object.toString()"></a>Object.toString()</h3><ul>
<li>Java语言中很多地方都会默认调用对象的toString方法，如字符串+对象、输出语句、Arrays.toString()等</li>
<li>toString()方法默认返回的是：类名@地址</li>
<li>Java自带类基本都重写了该方法，强烈建议自己写的类也重写该方法</li>
<li>重写toString方法原则上返回的字符串应当包含当前对象的属性信息</li>
</ul>
<h3 id="Object-equals"><a href="#Object-equals" class="headerlink" title="Object.equals()"></a>Object.equals()</h3><ul>
<li>规定用于对比两个对象是否“相同”</li>
<li>Java自带类基本都重写了该方法，如果不重写，底层相当于使用<code>==</code>判断</li>
<li><code>==</code>用于比较两者是否相同：基本数据类型的值/引用数据类型的引用</li>
</ul>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>8种基本类型是以值的形态存在的，不是以对象的形态存在的，所以封装、多态等不适用于基本数据类型，为解决这个问题，Java提供了包装类：</p>
<ol>
<li>包装类是final修饰的，没有子类。内部储存值也是final修饰，不可更改</li>
<li>Integer、Long、Double、Short、Float、Byte、Character、Boolean</li>
</ol>
<h4 id="包装类的创建方法："><a href="#包装类的创建方法：" class="headerlink" title="包装类的创建方法："></a>包装类的创建方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = Integer.valueOf(int);</span><br><span class="line">Integer i2 = new Integer(int);</span><br><span class="line">Integer i3 = 120;</span><br></pre></td></tr></table></figure>
<ul>
<li>建议使用<code>valueOf()</code>方法创建对象，通过这种方法有些包装类会有类似String那样重用现象：如Integer重用-128～127，但是Double不重用，等同于new</li>
<li>Byte、Character、Integer、Short、Long可以，另三个否</li>
<li>JDK1.5及以上可以包装类&lt;–&gt;基本数据类型直接赋值转换，编译期编译器补全代码，叫做自动装箱拆箱特性</li>
</ul>
<h4 id="包装类转换为基本类型方法："><a href="#包装类转换为基本类型方法：" class="headerlink" title="包装类转换为基本类型方法："></a>包装类转换为基本类型方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = i1.intValue();</span><br><span class="line">double d = i1.doubleValue();</span><br><span class="line">byte b = i1.byteValue();</span><br></pre></td></tr></table></figure>
<ul>
<li>每个数字包装类都有这些类似方法，包括大值转小值</li>
<li>大转小会精度缺失，二进制高位省略</li>
</ul>
<h4 id="包装类的常用API"><a href="#包装类的常用API" class="headerlink" title="包装类的常用API"></a>包装类的常用API</h4><table>
<thead>
<tr>
<th>java.lang.Number类API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int Interger.parseInt(String str)</td>
<td>将字符串类型转换为对应基本类型，”123.0”在此会报错，只能”123”</td>
</tr>
<tr>
<td>double Double.parseDouble(String str)</td>
<td>但是注意格式要正确，否则抛出NumberFormatException异常</td>
</tr>
</tbody></table>
<h2 id="日期操作"><a href="#日期操作" class="headerlink" title="日期操作"></a>日期操作</h2><h3 id="java-util-Date"><a href="#java-util-Date" class="headerlink" title="java.util.Date"></a>java.util.Date</h3><ul>
<li>Date的每一个实例用于表示一个时间，内部维护一个long值，该值保存的是自1970-1-1到当前Date所表示的时间之间经过的毫秒</li>
<li>注意其Date表示的时间是格林尼治时间，为0时区时间，系统显示时会添加时区时间显示</li>
<li>Date内部由于存在千年虫和时区的问题，因此大部分方法都被声明为过时的，不再建议使用，大多数Calendar类取代</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>有参构造</td>
<td>分配 Date 对象并初始化此对象当前时间</td>
</tr>
<tr>
<td>有参构造Date(long date)</td>
<td>分配 Date 对象并初始化此对象</td>
</tr>
<tr>
<td>void setTime(long time)</td>
<td>设置此 Date 对象，以表示1970-1-1 00:00:00 GMT以后 time 毫秒的时间点</td>
</tr>
<tr>
<td>long getTime()</td>
<td>返回自1970-1-1 00:00:00 GMT以来此 Date 对象表示的毫秒数</td>
</tr>
<tr>
<td>boolean after(Date when)</td>
<td>测试此日期是否在指定日期之后</td>
</tr>
<tr>
<td>boolean before(Date when)</td>
<td>测试此日期是否在指定日期之前</td>
</tr>
<tr>
<td>Object clone()</td>
<td>返回此对象的副本</td>
</tr>
<tr>
<td>int compareTo(Date anotherDate)</td>
<td>比较两个日期的顺序</td>
</tr>
</tbody></table>
<h3 id="java-text-SimpleDateFormat"><a href="#java-text-SimpleDateFormat" class="headerlink" title="java.text.SimpleDateFormat"></a>java.text.SimpleDateFormat</h3><ul>
<li>该类是用于格式化和解析日期的具体类，主要用于格式化(日期-&gt;文本)，解析(文本-&gt;日期)操作</li>
<li>构造方法：主要是 无参构造 和 传入一个给定模式的 有参构造，特定模式使用String表示，表示方法如下表</li>
<li>方法：<code>String format(Date date)</code> 将给定的时间对象按照格式转换为字符串</li>
<li>方法：<code>Date parse(String source)</code> 将给定的字符串按照格式返回一个Date对象 </li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
<td>yyyy年：2019年；yy年：19年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
<td>MM月：01月；M月：1月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
<td>dd日：06日；d日：6日</td>
</tr>
<tr>
<td>E</td>
<td>星期</td>
<td>有E这个标识 则显示 星期日 或 Sun</td>
</tr>
<tr>
<td>a</td>
<td>AM或PM标识</td>
<td>显示 下午(AM) 或 上午(PM)</td>
</tr>
<tr>
<td>H</td>
<td>小时(24小时制)</td>
<td></td>
</tr>
<tr>
<td>h</td>
<td>小时(12小时制)</td>
<td></td>
</tr>
<tr>
<td>m</td>
<td>分钟</td>
<td></td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
<td></td>
</tr>
</tbody></table>
<h3 id="java-util-Calendar"><a href="#java-util-Calendar" class="headerlink" title="java.util.Calendar"></a>java.util.Calendar</h3><ul>
<li>Calendar 抽象类，规定了操作时间的相关方法等</li>
<li>常用实现类：java.util.GregorianCalendar 格里高利历(阳历)</li>
<li>我们可以通过Calendar提供的静态方法getInstance来根据当前系统所在地区获取一个使用的实现类，大部分地区获取的都是格里高利历实现类</li>
<li>特别注意：Calendar中规定<font color="red">月份从0开始的</font>，使用表示记得+1</li>
<li>特别注意：Calendar中规定<font color="red">星期从周日开始的</font>，使用表示记得更改习惯</li>
<li>特别注意：Calendar中调用set()方法等设定时间时，<font color="red">底层并未进行计算</font>，只有执行了getTime()或add()方法后才会进行刷新，特别注意防止在刷新前有多个set()方法同时影响同一个值，这样的话后面的方法会覆盖掉前面的方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static Calendar getInstance()</td>
<td>使用默认时区和语言环境获得一个日历</td>
</tr>
<tr>
<td>Date getTime()</td>
<td>返回一个表示此 Calendar 时间值的 Date 对象</td>
</tr>
<tr>
<td>void setTime(Date date)</td>
<td>使用给定的 Date 设置此 Calendar 的时间</td>
</tr>
<tr>
<td>int get(int field)</td>
<td>返回给定日历字段的值</td>
</tr>
<tr>
<td>void set(int field,int value)</td>
<td>将给定的日历字段设置为给定值</td>
</tr>
<tr>
<td>int getActualMaximum(int field)</td>
<td>返回指定日历字段可能拥有的最大值</td>
</tr>
<tr>
<td>abstract void add(int field, int amount)</td>
<td>根据日历的规则，为给定的日历字段添加或减去指定的时间量</td>
</tr>
</tbody></table>
<ul>
<li>和天有关的时间分量：</li>
<li>DATE:月中的天</li>
<li>DATE_OF_MONTH:月中的天，与DATE是一样的</li>
<li>DATE_OF_WEEK:周中的天，就是星期几</li>
<li>DATE_OF_YEAR:年中的天，今年的第几天</li>
</ul>
<h2 id="文件及随机读写File、RandomAccessFile"><a href="#文件及随机读写File、RandomAccessFile" class="headerlink" title="文件及随机读写File、RandomAccessFile"></a>文件及随机读写File、RandomAccessFile</h2><h3 id="java-io-File"><a href="#java-io-File" class="headerlink" title="java.io.File"></a>java.io.File</h3><ul>
<li>操作文件或目录（创建，删除）</li>
<li>访问其表示的文件或目录的属性（名字,大小等）</li>
<li>访问一个目录的子项内容</li>
<li>但是<strong>不能访问</strong>文件数据</li>
<li>绝对路径与相对路径，推荐使用相对路，如<code>[./]src/xxx.java</code>或<code>xx.class.getResource(/img/xx.png)</code>等</li>
</ul>
<table>
<thead>
<tr>
<th>File类常用的API名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>File File(String str)</td>
<td>str为路径名(文件/目录)</td>
</tr>
<tr>
<td>String gerName()</td>
<td>返回文件名</td>
</tr>
<tr>
<td>Long length()</td>
<td>返回文件大小，单位大小LONG</td>
</tr>
<tr>
<td>boolean canRead()</td>
<td>判断是否可读</td>
</tr>
<tr>
<td>boolean canWrite()</td>
<td>判断是否可写</td>
</tr>
<tr>
<td>boolean isHidden()</td>
<td>判断是否为隐藏文件</td>
</tr>
<tr>
<td>boolean exists()</td>
<td>判断文件是否存在</td>
</tr>
<tr>
<td>boolean createNewFile()</td>
<td>创建新文件-IOException</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>删除文件</td>
</tr>
<tr>
<td>boolean mkdir()</td>
<td>创建单个文件夹,父目录没有会失败</td>
</tr>
<tr>
<td>boolean mkdirs()</td>
<td>创建多层多个文件夹,父目录没有会创建</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>删除空目录,注意有任何都不成功</td>
</tr>
<tr>
<td>boolean isFile()</td>
<td>判断是否文件</td>
</tr>
<tr>
<td>boolean isDirectory()</td>
<td>判断是否目录</td>
</tr>
<tr>
<td>File[] listFiles([FileFilter])</td>
<td>返回当前目录下[过滤后的]所有文件及目录</td>
</tr>
</tbody></table>
<h3 id="java-io-RandomAccessFile"><a href="#java-io-RandomAccessFile" class="headerlink" title="java.io.RandomAccessFile"></a>java.io.RandomAccessFile</h3><ul>
<li>专门用来读写文件数据的API，其基于指针对文件进行随机读写操作，读写操作非常灵活</li>
<li>构造方法常用两个：<code>RandomAccessFile(String name,String mode)</code>和<code>RandomAccessFile(File file,String mode)</code></li>
<li>模式(mode):”rw”读写模式，”r”只读模式</li>
<li>如果没有该文件，读写模式会自动创建，只读模式抛异常</li>
</ul>
<table>
<thead>
<tr>
<th>RandomAccessFile类常用的API名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>读一个字节数据，当读到末位返回-1</td>
</tr>
<tr>
<td>int read(byte[] data)</td>
<td>块读取，一次读取最多传入数组长度的数据到该数组，返回读取到的长度值，-1为末尾</td>
</tr>
<tr>
<td>void write(int)</td>
<td>写一个字节数据int的低八位</td>
</tr>
<tr>
<td>void write(byte[] data[,int offset,int len])</td>
<td>块写入，把数组的内容写入文件，从offset到len，解决最后一次长度问题</td>
</tr>
<tr>
<td>long getFilePointer()</td>
<td>返回当前RAF的指针位置</td>
</tr>
<tr>
<td>void seek(long pos)</td>
<td>设置指针位置</td>
</tr>
<tr>
<td>int readInt()</td>
<td>写4字节数据,readLong(long)写8字节数据,readDouble(double)写16字节数据等等</td>
</tr>
<tr>
<td>void writeInt(int)</td>
<td>写4字节数据,writeLong(long)写8字节数据,writeDouble(double)写16字节数据等等</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭文件</td>
</tr>
</tbody></table>
<h2 id="IO流操作"><a href="#IO流操作" class="headerlink" title="IO流操作"></a>IO流操作</h2><ul>
<li>节点流(低级流)：实际连接程序与数据源，最基础的流</li>
<li>处理流(高级流)：必须连接在其他流上存在，是对一个已存在的流的连接和封装</li>
<li>终端流：直接进行操作的流，非终端流一般称为中间流</li>
<li>流的操作一层一层套用，注意有的高级流可能内嵌了其他高级流或低级流</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = new FileOutputStream(&quot;pw.txt&quot;);</span><br><span class="line">OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;utf-8&quot;);</span><br><span class="line">BufferedWriter bw = new BufferedWriter(osw);</span><br><span class="line">PrintWriter pw = new PrintWriter(bw);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">.</th>
<th align="center">字节流</th>
<th align="center">字符流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">超类</td>
<td align="center">InputStream/OutputStream</td>
<td align="center">Reader/Writer</td>
</tr>
<tr>
<td align="center">低级流</td>
<td align="center">文件流</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">高级流</td>
<td align="center">缓冲流<br>对象流</td>
<td align="center">字符缓冲流<br>行刷新的缓冲字节流</td>
</tr>
</tbody></table>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><ul>
<li><code>abstract java.io.InputStream</code>：所有字节输入流的抽象超类，规定了读取字节的相关方法，抽象方法：<code>int read()</code>、<code>int read(byte[] data)</code>等</li>
<li><code>abstract java.io.OutputStream</code>：多有字节输出流的抽象超类，规定了写出字节的相关方法，抽象方法：<code>void write(int d);</code>、<code>void write(byte[] data)</code>等</li>
</ul>
<h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><ul>
<li>文件流是以对节点流(低级流)，用于对文件进行读写的流，功能上与RandomAccessFile一样</li>
<li>RAF是随机读写形式，文件流是顺序读写形式</li>
<li>虽然RAF更灵活，但基于流连接可以完成复杂数据的读写</li>
<li><code>FileInputStream(File file[,boolean append])</code></li>
<li><code>FileInputStream(String path[,boolean append])</code></li>
</ul>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><ul>
<li>缓冲流是一对高级流，在流连接中的作用是加快数据的读写效率</li>
<li>他们会将读写的数据统一转换为块读写以达到效率提高的目的</li>
<li><code>java.io.BufferedInputStream(InputStream in)</code></li>
<li><code>java.io.BufferedOutputStream(OutputStream out)</code></li>
<li>关闭时会先关闭前面的流最后关闭自己，所以只需要关闭离程序最近的高级流就可以</li>
<li>输出流中<code>void flush()</code>强制清空缓冲区，缓冲区未满时及时完成工作</li>
<li>close()方法包含flush()方法，但注意有需求时自己调用flush()</li>
</ul>
<h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><ul>
<li>对象流是一对高级流，可以读写java中任何对象</li>
<li>他们将对象其结果与一组字节相互转换</li>
<li><code>java.io.ObjectInputStream(InputStream in)</code></li>
<li><code>java.io.ObjectInputStream(OutputStream out)</code></li>
<li>对象所属的类必须实现序列化接口才可使用对象流，否则会抛出异常</li>
<li>序列化接口：java.io.Serializable</li>
<li><code>void writeObject(Object o)</code>和<code>Object readObject()</code></li>
<li><code>transient</code>关键字，在实现了序列化接口的类中，说明该词修饰的不被转换为对象流</li>
</ul>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><ul>
<li><code>abstract java.io.Reader</code>：所有字符输入流的抽象超类，规定了读取字符的相关方法，抽象方法：<code>int read()</code>、<code>int read(char[] chs)</code>等</li>
<li><code>abstract java.io.Writer</code>：多有字符输出流的抽象超类，规定了写出字符的相关方法，抽象方法：<code>void write(int c);</code>、<code>void write(char[] chs[,int offset,int len])</code>、<code>void write(String str)</code>等</li>
</ul>
<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><ul>
<li>转换流是一对高级流，是字符流的一对实现类</li>
<li>转换流一般不会作为终端流直接操作，但作为文件流与字符流的转换作用其作用十分重要</li>
<li><code>java.io.InputStreamReader(InputStream in[,String cs])</code></li>
<li><code>java.io.OutputStreamWriter(OutputStream out[,String cs])</code></li>
</ul>
<h3 id="缓冲字符流"><a href="#缓冲字符流" class="headerlink" title="缓冲字符流"></a>缓冲字符流</h3><ul>
<li>缓冲字符流是一对高级流，块写加速，按行写文本</li>
<li><code>java.io.BufferedWriter(Writer out)</code>但是一般使用PrintWriter</li>
<li><code>java.io.BufferedReader(Reader in)</code></li>
<li>使用<code>String readLine()</code>方法读取一行数据，读到结束返回null</li>
</ul>
<h3 id="行刷新缓冲字符流"><a href="#行刷新缓冲字符流" class="headerlink" title="行刷新缓冲字符流"></a>行刷新缓冲字符流</h3><ul>
<li>PrintWriter内包含了BufferedWriter且有自动刷新换行功能</li>
<li><code>java.io.PrintWriter(File file/String fileName/Writer writer/OutputStream out)</code></li>
<li><code>java.io.PrintWriter(String fileName[,String cs])</code>比较方便常用</li>
<li><code>java.io.PrintWriter(Writer writer[,boolean autoFlush])</code>打开自动行刷新，每输入一行自动flush()一次</li>
<li>只有在流连接的构造函数中才有自动行刷新的参数</li>
<li><code>void println()</code>输出字符串后换行方法</li>
</ul>
<h2 id="异常处理、异常API"><a href="#异常处理、异常API" class="headerlink" title="异常处理、异常API"></a>异常处理、异常API</h2><h3 id="异常简介"><a href="#异常简介" class="headerlink" title="异常简介"></a>异常简介</h3><ul>
<li>Throwable 所有异常的超类</li>
<li>Error、Exception(RuntimeException/IOException) 两种异常总类</li>
<li>错误、异常(运行时异常、受检异常)</li>
<li>使用try-catch-finally语句处理异常，或者throws抛出异常</li>
<li>finally：无论是否有错都会执行的代码部分，特殊情况如果try/catch中有return,会执行完return后半句,去执行finally后再回来return</li>
<li>但是System.close(0)并不会执行finally，会立即终止程序</li>
<li>方法内代码块中可以throw抛出一个自定的异常，RuntimeException不会强制处理</li>
<li>JDK1.7及以后，try()小括号内可以定义实现了<code>autoCloseable</code>接口的类的实例，这样可以不用写close()方法，编译器编译时改回正常书写方式编译。该编写为编译器认可</li>
<li>所有的流以及某些类都实现了<code>autocloseable</code>，正常书写方式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//因为作用域问题，流在try外面声明定义</span><br><span class="line">FileOutputStream fos = null;</span><br><span class="line">try &#123;</span><br><span class="line">	fos = new FileOutputStream(&quot;fos.dat&quot;);</span><br><span class="line">	fos.write(1);</span><br><span class="line">&#125;catch(IOException e) &#123;</span><br><span class="line">	System.out.println(&quot;出错了&quot;);</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">        //关闭之前判断是否为null</span><br><span class="line">		if(fos!=null) &#123;</span><br><span class="line">			fos.close();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ol>
<li>创建类，定义类名，做到见名知意</li>
<li>继承Exception或其子类</li>
<li>由于Exception实现了Serializable，可选定义序列化版本号</li>
<li>重写Exception定义的所有构造方法</li>
</ol>
<h3 id="处理异常方式"><a href="#处理异常方式" class="headerlink" title="处理异常方式"></a>处理异常方式</h3><p>1、JVM执行某句话出现异常<br>2、虚拟机结合情况实例化对应的异常实例<br>3、并将代码执行情况赋值到异常实例中<br>4、然后将异常抛出<br>5、检查catch处理异常的机制<br>6、无catch则继续向外抛出异常<br>7、一直抛出到最后，处理方式为JVM终止程序</p>
<h2 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h2><h3 id="java-net-Socket"><a href="#java-net-Socket" class="headerlink" title="java.net.Socket"></a>java.net.Socket</h3><ul>
<li>封装了TCP通讯的传输细节，使得我们使用它就可以完成与远端计算机的TCP连接以及数据传输</li>
<li>并且完成数据传输是基于两条流的读写</li>
<li><code>Socket(String host,int port)</code></li>
<li>Socket实例化的过程就是连接服务端的过程，成功连接则实例化成功，否则会在实例化过程中该抛出异常</li>
<li>通过<strong>IP地址</strong>找到网络上的服务端所在计算机，通过<strong>端口</strong>找到该机器上的服务端应用程序</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int getLocalPort()</td>
<td>返回本地连接的端口号</td>
</tr>
<tr>
<td>InetAddress getLocalAddress()</td>
<td>返回一个InetAddress数据对象，套接字绑定的本地地址</td>
</tr>
<tr>
<td>int getPort()</td>
<td>返回远端使用的端口号</td>
</tr>
<tr>
<td>InetAddress getInetAddress()</td>
<td>返回一个InetAddress数据对象，套接字绑定的远端地址</td>
</tr>
<tr>
<td>OutputStream getOutputStream()</td>
<td>返回字节输出流，其写出的字节流可以通过网络发送到远端</td>
</tr>
<tr>
<td>InputStream getInputStream()</td>
<td>返回字节输入流，其读取通过网络发送过来的字节流</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭此套接字，同时关闭了输入流与输出流</td>
</tr>
</tbody></table>
<h4 id="java-net-InetAddress"><a href="#java-net-InetAddress" class="headerlink" title="java.net.InetAddress"></a>java.net.InetAddress</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String getCanonicalHostName()</td>
<td>获取此IP地址的完全限定域名</td>
</tr>
<tr>
<td>String getHostAddress()</td>
<td>返回IP地址字符串(文本形式)</td>
</tr>
</tbody></table>
<h3 id="java-net-ServerSocket"><a href="#java-net-ServerSocket" class="headerlink" title="java.net.ServerSocket"></a>java.net.ServerSocket</h3><ul>
<li>向系统申请服务端口并监听该端口，客户端进行连接时，ServerSocket会自动创建一个Socket与客户端进行交互</li>
<li><code>ServerSocket(int port)</code></li>
<li><code>Socket accept()</code>该方法是一个阻塞方法，一直等待一个客户端连接为止，并返回Socket实例，可多次调用进行接收多个客户端的连接</li>
</ul>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="反射基础"><a href="#反射基础" class="headerlink" title="反射基础"></a>反射基础</h3><h4 id="获取Class对象的方式"><a href="#获取Class对象的方式" class="headerlink" title="获取Class对象的方式"></a>获取Class对象的方式</h4><ol>
<li>每个类都有一个class属性，通过 类.class 获取Class对象</li>
<li>每个对象都有getClass()方法，通过 对象.getClass() 获取Class对象</li>
<li>Class类的静态方法，Class.forName(完整类名) 获取Class对象</li>
</ol>
<ul>
<li>基本数据类型也有Class对应对象，包括void也有</li>
<li>包装数据类的静态成员TYPE返回对应基本数据类型类：Class&lt;?&gt; cls=Integer.TYPE;</li>
<li>通过forName()方法获取Class对象时，会把参数指定的类加载到内存中</li>
</ul>
<h3 id="java-lang-Class"><a href="#java-lang-Class" class="headerlink" title="java.lang.Class"></a>java.lang.Class</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static Class forName(String className)</td>
<td>返回与带有给定字符串名的类或接口相关联的 Class 对象</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称</td>
</tr>
<tr>
<td>String getSimpleName()</td>
<td>返回此 Class 对象的简单名称</td>
</tr>
<tr>
<td>Method[] getMethods()</td>
<td>返回一个 Method 对象的数组，每个Method对象表示一个方法</td>
</tr>
<tr>
<td>Method getMethod(String name[Class&lt;?&gt;… parameterTypes])</td>
<td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法</td>
</tr>
<tr>
<td>Object newInstance()</td>
<td>实例化该 Class 对象(仅适用于具有无参构造的类)</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>返回一个修饰符，是一个整数，可以通过Modifier类中的静态方法转换<br>Modifier：static String toString(int modifier)</td>
</tr>
<tr>
<td>Class&lt;?&gt; getSuperclass()</td>
<td>返回该 Class 对象父类的 Class 对象</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getInterfaces()</td>
<td>返回该 Class 对象实现的接口数组</td>
</tr>
<tr>
<td>Filed getField(String field)</td>
<td>获取名为field的字段的值(只能返回公共字段)，可以通过Field对象操作<br>Field：void set(Object obj, Object value)<br>Filed：Object get(Object obj) 对Object对象Field属性值的操作</td>
</tr>
<tr>
<td>Filed getDeclareField(String field)</td>
<td>获取名为field的字段的值(可以返回任意访问权限字段，但只能返回不能访问)<br>Filed：void setAccessible(boolean canAccess) 设置为true时可以访问私有字段值</td>
</tr>
</tbody></table>
<h3 id="java-lang-reflect-Method"><a href="#java-lang-reflect-Method" class="headerlink" title="java.lang.reflect.Method"></a>java.lang.reflect.Method</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String getName()</td>
<td>返回该Method所指方法的方法名</td>
</tr>
<tr>
<td>Object invoke(Object obj[Object… args])</td>
<td>调用obj对象的该Method对象方法(可传入参数)</td>
</tr>
</tbody></table>
<h2 id="Lambda函数式"><a href="#Lambda函数式" class="headerlink" title="Lambda函数式"></a>Lambda函数式</h2><ul>
<li>由JDK1.8开始引入的语句，主要是解决了Java缺失函数式编程特点的缺点</li>
<li>这是编译器认可的语句，编译时会更改为一般代码样式去编译</li>
<li>其语法为：<code>(参数)-&gt;{方法体}</code></li>
<li>参数部分：可以为空，表示没有参数；可以多个，表示多个参数；可以不写参数类型，前提是可以推断</li>
<li>方法体部分：如果方法体内只有一条语句，可以省略花括号{}；但如果这一句是return，则必须把return也省掉</li>
<li>特别注意：lambda表达式 与 匿名内部类 this关键字的区别！！–&gt;前者的this表示外部类，后者的this表示匿名类</li>
<li>常用在实现只含有一个抽象方法的接口的时候，Java中 某些接口在类声明上方有个注解 @FunctionalInterface 说明该接口可以用Lambda表达式，没有标注也不一定不可以</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/11/11/dshc/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(OOP)/">
                Java基础-面向对象(OOP)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-11-11</span>
            
            
            
                <span class="category">
                    <a href="/categories/语言编程/">语言编程</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Java基础-面向对象-OOP"><a href="#Java基础-面向对象-OOP" class="headerlink" title="Java基础-面向对象(OOP)"></a>Java基础-面向对象(OOP)</h1><h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><ol>
<li>对象：软件中存在的单个个体</li>
<li>类：对象的抽象、总结，对象的模板</li>
<li>成员变量、成员方法</li>
</ol>
<h3 id="定义类："><a href="#定义类：" class="headerlink" title="定义类："></a>定义类：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;修饰词&gt; class 类名&#123;</span><br><span class="line">    &lt;成员变量;&gt;</span><br><span class="line">    &lt;成员方法/类函数&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法的签名：就是方法名+参数列表；SendMsg(“Hello”);</p>
</li>
<li><p>方法重载Overload：<strong>方法名</strong>相同，<strong>参数列</strong>表必须不同(个数、类型)，但<font color="red"><strong>与修饰词、返回值无关</strong></font>，重载选择是编译器编译时决定的</p>
</li>
<li><p>构造函数：(可以重载)无返回值,名字和类名相同 一般用于初始化成员变量的值<br><code>&lt;访问修饰符&gt; 类名 (&lt;参数列表&gt;){构造方法体}</code></p>
<blockquote>
<p>没写构造函数，编译时会自动添加一个无参的构造函数。但是注意如果写了构造函数，编译时就<font color="red"><strong>不会再自动添加</strong></font>无参的构造函数！！</p>
</blockquote>
</li>
<li><p>this：代表自己本身这个对象，可用于：成员变量 成员函数 构造函数</p>
<blockquote>
<p>用this调用构造函数必须放在第一句,且只能放在构造函数中<br>如果子类变量与父类变量重名，this优先本类变量，如果子类没有重名变量，this指向父类变量</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>注意内存分配问题，对象的引用与实体，堆栈问题</p>
</blockquote>
<h3 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h3><p>类 –&gt; 对象<br><code>&lt;类名&gt; &lt;对象名&gt; = new &lt;类名&gt;(构造函数参数);</code></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的基础概念"><a href="#继承的基础概念" class="headerlink" title="继承的基础概念"></a>继承的基础概念</h3><ul>
<li>继承其他包中的类,需要先导入此类/包含此类的包，is-a原则</li>
<li>不写extends默认继承java.lang.Object类，也就是说所有类都时Object类的子类，都拥有Object类的变量及方法</li>
<li>一个类只能extends一个类，可以implements多个接口</li>
</ul>
<h3 id="如何继承类"><a href="#如何继承类" class="headerlink" title="如何继承类"></a>如何继承类</h3><ul>
<li>使用关键子<code>extends</code>进行继承，例：<code>class son extends farther{}</code></li>
<li>继承就是继承父类的所有成员函数和成员变量(注意权限问题,private不能直接访问)</li>
<li><font color="red">子类的<strong><em>属性、方法</em></strong>与父类的属性/方法重名是被Java允许的</font>，但注意区分，用this或super区别调用(如果子类变量与父类变量重名，this优先本类变量，如果子类没有重名变量，this指向父类变量)</li>
<li>内存结构：子类内存对象中存有父类内存对象的引用(new生成子类对象和父类对象两个)<blockquote>
<p>super：用法与this相同，在继承中常用在方法重写与构造函数中<br>相同的，用super调用构造函数时，也必须放在第一句,且只能放在构造函数中</p>
</blockquote>
</li>
</ul>
<h3 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h3><ul>
<li>子类的构造函数不写super编译器会自动添加super()无参的父类构造函数</li>
<li>子类的构造函数可以调用父类的其他构造函数，使用super()，但注意super()必须放在子类构造函数的第一句(根据参数列表确定调用的哪个构造函数)</li>
</ul>
<blockquote>
<p><font color="red"><strong>父类没写无参构造</strong></font>，且写了其他有参构造函数，编译器不会再自动添加无参构造函数，会导致<strong>子类构造函数中自动添加的super()报错</strong></p>
</blockquote>
<h3 id="继承中的方法重写"><a href="#继承中的方法重写" class="headerlink" title="继承中的方法重写"></a>继承中的方法重写</h3><ul>
<li><p><strong>方法重写</strong>：子类方法名与父类方法名相同，且形参列表相同，返回值与访问修饰符如下</p>
<ul>
<li><strong>返回值</strong>：也要相同，除非返回值类型为引用数据类型时，子类的返回值类型可以是父类返回值类型的子类</li>
<li><strong>访问修饰符</strong>：子类的访问修饰符 <strong>不能</strong> 比父类访问修饰符更严格</li>
<li><strong>异常处理</strong>：子类的异常类型要与父类相同，或者是父类异常类型的子类</li>
</ul>
</li>
<li><p>private方法不能被重写成功（不报错但是重写不成功，自我调用还是父类方法）</p>
</li>
<li><p>可以使用<code>super.方法名</code>，调用原方法，再另行添加自己的代码</p>
<blockquote>
<p>这里的super可以不必第一行，只有构造函数时super/this必须第一行</p>
</blockquote>
</li>
<li><p>@override，表明明确复写父类函数，编译器可检查错误</p>
</li>
<li><p>子类重写的内容覆盖父类内存对象中的原方法内容，所以向上转型后的调用是重写后的方法。注意：子类中与父类重名的成员变量不属于重写，在子类内存对象与父类内存对象分别储存着。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>重载与重写区别</th>
<th>位置</th>
<th>方法名</th>
<th>参数</th>
<th>返回值</th>
<th>修饰符</th>
</tr>
</thead>
<tbody><tr>
<td>重载&emsp;Overload</td>
<td>同类*</td>
<td>相同</td>
<td>不同</td>
<td><font color="red">无关</font></td>
<td><font color="red">无关</font></td>
</tr>
<tr>
<td>重写&emsp;Override</td>
<td>子类</td>
<td>相同</td>
<td>相同</td>
<td>相同*</td>
<td>相同*</td>
</tr>
</tbody></table>
<h2 id="抽象类、接口、内部类"><a href="#抽象类、接口、内部类" class="headerlink" title="抽象类、接口、内部类"></a>抽象类、接口、内部类</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>用<code>abstract</code>关键字定义<code>public/默认 abstract class 类名{};</code></li>
<li>抽象类不能生成对象(只能当父类)</li>
<li>抽象类被继承后需要重写抽象类中所有的抽象方法，如果子类是也抽象类则可以不全部重写父类抽象方法</li>
<li>抽象方法：用<code>abstract</code>修饰的方法，特点是没有函数体无大括号<code>public abstract void 函数名();</code></li>
<li>抽象类其他特性与普通类一样，但是注意不可以抽象构造方法。</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><ul>
<li>用<code>interface</code>关键字定义<code>public/默认 interface 接口名{};</code></li>
<li>在类的声明后面使用<code>implements</code>加接口名逗号分隔实现</li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>所有属性只能是公有静态常量,不写/不写全则编译器自动增为<code>public static final</code></li>
<li>所有方法只能是公有抽象方法,不写/不写全则编译器自动增为<code>public abstract</code></li>
<li>没有静态块，构造函数(不能实例化)。静态方法和默认方法很少使用，暂时忽略</li>
</ul>
<blockquote>
<p>接口没有构造函数不能实例化对象，has-a原则<br>接口一般是某种功能的总结，接口可以继承多个接口<br>更容易实现程序架构的搭建-面向接口编程</p>
</blockquote>
<h3 id="内部类-Inner-！Outer"><a href="#内部类-Inner-！Outer" class="headerlink" title="内部类(Inner)！Outer"></a>内部类(Inner)！Outer</h3><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul>
<li>在成员变量的位置声明的内部类，可以使用4种<strong>全部的访问修饰符</strong></li>
<li>实例化内部类对象需要外部类的支持，<code>&lt;内部类&gt; x = &lt;外部类对象&gt;.new &lt;内部类&gt;</code></li>
<li>当前类如果需要多个方法中使用这个类且只有自己的类使用，定义内部类<hr></li>
<li>外部类和内部类的私有成员可以相互调用，外部类实例化对象访问，内部类直接访问</li>
<li>允许内部类和外部类定义同名成员，内部类调用外部类成员时<code>&lt;外部类&gt;.this.&lt;成员&gt;</code></li>
<li>内部类编译时产生独立的<strong>class文件</strong><code>外类名$内类名.class</code></li>
</ul>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul>
<li>继承或实现接口时直接使用：<code>&lt;父类&gt; name = new &lt;父类&gt;{子类代码块}</code></li>
<li>一个类的某方法临时使用时，更有针对性</li>
<li>匿名内部类访问定义该匿名内部类的方法的局部变量(参数/变量)时，如果局部变量没有另外修改值则可访问，但一直不可修改(视为final只可访问不可修改)。</li>
<li>如果方法中/内部类中修改了局部变量值，内部类不可访问该值，所以一般如果这样使用，通称在需要调用的变量声明前使用final(参数变量也可以哦)</li>
<li>JAR1.8以前如果上方使用，必须添加final否则报错<hr></li>
<li>外部类和内部类的私有成员可以相互调用，外部类实例化对象访问，内部类直接访问</li>
<li>允许内部类和外部类定义同名成员，内部类调用外部类成员时<code>&lt;外部类&gt;.this.&lt;成员&gt;</code></li>
<li>内部类编译时产生独立的<strong>class文件</strong><code>外类名$数字.class</code></li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h3><ol>
<li>向上造型数组储存</li>
<li>向上造型方法重写</li>
<li>向下造型调用私有方法<blockquote>
<p>强制类型转换<code>(需要类型)实例化对象</code>，容易产生ClassCastException错误<br>关键字<code>对象instanceof类型</code>返回布尔判断类型，尽量避免，并不是面向对象思想做法</p>
</blockquote>
</li>
</ol>
<h3 id="对象转型"><a href="#对象转型" class="headerlink" title="对象转型"></a>对象转型</h3><ul>
<li><p><strong>向上造型</strong>：f和s指向堆中同一个对象,但f只能调用自己类的变量和方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">farther f = new son();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>向下造型</strong>：（官方没承认的民间说法）一般不可以，例外：前提先向上转型再向下转型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">farther f = new son();</span><br><span class="line">son s = (son)f;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="关键字-访问控制-static-final"><a href="#关键字-访问控制-static-final" class="headerlink" title="关键字-访问控制/static/final"></a>关键字-访问控制/static/final</h2><h3 id="访问控制修饰词"><a href="#访问控制修饰词" class="headerlink" title="访问控制修饰词"></a>访问控制修饰词</h3><table>
<thead>
<tr>
<th>权限修饰词</th>
<th>作用范围</th>
<th>类内部</th>
<th>同包</th>
<th>不同包<br>子类</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>public(共有)</td>
<td>其他包可以通过全名调用(导入后可以不写包名)</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>其他包作为子类可以调用,不过只能修饰变量和函数<br>主要用于可以被子类继承使用(只有子类)</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>default(默认不写)</td>
<td>同一个包才可以使用</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>private(私有)</td>
<td>同一个类才可以使用</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>class只有两种修饰方式：默认/public</li>
<li>通过访问修饰符封装类属性：<ol>
<li>变量设为pravate私有的</li>
<li>编写public公有的get/set方法进行判断赋值</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="static静态修饰词"><a href="#static静态修饰词" class="headerlink" title="static静态修饰词"></a>static静态修饰词</h3><table>
<thead>
<tr>
<th>static的使用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Static 变量</td>
<td>推荐直接<code>类名.静态变量</code>进行访问,等同于<code>实例化.静态变量</code><br>因为静态变量是共享的，是指向同一块内存的</td>
</tr>
<tr>
<td>Static 方法</td>
<td>推荐直接<code>类名.静态方法</code>进行调用,等同于<code>实例化.静态方法</code><br><strong>静态方法中无法使用实例成员：</strong><br>&emsp;静态方法只能访问静态变量，静态方法只能调用静态方法<br>&emsp;普通方法可以访问所有变量，普通方法可以调用所有方法</td>
</tr>
<tr>
<td>Static 类</td>
<td>很少使用，暂时忽略</td>
</tr>
<tr>
<td>Static 代码块</td>
<td>静态代码块 static{} 匿名代码块 {}<br>在类载入内存时执行它,且只运行一次,一般很少用<br>当类被实例化,执行顺序:静态块(1次)&gt;匿名块&gt;构造函数</td>
</tr>
</tbody></table>
<blockquote>
<p>static修饰的变量和方法不可以用this或super<br>静态方法中无法使用实例成员的<strong>根本原因</strong>是无法this<br>静态方法重写不成功（不报错，但是调用还是父类方法）<br>在类载入内存时：1实例化对象2使用类中静态成员<br>final+static定义的常量声明时赋值被使用，<font color="red"><strong>在编译时调用常量位置会被常量值替换</strong></font>，所以运行时不会加载常量所在类，提高运行效率</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final MY_COUNT = 1;</span><br><span class="line">System.out.println(MyClass.MY_COUNT);</span><br><span class="line">System.out.println(1);</span><br></pre></td></tr></table></figure>

<p>以上代码编译后，第二行代码会被编译成第三行代码编译的样子。(运行时MyClass类不会被加在)<br>注意final static定义的常量，无法在构造中赋值，只能声明直接赋值 或 在静态代码块中赋值，这样的常量被调用时依然先加载类后使用，并非上述</p>
<h3 id="final修饰词"><a href="#final修饰词" class="headerlink" title="final修饰词"></a>final修饰词</h3><table>
<thead>
<tr>
<th>final的使用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>final 类</td>
<td>该类不可以被继承,public final class (){}</td>
</tr>
<tr>
<td>final 方法</td>
<td>该方法不可以被重写,public final static void fuc(){}</td>
</tr>
<tr>
<td>final 变量</td>
<td>该变量不可以被重新赋值,final int a = 0;</td>
</tr>
<tr>
<td>final 对象</td>
<td>不能修改其引用(指针),final class obj1 = new class();obj1 = obj2不可以;但可以改变引用(指针)指向的对象的值</td>
</tr>
</tbody></table>
<blockquote>
<p>final 变量：声明时直接赋值 或 声明后在<strong>每个</strong>构造中赋值。final也可以修饰形参变量</p>
</blockquote>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/11/11/dshc/Java%E5%9F%BA%E7%A1%80-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80(Basic)/">
                Java基础-语言基础(Basic)
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-11-11</span>
            
            
            
                <span class="category">
                    <a href="/categories/语言编程/">语言编程</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Java基础-语言基础-Basic"><a href="#Java基础-语言基础-Basic" class="headerlink" title="Java基础-语言基础(Basic)"></a>Java基础-语言基础(Basic)</h1><h2 id="Java开发环境"><a href="#Java开发环境" class="headerlink" title="Java开发环境"></a>Java开发环境</h2><h3 id="安装Java开发环境-Window系统"><a href="#安装Java开发环境-Window系统" class="headerlink" title="安装Java开发环境(Window系统)"></a>安装Java开发环境(Window系统)</h3><ol>
<li>下载JDK –&gt; 安装JDK –&gt; 验证安装成功</li>
<li>配置环境变量：JAVA_HOME–JDK根目录、、Path–bin目录、、CLASSPATH–.(java1.7以后可以不用写了)</li>
<li>测试：java -version</li>
<li>安装eclipse</li>
</ol>
<h2 id="Java基础说明"><a href="#Java基础说明" class="headerlink" title="Java基础说明"></a>Java基础说明</h2><h3 id="Java说明"><a href="#Java说明" class="headerlink" title="Java说明"></a>Java说明</h3><ul>
<li>一个Java文件可以有多个类但提倡只有一个</li>
<li>一个Java文件只能有一个public class</li>
<li>Main函数是java的主入口PSVM进行主动运行</li>
<li>Main函数不属于成员函数，只是寄居在Class中</li>
<li>Main函数的参数args是启动java时附带的参数</li>
<li>JVM默认导入java.lang.*包</li>
</ul>
<h3 id="Java中的注释"><a href="#Java中的注释" class="headerlink" title="Java中的注释"></a>Java中的注释</h3><ol>
<li><code>//</code><strong>单行注释：</strong>从//开始到本行结束</li>
<li><code>/*</code>开始<code>*/</code>结束，<strong>多行注释</strong></li>
<li><code>/**</code>开始<code>*/</code>结束，<strong>文档注释：</strong>javadoc会提取生成帮助文档，类方法常量</li>
</ol>
<h3 id="Java标示符"><a href="#Java标示符" class="headerlink" title="Java标示符"></a>Java标示符</h3><p>Java中的标示符组成：数字、字母、下划线、美元符<br>Java中大小写敏感、没有长度限制，不可以用java关键字，不可以用数字开头<br>Java命名规范：</p>
<table>
<thead>
<tr>
<th>规范</th>
<th>方式</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><strong>类名或接口名</strong></td>
<td>每个首字母大写</td>
<td>HelloWord</td>
</tr>
<tr>
<td><strong>方法名</strong></td>
<td>首字母小写，其他首字母都大写</td>
<td>getName</td>
</tr>
<tr>
<td><strong>常量名</strong></td>
<td>全部字母大写，用_连接</td>
<td>BLUE_COLOR</td>
</tr>
<tr>
<td><strong>变量名</strong></td>
<td>首字母小写，后面的首字母大写，其他首字母小写</td>
<td>tomScrop</td>
</tr>
<tr>
<td><strong>包名</strong></td>
<td>全部字母小写</td>
<td>com.baidu.demo</td>
</tr>
</tbody></table>
<h2 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h2><p>输出语句：<code>System.out.println(&quot;&quot;);</code><br>输入语句：<code>int a = new Scanner(System.in).nextInt();</code></p>
<table>
<thead>
<tr>
<th>命名</th>
<th>语法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>变量声明</td>
<td>&lt;类型&gt; &lt;变量名&gt;</td>
<td>int age;<br>int age = 20;</td>
</tr>
<tr>
<td>常量声明</td>
<td>使用final</td>
<td>public final static int a = 0;<br>公用的,不被修改的,只有一份的</td>
</tr>
<tr>
<td>创建对象</td>
<td>&lt;类名&gt; &lt;对象名&gt;=new &lt;构造函数&gt;;</td>
<td>Map map=new Map();</td>
</tr>
<tr>
<td>if分支</td>
<td>if(布尔表达式){<br>}else if(布尔表达式){<br>}else{}</td>
<td>不使用大括号默认认为下一个；前的语句属于if-true分支内,效率比switch低,switch直接进入不是挨个判断</td>
</tr>
<tr>
<td>switch分支</td>
<td>switch(表达式){<br>default:<br>&emsp;默认语句;<br>&emsp;break;<br>case 常量:<br>&emsp;语句;<br>&emsp;break;}</td>
<td>case说明程序开始，break说明结束(退出分支),没有则case穿透,default可以不在最后面但是不要忘记break，byte/char/short/int/String(1.7以后支持)不支持小数布尔等</td>
</tr>
<tr>
<td>for循环</td>
<td>for(int i = 0;i &lt; 9;i++){}</td>
<td>for(;;){}默认死循环,()内多条语句用<code>,</code>但是注意第一块如果有声明只能一个类型的多声明</td>
</tr>
<tr>
<td>while循环</td>
<td>while(布尔表达式){}<br>do{}while(布尔表达式)</td>
<td>continue跳过本次循环继续下次循环</td>
</tr>
<tr>
<td>foreach遍历</td>
<td>for(Object o:数组/集合){}</td>
<td>JDK1.5开始支持的，仅是编译器认可，编译过程中数组改回for语句，集合改回迭代器语句</td>
</tr>
</tbody></table>
<blockquote>
<p>break XX;跳出XX标记的循环<br>continue XX;跳出本次循环进行XX标记循环的下一次循环</p>
</blockquote>
<h2 id="Java运算符号"><a href="#Java运算符号" class="headerlink" title="Java运算符号"></a>Java运算符号</h2><p><strong>基本运算符</strong></p>
<table>
<thead>
<tr>
<th>命名</th>
<th>语法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>算术运算</td>
<td><code>+,-,*,/,%,++,--</code></td>
<td>2/3*6得0</td>
</tr>
<tr>
<td>关系运算</td>
<td><code>&gt;,&lt;,&gt;=,&lt;=,==,!=</code></td>
<td></td>
</tr>
<tr>
<td>逻辑运算</td>
<td><code>!,&amp;&amp;,||</code></td>
<td></td>
</tr>
<tr>
<td>位运算</td>
<td><code>~,&amp;,|,^,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;</code></td>
<td></td>
</tr>
<tr>
<td>赋值符号</td>
<td><code>=,+=,-=,*=,/=,%=</code></td>
<td>自带强转</td>
</tr>
<tr>
<td>字符串连接</td>
<td><code>+</code></td>
<td></td>
</tr>
<tr>
<td>三目运算符</td>
<td><code>条件?真:假</code></td>
<td>真假的值会先统一到较大的数据类型</td>
</tr>
</tbody></table>
<p><strong>使用注意事项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i++ --&gt; i自加,自加之前的值参与计算  </span><br><span class="line">++i --&gt; i自加,自加之后的值参与计算  </span><br><span class="line">int i=0;i=i++; --&gt; i:0  </span><br><span class="line">+= --&gt; i+=5.5相当于i=(int)(i+5.5)  </span><br><span class="line">&amp;&amp; --&gt; 遇到一个F,后面就不再执行(短路特性)  </span><br><span class="line">|| --&gt; 遇到一个T,后面就不再执行(短路特性)  </span><br><span class="line">例题：int i = 5;boolean b = i &gt; 6 &amp;&amp; i++ &gt; 7;  </span><br><span class="line">结果：b=false;i=5;因为执行到i&gt;6就结束了  </span><br><span class="line">扩展：boolean b = i &gt; 4 &amp;&amp; i++ &gt; 7;结果i=6  </span><br><span class="line">obj1 == obj2 判断的是对象的指针  </span><br><span class="line">String.equals(String) 是对比内容</span><br></pre></td></tr></table></figure>

<h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><p>数据类型分类：<strong>基本数据类型(8种)</strong> 和 <strong>引用数据类型</strong></p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>占用位数</th>
<th>使用范围</th>
<th>数据范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte字节</td>
<td>[8位]</td>
<td>IO常用</td>
<td>-128~127</td>
</tr>
<tr>
<td>short短整型</td>
<td>[16位]</td>
<td>与其他语言兼容使用</td>
<td>-32768~32767三万</td>
</tr>
<tr>
<td>int整型</td>
<td>[32位]</td>
<td>十进制普通表示,八进制0开头,十六进制0x开头</td>
<td>-2147483648~..7二十亿</td>
</tr>
<tr>
<td>long长整型</td>
<td>[64位]</td>
<td>注意超过int类型数值后<strong>加个L</strong></td>
<td>-9223372036854775808~..7</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>整数的直接量默认为int</td>
</tr>
<tr>
<td>float单浮点</td>
<td>[4字节]</td>
<td>不常用，不精准，数值后<strong>加个F</strong></td>
<td>小数的直接量默认为double</td>
</tr>
<tr>
<td>double双浮点</td>
<td>[8字节]</td>
<td>常用，较精准</td>
<td>-</td>
</tr>
<tr>
<td>char字符型</td>
<td>[2字节]</td>
<td>表示<strong>一个</strong>字符’’空也不行</td>
<td>无符号16位类型，0到65535</td>
</tr>
<tr>
<td>Boolean布尔型</td>
<td>[1字节]</td>
<td>True - False</td>
<td>-</td>
</tr>
</tbody></table>
<blockquote>
<p>变量无初始值会报错(类实例化时成员变量初始化0,false,null)<br>混合型计算,结果为最大数值类型<br>转义字符：<code>\b \n \e \t \\</code>、<code>\uXXXX \XXX</code>等<br>小心数据溢出，程序不会报错，浮点型计算产生的舍入误差</p>
</blockquote>
<p>数据类型转换：</p>
<ol>
<li>自动类型转换：Java会自动转换为较大的数据类型</li>
<li>char、byte、shor &lt;==&gt; int 直接来回转化是因为java内部特殊处理</li>
<li>char、byte、short之间发生计算都会转化为int 因为java内部特殊处理</li>
<li>char、byte、short可以直接赋值int型是因为Java在赋值时做了特殊处理</li>
<li>注意final修饰的不会自动转化类型！！尤其是上述注意！！</li>
<li>这里的大小注意long&lt;float，因为整数代表不了科学计数的小数</li>
<li>强制类型转换：&lt;数据类型&gt; &lt;数值/数据类型&gt;可以实现转为较小的类型</li>
</ol>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><table>
<thead>
<tr>
<th>引用数据类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>class</td>
</tr>
<tr>
<td>接口</td>
<td>interface</td>
</tr>
<tr>
<td>数组</td>
<td>是一种特殊的对象，不是类</td>
</tr>
<tr>
<td>枚举</td>
<td>用于自定义数据类型，JDK1.5引入</td>
</tr>
</tbody></table>
<h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><ul>
<li>数组的静态声明法:int[] arr = {1,2,3,4,5};(声明了5个)</li>
<li>数组的动态声明法:int[] arr = new int[10];(声明了10个)</li>
<li>二维数组声明方法:int[][] arr = new int[3][0];</li>
<li>引用数据类型数组声明:class[] obj = new class[3];(声明了3个class对象)  <blockquote>
<p>这样的操作只是<font color="red"><strong>声明</strong></font>，并没有实例化及初始化！！并没有产生内存对象(引用)！</p>
</blockquote>
</li>
</ul>
<h3 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h3><ul>
<li>数组的长度：arr.length;arr.[1].length;  </li>
<li>数组的遍历：for(String s : stringArray){}</li>
</ul>
<h3 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h3><p><strong>复制方法</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(src, srcPos, dest, destPos, length);  </span><br><span class="line">&gt; Pos:Start 0 ; length:length in src  </span><br><span class="line">Arrays.copyOf(original, newLength);</span><br><span class="line">&gt; 可实现扩容缩容</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意引用数据类型的内存分配问题，直接赋值引用</p>
</blockquote>
<p><strong>排序方法(顺序)</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(array);</span><br></pre></td></tr></table></figure>

<h2 id="Java方法的定义和使用"><a href="#Java方法的定义和使用" class="headerlink" title="Java方法的定义和使用"></a>Java方法的定义和使用</h2><h3 id="定义语句"><a href="#定义语句" class="headerlink" title="定义语句"></a>定义语句</h3><p><code>修饰词 返回值 函数名(形参列表){函数体}</code></p>
<h3 id="修饰词"><a href="#修饰词" class="headerlink" title="修饰词"></a>修饰词</h3><h4 id="访问控制修饰词"><a href="#访问控制修饰词" class="headerlink" title="访问控制修饰词"></a>访问控制修饰词</h4><table>
<thead>
<tr>
<th>权限修饰词</th>
<th>作用范围</th>
<th>类内部</th>
<th>同包</th>
<th>不同包<br>子类</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>public(共有)</td>
<td>其他包可以通过全名调用(导入后可以不写包名)</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>其他包作为子类可以调用,不过只能修饰变量和函数<br>主要用于可以被子类继承使用(只有子类)</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>default(默认不写)</td>
<td>同一个包才可以使用</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>private(私有)</td>
<td>同一个类才可以使用</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>class只有两种修饰方式：默认/public</li>
<li>通过访问修饰符封装类属性：<ol>
<li>变量设为pravate私有的</li>
<li>编写public公有的get/set方法进行判断赋值</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="static静态修饰词"><a href="#static静态修饰词" class="headerlink" title="static静态修饰词"></a>static静态修饰词</h4><table>
<thead>
<tr>
<th>static的使用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Static 变量</td>
<td>推荐直接<code>类名.静态变量</code>进行访问,等同于<code>实例化.静态变量</code><br>因为静态变量是共享的，是指向同一块内存的</td>
</tr>
<tr>
<td>Static 方法</td>
<td>推荐直接<code>类名.静态方法</code>进行调用,等同于<code>实例化.静态方法</code><br><strong>静态方法中无法使用实例成员：</strong><br>&emsp;静态方法只能访问静态变量，静态方法只能调用静态方法<br>&emsp;普通方法可以访问所有变量，普通方法可以调用所有方法</td>
</tr>
<tr>
<td>Static 类</td>
<td>很少使用，暂时忽略</td>
</tr>
<tr>
<td>Static 代码块</td>
<td>静态代码块 static{} 匿名代码块 {}<br>在类载入内存时执行它,且只运行一次,一般很少用<br>当类被实例化,执行顺序:静态块(1次)&gt;匿名块&gt;构造函数</td>
</tr>
</tbody></table>
<blockquote>
<p>static修饰的变量和方法不可以用this或super<br>静态方法中无法使用实例成员的<strong>根本原因</strong>是无法this<br>静态方法重写不成功（不报错，但是调用还是父类方法）<br>在类载入内存时：1实例化对象2使用类中静态成员<br>final+static定义的常量声明时赋值被使用，<font color="red"><strong>在编译时调用常量位置会被常量值替换</strong></font>，所以运行时不会加载常量所在类，提高运行效率</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final MY_COUNT = 1;</span><br><span class="line">System.out.println(MyClass.MY_COUNT);</span><br><span class="line">System.out.println(1);</span><br></pre></td></tr></table></figure>

<p>以上代码编译后，第二行代码会被编译成第三行代码编译的样子。(运行时MyClass类不会被加在)<br>注意final static定义的常量，无法在构造中赋值，只能声明直接赋值 或 在静态代码块中赋值，这样的常量被调用时依然先加载类后使用，并非上述</p>
<h4 id="final修饰词"><a href="#final修饰词" class="headerlink" title="final修饰词"></a>final修饰词</h4><table>
<thead>
<tr>
<th>final的使用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>final 类</td>
<td>该类不可以被继承,public final class (){}</td>
</tr>
<tr>
<td>final 方法</td>
<td>该方法不可以被重写,public final static void fuc(){}</td>
</tr>
<tr>
<td>final 变量</td>
<td>该变量不可以被重新赋值,final int a = 0;</td>
</tr>
<tr>
<td>final 对象</td>
<td>不能修改其引用(指针),final class obj1 = new class();obj1 = obj2不可以;但可以改变引用(指针)指向的对象的值</td>
</tr>
</tbody></table>
<blockquote>
<p>final 变量：声明时直接赋值 或 声明后在<strong>每个</strong>构造中赋值。final也可以修饰形参变量</p>
</blockquote>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>有返回值，写返回值类型，如int、String<br>无返回值，写void</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>同一个类中,函数名相同,返回值无所谓,参数个数或类型不同</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/11/11/dshc/JavaEE-Web%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E9%A1%BA%E5%BA%8F/">
                JavaEE-Web开发学习顺序
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-11-11</span>
            
            
            
                <span class="category">
                    <a href="/categories/语言编程/">语言编程</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="JavaEE-Web开发学习顺序"><a href="#JavaEE-Web开发学习顺序" class="headerlink" title="JavaEE-Web开发学习顺序"></a>JavaEE-Web开发学习顺序</h1><h2 id="Java学习"><a href="#Java学习" class="headerlink" title="Java学习"></a>Java学习</h2><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><ol>
<li><a href="">Java基础-语言基础(Basic)</a></li>
<li><a href="">Java基础-面向对象(OOP)</a></li>
<li><a href="">Java基础-JavaSE(上)</a></li>
<li><a href="">Java基础-JavaSE(下)</a></li>
</ol>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol>
<li><a href="">Java实践-飞机大战</a></li>
<li><a href="">Java练习-随机读写/顺序读写</a></li>
<li><a href="">Java实践-聊天室(C/S网络编程)</a></li>
<li><a href="">Java实践-WebServer(仿Tomcat)</a></li>
</ol>
<h2 id="Web学习"><a href="#Web学习" class="headerlink" title="Web学习"></a>Web学习</h2><h3 id="知识-1"><a href="#知识-1" class="headerlink" title="知识"></a>知识</h3><ol>
<li><a href="">Web基础-HTML语言</a></li>
<li><a href="">Web基础-CSS语言</a></li>
<li><a href="">Web基础-JavaScript语言</a></li>
<li><a href="">Web基础-jQuery语言</a></li>
<li><a href="">Web基础-Bootstrap</a></li>
</ol>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><ol>
<li><a href=""></a></li>
</ol>
<h2 id="数据库学习"><a href="#数据库学习" class="headerlink" title="数据库学习"></a>数据库学习</h2><h2 id="解决前后端通讯"><a href="#解决前后端通讯" class="headerlink" title="解决前后端通讯"></a>解决前后端通讯</h2><h2 id="框架学习"><a href="#框架学习" class="headerlink" title="框架学习"></a>框架学习</h2>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/11/11/dshc/Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
                Java内存管理
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-11-11</span>
            
            
            
                <span class="category">
                    <a href="/categories/语言编程/">语言编程</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="Java内存管理"><a href="#Java内存管理" class="headerlink" title="Java内存管理"></a>Java内存管理</h1><h2 id="Java的内存管理"><a href="#Java的内存管理" class="headerlink" title="Java的内存管理"></a>Java的内存管理</h2><ul>
<li>Java虚拟机JVM对于Java程序有特定的储存管理方案</li>
<li>JVM内存划分为栈、堆、方法区、程序计数器等</li>
<li>JVM提供一条垃圾回收线程,能够自动识别垃圾并将它回收</li>
<li>垃圾回收线程GC(garbage collection)程序员无法调用，最多只能通知<code>System.gc()</code></li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul>
<li>Java的基本数据类型共有8种</li>
<li>如<code>int a=3</code>栈中储存变量名a,并储存3这个字面值</li>
<li>字面值的数据由于大小可知、生存期可知，所以存在栈中重用</li>
<li>这些字面值定义在某个程序块里面，程序块退出后，字面值就消失了</li>
<li>重用就是更改值后原内存数据不变，指针(引用)指向已存在或新创建的内存空间</li>
</ul>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><h3 id="声明对象时的内存模型"><a href="#声明对象时的内存模型" class="headerlink" title="声明对象时的内存模型"></a>声明对象时的内存模型</h3><ul>
<li>代码执行<code>Teacher t;</code>后，声明一个Teacher对象t，栈中为储存类名t并分配Teacher类引用空间，因为对象还未创建，它还没有引用任何”实体”，所以引用为空</li>
<li>代码执行<code>t=new Teacher();</code>时，堆内存中为类的成员变量分配内存并将其初始化为各数据类型的默认值，接着进行显式初始化（类定义时的初始化值）；最后调用构造方法，为成员变量赋值。返回堆内存中对象的引用（相当于首地址）给引用变量t,以后就可以通过t来引用堆内存中的对象了</li>
</ul>
<h2 id="关于对象的特殊问题"><a href="#关于对象的特殊问题" class="headerlink" title="关于对象的特殊问题"></a>关于对象的特殊问题</h2><h3 id="String及个别包装类的堆重用问题"><a href="#String及个别包装类的堆重用问题" class="headerlink" title="String及个别包装类的堆重用问题"></a>String及个别包装类的堆重用问题</h3><ul>
<li>String在创建时如果使用类似<code>String s=&quot;hello&quot;;</code>方式声明会重用</li>
<li>个别包装类使用其静态方法<code>valueOf()</code>创建时会重用*</li>
<li>个别包装类：byte、char、short、int、long他们的包装类在-128~127时会重用</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>当定义一个数组是在栈内存中创建一个数组引用，通过该引用（即数组名）来引用数组</li>
<li>如<code>int[]x=new int[3]；</code>栈内存中储存数组名x及堆内存的首地址，堆内存中分配3个保存int型数据的空间，每个数组元素被初始化为0</li>
</ul>
<h3 id="static问题"><a href="#static问题" class="headerlink" title="static问题"></a>static问题</h3><ul>
<li>用static的修饰的变量和方法，实际上是指定了这些变量和方法在内存中的”固定位置”(static storage)</li>
<li>可以理解为所有实例对象共有的内存空间,全局的共用的，该类不只实例化时加载，也可使用static时被加载</li>
</ul>
<h3 id="final问题"><a href="#final问题" class="headerlink" title="final问题"></a>final问题</h3><ul>
<li>关键词final修饰的变量”不变”，指的是引用不变，所以：</li>
<li>在引用数据类型中：引用不变，但是引用指向的对象内容不保证</li>
<li>在基本数据类型中：引用不变，又因为重用现象，所以间接的值也不可以改变</li>
</ul>
<h2 id="Java垃圾回收机制-GC"><a href="#Java垃圾回收机制-GC" class="headerlink" title="Java垃圾回收机制(GC)"></a>Java垃圾回收机制(GC)</h2><ul>
<li>垃圾：在JVM堆中保存的已经不会再被使用的数据资源或对象</li>
</ul>
<h3 id="GC缺点"><a href="#GC缺点" class="headerlink" title="GC缺点"></a>GC缺点</h3><ol>
<li>本身占用资源.</li>
<li>周期性回收不及时.</li>
<li>只回收java垃圾,不能回收java在其他程序中产生的垃圾,如数据库</li>
</ol>
<h3 id="GC如何识别垃圾"><a href="#GC如何识别垃圾" class="headerlink" title="GC如何识别垃圾"></a>GC如何识别垃圾</h3><ol>
<li>引用计数法:<strong>程序计数器</strong>保存对象引用了多少次,如果为0识别为垃圾<blockquote>
<p>如果有对象想要尽快被回收,将这个对象引用指向null,将引用取消</p>
</blockquote>
</li>
<li>……</li>
</ol>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><ol>
<li>finalize方法定义在Object类中</li>
<li>在GC回收这个对象前,会先调用这个对象的finalize方法</li>
</ol>
<h3 id="System-gc-方法"><a href="#System-gc-方法" class="headerlink" title="System.gc()方法"></a>System.gc()方法</h3><ol>
<li>通知GC尽快回收垃圾</li>
<li>并不是立即回收,至少需要线程完成正在的任务时</li>
<li>所以并非一定在调用方法的地方执行回收(包括finalize()方法)</li>
</ol>
<h3 id="关于GC实现回收的过程"><a href="#关于GC实现回收的过程" class="headerlink" title="关于GC实现回收的过程"></a>关于GC实现回收的过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Aoo a = new Aoo();</span><br><span class="line">a = null;</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(&quot;OVER&quot;);</span><br><span class="line"></span><br><span class="line">Aoo重写finalize()方法输出&quot;回收&quot;</span><br></pre></td></tr></table></figure>

<p>程序执行后得到的结果有三种情况:</p>
<ol>
<li>先输出”OVER”,然后GC执行输出”回收”</li>
<li>GC先执行输出”回收”,然后再输出”OVER”</li>
<li>先输出”OVER”,GC还没来得及回收程序终止,没有输出”回收”</li>
</ol>
<h2 id="Java的内存泄露"><a href="#Java的内存泄露" class="headerlink" title="Java的内存泄露"></a>Java的内存泄露</h2><p>Java中内存泄漏就是存在一些不会被GC所回收而它却占用内存的对象，这些对象不再使用而大量堆积，因占用过多内存占用而导致程序的崩溃</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/11/10/dshc/HTTP%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/">
                HTTP协议简单理解
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-11-10</span>
            
            
            
                <span class="category">
                    <a href="/categories/计算机知识/">计算机知识</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="HTTP协议简单理解"><a href="#HTTP协议简单理解" class="headerlink" title="HTTP协议简单理解"></a>HTTP协议简单理解</h1><h2 id="HTTP协议简介"><a href="#HTTP协议简介" class="headerlink" title="HTTP协议简介"></a>HTTP协议简介</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul>
<li>HTTP协议:超文本传输协议，应用层协议，负责定义传输数据的格式</li>
<li>HTTP协议分为1.0与1.1两个版本。现在常用为1.1版本</li>
<li>Hypertext Transfer Protocol – HTTP/1.0 RFC1945</li>
<li>Hypertext Transfer Protocol – HTTP/1.1 RFC2616</li>
</ul>
<h3 id="HTTP协议的规则"><a href="#HTTP协议的规则" class="headerlink" title="HTTP协议的规则"></a>HTTP协议的规则</h3><ul>
<li>协议规定客户端与服务端通讯方式为:一次请求一次响应</li>
<li>HTTP对请求与响应分别定义了格式</li>
<li>HTTP定义了字符格式，(不含正文部分内容)都只能符合ISO8859-1编码字符(如:数字，字母，符号)</li>
<li>请求行以CRLF结束<ul>
<li>CR:回车符,asc编码中对应数字13</li>
<li>LF:换行符,asc编码中对应数字10</li>
</ul>
</li>
</ul>
<h2 id="HTTP请求格式"><a href="#HTTP请求格式" class="headerlink" title="HTTP请求格式"></a>HTTP请求格式</h2><ul>
<li>一个HTTP请求分为三部分组成:请求行，消息头，消息正文</li>
</ul>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><ul>
<li>请求行请求分为三部分：<code>method url protocol(CRLF)</code></li>
<li>请求方法 资源路径 协议(CRLF)</li>
<li>例如<code>GET /index.html HTTP/1.1(CRLF)</code></li>
</ul>
<h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><ul>
<li>消息头由若干行表示，每行表示一个具体的头信息</li>
<li>每个头信息格式：<code>name:value(CRLF)</code></li>
<li>消息头名字: 消息头的值(CRLF)</li>
<li>最后一个消息头结尾处会有两个CRLF，第一个表示最后一个消息头结束，第二个表示消息头部分结束</li>
</ul>
<h3 id="消息正文"><a href="#消息正文" class="headerlink" title="消息正文"></a>消息正文</h3><ul>
<li>消息正文不是必须部分，消息正文是二进制数据</li>
<li>是客户端在发送请求时发送给服务端客户提交的数据</li>
</ul>
<h2 id="HTTP响应格式"><a href="#HTTP响应格式" class="headerlink" title="HTTP响应格式"></a>HTTP响应格式</h2><ul>
<li>HTTP响应格式也分为三部分:状态行，响应头，响应正文</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK(CRLF)</span><br><span class="line">Content-Type: text/html(CRLF)//告知浏览器正文文件类型</span><br><span class="line">Content-Length: 224586(CRLF)//告知浏览器正文长度</span><br><span class="line">(CRLF)</span><br><span class="line">正文部分二进制</span><br></pre></td></tr></table></figure>

<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><ul>
<li>状态行格式<code>protorol status-code status-reason(CRLF)</code></li>
<li>协议版本 状态码 状态描述(CRLF)</li>
<li>例如<code>HTTP/1.1 200 OK(CRLF)</code></li>
</ul>
<table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>信息响应类，表示接受到请求并继续处理</td>
</tr>
<tr>
<td>2xx</td>
<td>处理成功响应类,表示动作被成功接收兵处理</td>
</tr>
<tr>
<td>200</td>
<td>一切正常</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向类，为了完成指定的动作，必须接受下一步处理</td>
</tr>
<tr>
<td>302</td>
<td>服务端要求客户端重定向到指定路径</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误类，表示客户端请求包含错误的语法或不能正确的执行</td>
</tr>
<tr>
<td>404</td>
<td>用于请求资源未找到</td>
</tr>
<tr>
<td>5xx</td>
<td>服务端错误类，服务端不能正确的处理一个正确的请求</td>
</tr>
<tr>
<td>500</td>
<td>服务端处理异常</td>
</tr>
</tbody></table>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><ul>
<li>响应头的格式与请求中的消息头格式一致</li>
<li>消息头由若干行表示，每行表示一个具体的头信息</li>
<li>每个头信息格式：<code>name:value(CRLF)</code></li>
<li>消息头名字: 消息头的值(CRLF)</li>
<li>最后一个消息头结尾处会有两个CRLF，第一个表示最后一个消息头结束，第二个表示消息头部分结束</li>
</ul>
<h3 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h3><ul>
<li>响应正文也是二进制数据，用于将客户端请求的资源等信息发送回给客户端。</li>
</ul>
<h2 id="关于头数据"><a href="#关于头数据" class="headerlink" title="关于头数据"></a>关于头数据</h2><h4 id="MIME-类型"><a href="#MIME-类型" class="headerlink" title="MIME 类型"></a>MIME 类型</h4><ul>
<li>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准</li>
<li>是数据头：Content-Type这个消息头的对应字符串；根据文件后缀，确定HTTP协议规定的标识数据类型</li>
</ul>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/3/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo" target="_blank" rel="noopener">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2019/12/02/Java%E5%9F%BA%E7%A1%80-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88Basic)/">Java基础-语言基础（Basic)</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/12/02/dshc/Web%E5%9F%BA%E7%A1%80-jQuery%E8%AF%AD%E8%A8%80/">Web基础-jQuery语言</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/11/29/dshc/Web%E5%9F%BA%E7%A1%80-JavaScript%E8%AF%AD%E8%A8%80/">Web基础-JavaScript语言</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/11/28/dshc/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/">线性代数笔记</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/Java/">Java</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/">生活记录</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/">结构算法</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/">工具环境</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com" target="_blank" rel="noopener">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/" target="_blank" rel="noopener">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>