<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-09T12:01:06.194Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>whitedofu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web基础-jQuery语言</title>
    <link href="http://yoursite.com/2019/12/09/Web%E5%9F%BA%E7%A1%80-jQuery%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2019/12/09/Web%E5%9F%BA%E7%A1%80-jQuery%E8%AF%AD%E8%A8%80/</id>
    <published>2019-12-09T12:02:24.000Z</published>
    <updated>2019-12-09T12:01:06.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web基础-jQuery语言"><a href="#Web基础-jQuery语言" class="headerlink" title="Web基础-jQuery语言"></a>Web基础-jQuery语言</h1><h2 id="jQuery简介"><a href="#jQuery简介" class="headerlink" title="jQuery简介"></a>jQuery简介</h2><h3 id="什么是jQuery"><a href="#什么是jQuery" class="headerlink" title="什么是jQuery"></a>什么是jQuery</h3><ul><li>jQuery是一个优秀的JavaScript框架，一个轻量级的JS库</li><li>它封装了JS、CSS、DOM，提供了一致的、简洁的API</li><li>兼容CSS3，以及兼容各种浏览器</li><li>注意：jQuery 2.x 开始不再支持IE6/7/8</li></ul><h3 id="如何使用jQuery"><a href="#如何使用jQuery" class="headerlink" title="如何使用jQuery"></a>如何使用jQuery</h3><ul><li>引入jQuery的js文件</li><li>可以通过本地文件导入，或者通过网络中jQuery的js文件地址</li><li>使用jq选择器定位要操作的节点，然后调用jq方法进行操作</li></ul><h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><h3 id="jQuery对象简介"><a href="#jQuery对象简介" class="headerlink" title="jQuery对象简介"></a>jQuery对象简介</h3><ul><li>jQuery为了解决浏览器的兼容问题而提供的一种统一的封装后的对象描述</li><li>jQuery提供的方法都是针对jQuery对象特有的，而且大部分方法的返回值也是jQuery对象，所以方法可以连缀调用</li><li>jQuery对象本质上是DOM对象数组，它在该数组上扩展了一些操作数组中元素的方法</li><li>jq.length：获取数组长度、jq.get(index)：获取数组中的某一个DOM对象、jq[index]：等价于obj.get(index)</li><li>jq对象与dom对象之间转换，就是选择jq对象的某个 dom = jq[0]，相反的 jq = $(dom)</li></ul><h3 id="jQuery遍历数组的方法"><a href="#jQuery遍历数组的方法" class="headerlink" title="jQuery遍历数组的方法"></a>jQuery遍历数组的方法</h3><ul><li>$(selector).each(func) ：遍历selector选中的每个对象，每个对象执行func方法，方法体内用this表示当前对象</li><li>示例：<code>$(&quot;div&quot;).each(function(){this.val=&quot;已遍历&quot;})</code></li></ul><h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><h3 id="jQuery选择器-1"><a href="#jQuery选择器-1" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h3><ul><li>jQuery选择器类似CSS选择器，包含以下种类：基本选择器、层次选择器、过滤选择器、表单选择器</li><li>jQuery选择器大部分采用了CSS方式，方便的选择对象，基本选择器、层次选择器基本都为CSS格式</li><li>以下详细描述了另外两种选择器的介绍和使用</li><li>节点操作节点，参考下面jQuery的遍历节点操作</li></ul><h3 id="jQuery过滤选择器"><a href="#jQuery过滤选择器" class="headerlink" title="jQuery过滤选择器"></a>jQuery过滤选择器</h3><h4 id="基本过滤选择器"><a href="#基本过滤选择器" class="headerlink" title="基本过滤选择器"></a>基本过滤选择器</h4><ul><li>:first：第一个元素</li><li>:last：最后一个元素</li><li>:not(jq)：把jq对象排除在外</li><li>:even：挑选偶数行</li><li>:odd：挑选奇数行</li><li>:eq(index)：下标等于index的元素(从0开始计算)</li><li>:gt(index)：下标大于index的元素</li><li>:lt(index)：下标小于index的元素</li></ul><h4 id="子元素过滤选择器"><a href="#子元素过滤选择器" class="headerlink" title="子元素过滤选择器"></a>子元素过滤选择器</h4><ul><li>:first-child ：匹配第一个子元素</li><li>:last-child ：匹配最后一个子元素</li><li>:nth-child(n) ：匹配第n个子元素(不是从0开始计算)</li></ul><h4 id="内容过滤选择器"><a href="#内容过滤选择器" class="headerlink" title="内容过滤选择器"></a>内容过滤选择器</h4><ul><li>:contains(‘text’)：匹配包含给定文本的元素</li><li>:empty：匹配所有不包含子元素或文本的空元素</li><li>:has(jq)：匹配包含jq对象的元素</li><li>:parent：匹配非空的元素</li></ul><h4 id="可见性过滤选择器"><a href="#可见性过滤选择器" class="headerlink" title="可见性过滤选择器"></a>可见性过滤选择器</h4><ul><li>:hidden ：匹配所有不可见元素，或type为hidden的元素</li><li>:visible：匹配所有可见元素</li></ul><h4 id="属性过滤选择器"><a href="#属性过滤选择器" class="headerlink" title="属性过滤选择器"></a>属性过滤选择器</h4><ul><li>类似CSS中属性选择器</li><li>例如：<code>$(&quot;input[value=&#39;你好&#39;]&quot;)</code></li></ul><h4 id="状态过滤选择器"><a href="#状态过滤选择器" class="headerlink" title="状态过滤选择器"></a>状态过滤选择器</h4><ul><li>:enabled 匹配可用的元素</li><li>:disabled 匹配不可用的元素</li><li>:checked 匹配选中的checkbox、option(单选、多选、下拉选)</li><li>:selected 匹配选中的option</li></ul><h3 id="表单选择器"><a href="#表单选择器" class="headerlink" title="表单选择器"></a>表单选择器</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>:input</td><td>匹配所有表单控件</td></tr><tr><td>:text</td><td>匹配文本框</td></tr><tr><td>:password</td><td>匹配密码框</td></tr><tr><td>:radio</td><td>匹配单选框</td></tr><tr><td>:checkbox</td><td>匹配多选框</td></tr><tr><td>:submit</td><td>匹配提交按钮</td></tr><tr><td>:reset</td><td>匹配重置按钮</td></tr><tr><td>:button</td><td>匹配普通按钮</td></tr><tr><td>:file</td><td>匹配文件框</td></tr><tr><td>:hidden</td><td>匹配隐藏框</td></tr></tbody></table><h2 id="jQuery操作DOM"><a href="#jQuery操作DOM" class="headerlink" title="jQuery操作DOM"></a>jQuery操作DOM</h2><h3 id="读写节点"><a href="#读写节点" class="headerlink" title="读写节点"></a>读写节点</h3><ul><li>读写节点的HTML内容：<code>obj.html() / obj.html(&quot;&lt;span&gt;123&lt;/span&gt;&quot;)</code></li><li>读写节点的文本内容：<code>obj.text() / obj.text(&quot;123&quot;)</code></li><li>读写节点的value属性值：<code>obj.val() / obj.val(&quot;abc&quot;)</code></li><li>读写节点的属性值：<code>obj.attr(&quot;属性名&quot;) / obj.attr(&quot;属性名&quot;,&quot;属性值&quot;)</code></li></ul><blockquote><p>Jquery1.6之后，它将“属性”与“特性”做了区别，属性指的是“name，id”等等，特性指的是“selectedIndex, tagName, nodeName”等等。可以通过attr方法去获得属性，通过prop方法去获得特性。<br>$(“#cb”).attr(“tagName”); //undefined<br>$(“#cb”).prop(“tagName”); //INPUT<br>那么，什么时候使用attr()，什么时候使用prop()？  </p><ol><li>添加属性名称该属性就会生效应该使用prop();  </li><li>是有true,false两个属性使用prop();  </li><li>其他则使用attr();  </li></ol></blockquote><h3 id="增删节点"><a href="#增删节点" class="headerlink" title="增删节点"></a>增删节点</h3><ul><li>创建DOM节点：语法<code>$(&quot;节点内容&quot;)</code>，例如：<code>$(&quot;&lt;span&gt;你好&lt;/span&gt;&quot;)</code></li><li>插入DOM节点：<ol><li>element.append(obj) 作为最后一个节点添加进来</li><li>element.prepend(obj) 作为第一个节点添加进来</li><li>element.after(obj) 作为元素的下一个节点添加进来</li><li>element.before(obj) 作为元素的上一个节点添加进来</li></ol></li><li>删除DOM节点：<ol><li>obj.remove() 删除节点</li><li>obj.remove(selector) 只删除满足selector的节点</li><li>obj.empty() 清空节点</li></ol></li></ul><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><ul><li>addClass(“”) 追加样式</li><li>removeClass(“”) 移除指定样式</li><li>removeClass() 移除所有样式</li><li>toggleClass(“”) 切换样式</li><li>hasClass(“”) 判断是否有某个样式</li><li>css(“”) 读取css的值</li><li>css(“”,””) 设置多个样式</li><li>css(“{….}”) 设置样式</li></ul><h3 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>siblings([selector])</td><td>返回所有兄弟元素</td></tr><tr><td>prev([selector])</td><td>返回同级上一个元素</td></tr><tr><td>prevAll([selector])</td><td>返回同级上所有元素</td></tr><tr><td>next([selector])</td><td>返回同级下一个元素</td></tr><tr><td>nextAll([selector])</td><td>返回同级下所有元素</td></tr><tr><td>chirldren([selector])</td><td>返回所有子元素</td></tr><tr><td>parent()</td><td>返回父元素</td></tr><tr><td>find(selector)</td><td>查找满足选择器的所有后代</td></tr></tbody></table><h2 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h2><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul><li>语法：$obj.bind(事件类型，事件处理函数)，如 <code>$obj.bind(&quot;click&quot;,func)</code></li><li>简写形式：如 <code>$obj.click(func)</code></li><li>获取事件对象event，只需要在事件函数中传入一个参数，例如：<code>$obj.click(function(e){...})</code></li><li>事件对象的常用属性：<ul><li>获取事件源 e.target <strong>返回DOM对象</strong></li><li>获取鼠标点击坐标 e.pageX 、 e.pageY</li></ul></li></ul><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><ul><li>子节点产生的事件会依次向上抛给父节点</li><li>为了避免事件冒泡，我们可以设置取消事件冒泡</li><li>代码：<code>e.stopPropagation()</code> ，用于取消事件冒泡</li></ul><h3 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h3><ul><li>hover(mouseenter,mouseleave) 用于模拟光标悬停事件</li><li>toggle() 在多个事件响应中切换</li></ul><h3 id="模拟操作"><a href="#模拟操作" class="headerlink" title="模拟操作"></a>模拟操作</h3><ul><li>语法：$obj.trigger(事件类型) 例如：<code>$obj.trigger(&quot;focus&quot;)</code></li><li>简写形式：如 <code>$obj.focus()</code></li></ul><h2 id="jQuery动画"><a href="#jQuery动画" class="headerlink" title="jQuery动画"></a>jQuery动画</h2><h3 id="显示隐藏动画"><a href="#显示隐藏动画" class="headerlink" title="显示隐藏动画"></a>显示隐藏动画</h3><ul><li>语法： show() / hide() , 通过改变元素的宽度和高度来实现显示或者隐藏</li><li>用法： <code>$obj.show(执行时间,回调函数);</code><ul><li>执行时间：slow,normla,fast,毫秒数</li><li>回调函数：动画执行完毕后执行的函数</li></ul></li><li>toggle();</li></ul><h3 id="上下滑动式"><a href="#上下滑动式" class="headerlink" title="上下滑动式"></a>上下滑动式</h3><ul><li>语法： slideDown() / slideUp() , 通过改变元素的高度来实现显示或者隐藏</li><li>用法同上</li><li>slideToggle();</li></ul><h3 id="淡入淡出效果"><a href="#淡入淡出效果" class="headerlink" title="淡入淡出效果"></a>淡入淡出效果</h3><ul><li>语法： fadeIn() / fadeOut() , 通过改变元素的不透明度opacity来实现显示或者隐藏</li><li>用法同上</li><li>fadeToggle();</li></ul><h3 id="自定义动画效果"><a href="#自定义动画效果" class="headerlink" title="自定义动画效果"></a>自定义动画效果</h3><ul><li>语法：<code>animate(偏移位置,执行时间,回调函数)</code><ul><li>偏移位置：{}描述动画执行之后元素的样式</li><li>执行时间：毫秒数</li><li>回调函数：动画执行结束后要执行的函数</li></ul></li><li>使用示例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div&quot;).click(function()&#123;</span><br><span class="line">    $(this).animate(&#123;&apos;left&apos;,&apos;500px&apos;&#125;,4000);</span><br><span class="line">    $(this).animate(&#123;&apos;top&apos;,&apos;300px&apos;&#125;,2000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Web基础-jQuery语言&quot;&gt;&lt;a href=&quot;#Web基础-jQuery语言&quot; class=&quot;headerlink&quot; title=&quot;Web基础-jQuery语言&quot;&gt;&lt;/a&gt;Web基础-jQuery语言&lt;/h1&gt;&lt;h2 id=&quot;jQuery简介&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="语言编程" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="JQ" scheme="http://yoursite.com/tags/JQ/"/>
    
  </entry>
  
  <entry>
    <title>Web基础-JavaScript语言</title>
    <link href="http://yoursite.com/2019/12/09/Web%E5%9F%BA%E7%A1%80-JavaScript%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2019/12/09/Web%E5%9F%BA%E7%A1%80-JavaScript%E8%AF%AD%E8%A8%80/</id>
    <published>2019-12-09T12:01:20.000Z</published>
    <updated>2019-12-09T12:00:14.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web基础-JavaScript语言"><a href="#Web基础-JavaScript语言" class="headerlink" title="Web基础-JavaScript语言"></a>Web基础-JavaScript语言</h1><h2 id="JavaScript概述"><a href="#JavaScript概述" class="headerlink" title="JavaScript概述"></a>JavaScript概述</h2><h3 id="什么是JavaScript"><a href="#什么是JavaScript" class="headerlink" title="什么是JavaScript"></a>什么是JavaScript</h3><ul><li>JavaScript是嵌入HTML中的脚本语言</li><li>用于向HTML页面添加交互行为</li><li>不进行预编译，由浏览器解析执行</li></ul><h3 id="JavaScript语言特点"><a href="#JavaScript语言特点" class="headerlink" title="JavaScript语言特点"></a>JavaScript语言特点</h3><ul><li>属于弱类型语言</li><li>基于面向对象：内置大量线程对象</li><li>安全性高：js语言智能访问浏览器内部数据，不能访问浏览器以外的数据</li><li>交互性高：js语言可以直接嵌入到html页面中，可以直接和页面中的用户进行交互</li></ul><h3 id="导入JavaScript方法"><a href="#导入JavaScript方法" class="headerlink" title="导入JavaScript方法"></a>导入JavaScript方法</h3><ul><li>总共有三种方式：事件定义式、嵌入式、文件调用式</li><li>事件定义式：在标签的事件属性中添加js代码，当事件触发时执行</li><li>嵌入式：定义在HTML的任意位置，标签内写js代码，通常建议写在body标签末尾<ul><li>使用<code>script</code>标签，属性<code>type=&quot;text/script&quot;</code>，在标签体内书写</li><li>例如：<code>&lt;script type=&quot;text/javascript&quot;&gt;js代码&lt;/script&gt;</code></li></ul></li><li>文件调用式：定义在一个外部的js文件中，HTML页面引用<ul><li>使用<code>script</code>标签，属性<code>type=&quot;text/script&quot;</code>，属性<code>src=&quot;js文件&quot;</code></li><li>例如：<code>&lt;script type=&quot;text/javascript&quot; src=&quot;js文件&quot;&gt;&lt;/script&gt;</code></li></ul></li></ul><h2 id="JavaScript基础语法"><a href="#JavaScript基础语法" class="headerlink" title="JavaScript基础语法"></a>JavaScript基础语法</h2><h3 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h3><ul><li>Unicode字符集编写，大小写敏感，使用分号或换行结束，一般都以分号结束，代码中的空格会被忽略</li><li>注释使用//或/* */</li><li>不以数字开头的字母、数字、下划线、美元符号组成</li><li>特定字符保留字不允许程序再定义</li><li>使用var关键字声明为全局变量，使用let关键字声明为局部变量</li><li>谷歌浏览器会把定义id的元素，自动获取本身对象到id名称变量中</li></ul><h3 id="JavaScript语法"><a href="#JavaScript语法" class="headerlink" title="JavaScript语法"></a>JavaScript语法</h3><table><thead><tr><th>命名</th><th>语法</th><th>备注</th></tr></thead><tbody><tr><td>变量(对象)声明</td><td>var/let &lt;变量名&gt;</td><td>var age;var name=’明’;<br>var person={name:”xiao”,age:”20”,id:”123456”};</td></tr><tr><td>常量声明</td><td>const &lt;变量名&gt;</td><td>只对基本数据类型生效(Number、String、Boolean等)</td></tr><tr><td>if分支</td><td>if(布尔表达式){<br>}else if(布尔表达式){<br>}else{}</td><td>不使用大括号默认认为下一个；前的语句属于if-true分支内,效率比switch低,switch直接进入不是挨个判断</td></tr><tr><td>switch分支</td><td>switch(表达式){<br>default:<br>&emsp;默认语句;<br>&emsp;break;<br>case 常量:<br>&emsp;语句;<br>&emsp;break;}</td><td>case说明程序开始，break说明结束(退出分支),没有则case穿透,default可以不在最后面但是不要忘记break</td></tr><tr><td>for循环</td><td>for(var/let i = 0;i &lt; 9;i++){}</td><td>for(;;){}默认死循环,()内多条语句用<code>,</code>但是注意第一块如果有声明只能一个类型的多声明</td></tr><tr><td>while循环</td><td>while(布尔表达式){}<br>do{}while(布尔表达式)</td><td>continue跳过本次循环继续下次循环</td></tr></tbody></table><ul><li>false一切表示空的值都是：false/0/null/“”/undefined/NaN</li><li>true：true/“非空”值</li><li>Number字符可以用3e2赋值，为300</li></ul><h3 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h3><ul><li>特殊类型：null(空)、undefined(未定义)</li><li>内置对象：Number(数字:整数和小数)、Sting(字符串)、Boolean(布尔)、Function(函数)、Array(数组)</li><li>外部对象：window(浏览器对象)、document(文档对象)</li><li>自定义对象：Object(自定义对象)</li><li>Number统一使用4字节浮点格式存储，Boolean运算时true=1,false=0</li><li>null表示无值或者无对象，undefined表示声明了变量但为赋值，或者对象属性不存在</li><li>使用<code>typeof()</code>方法传入对象，返回对象类型，以字符串类型显示</li></ul><h3 id="数据类型的隐式转换"><a href="#数据类型的隐式转换" class="headerlink" title="数据类型的隐式转换"></a>数据类型的隐式转换</h3><ul><li>数字+字符串：数字转为字符串</li><li>数字+布尔值：布尔转换1或0</li><li>字符串+布尔值：布尔转为为字符串true或false</li><li>布尔值+布尔值：布尔值转换1或0</li></ul><h3 id="特殊运算符规则"><a href="#特殊运算符规则" class="headerlink" title="特殊运算符规则"></a>特殊运算符规则</h3><ul><li><code>==</code>与<code>===</code>的区别：前者会先统一类型再比较值，后者先比较类型再比较值</li><li>进而存在<code>!=</code>与<code>!==</code>，不等、不全等</li><li>JS在除法运算中，计算后的结果会根据实际值存储为整数或小数</li></ul><h3 id="JavaScript方法声明"><a href="#JavaScript方法声明" class="headerlink" title="JavaScript方法声明"></a>JavaScript方法声明</h3><ul><li>function 方法名(参数列表){方法体}</li><li>var 方法名 = function(参数列表){方法体}</li><li>var 方法名 = new Function(“参数1”,”参数2”…,”方法体”)</li></ul><h2 id="JavaScript内置对象"><a href="#JavaScript内置对象" class="headerlink" title="JavaScript内置对象"></a>JavaScript内置对象</h2><h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><ul><li>常见String对象创建方式：<code>var str=&quot;myString&quot;</code> 和 <code>var str=new String(&quot;myString&quot;)</code></li><li>属性：length，存储字符串长度</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>toLowerCase()</td><td>转换为小写</td></tr><tr><td>toUpperCase()</td><td>转换为大写</td></tr><tr><td>charAt(index)</td><td>返回指定位置的字符</td></tr><tr><td>formCharCode(num)</td><td>返回num对应的值(ASCII)，不区分大小写</td></tr><tr><td>charCodeAt(index)</td><td>返回指定位置字符的Unicode编码</td></tr><tr><td>indexOf(findsrt[,index])</td><td>从制定位置，从头开始寻找findstr出现的第一个位置</td></tr><tr><td>lastIndexOf(findsrt[,index])</td><td>从制定位置，从尾开始寻找findstr出现的第一个位置</td></tr><tr><td>substring(start[,end])</td><td>截取字符串，从start到end(不写默认到最后)</td></tr><tr><td>replace(findstr,tostr)</td><td>替换字符串内的字符</td></tr><tr><td>split(bystr[,length])</td><td>根据bystr分隔字符串，可以指定返回数组的最大长度length</td></tr><tr><td>正则表达式相关</td><td></td></tr><tr><td>replace(regexp,tostr)</td><td>将与正则相匹配的替换为tostr</td></tr><tr><td>match(regexp)</td><td>返回匹配字符串的数组</td></tr><tr><td>search(regexp)</td><td>返回匹配字符串的首字符位置索引</td></tr></tbody></table><h3 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h3><ul><li>Number是数值对象，储存整数和小数，都是通过32位浮点方式储存</li><li>方法：toFixed(num)，转换为字符串，并保留小数点后一定位数</li></ul><h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><ul><li>常见Array对象创建方式：<code>var a=new Array(1,2,3)</code>和<code>var a=[[a00,a01],[a10,a11]]</code></li><li>属性：length，存储数组内元素个数</li><li>特殊的：数组内可以储存不同类型元素，js的数组是<strong>可变长度</strong>的</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>ar.reverse()</td><td>改变数组中数值的顺序</td></tr><tr><td>ar.sort([sortfunc])</td><td>数组排序,可选使用某方法进行排序,方法返回正负零</td></tr><tr><td>ar.push(“11”,”22”)</td><td>在末尾增加元素</td></tr><tr><td>delete ar[1]</td><td>删除指定位元素</td></tr><tr><td>ar.pop()</td><td>在末尾删除元素，返回删除值</td></tr><tr><td>ar.shift()</td><td>在开始删除元素，返回删除值</td></tr><tr><td>ar.unshift(“11”)</td><td>在开始增加元素，返回元素个数</td></tr><tr><td>ar.toString()</td><td>数组转为字符串</td></tr><tr><td>ar.join(“—”)</td><td>数组转为字符串，用—连接</td></tr><tr><td>ar1.concat(ar2)</td><td>合并数组，ar2也可以直接写元素</td></tr><tr><td>ar.splice(start,length)</td><td>删除、替换、插入元素,会改变原数组</td></tr><tr><td>ar.slice(start,end)</td><td>切取数组一段,不会改变原数组,返回切取得元素</td></tr><tr><td>for—in—</td><td>遍历数组或对象for(x in obj){alert(obj[x]);}<br>这里的x表示obj.key obj[x]就是obj.key.value</td></tr></tbody></table><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><ul><li>该对象常用它的方法与属性、常量</li><li>无需创建对象，直接把Math作为对象使用</li><li>常用属性：Math.PI 、 Math.E</li><li>三角函数：sin(x)、cos(x)、tan(x) 等</li><li>计算函数：sqrt(x)、log(x)、exp(x) 等</li><li>数值比较函数：abs(x)、max(x,y,…)、random() 、round(x) 等等</li></ul><h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><ul><li>常见Date对象创建方式：<code>var now=new Date()</code>和<code>var date=new Date(&quot;2018/8/8 08:00&quot;)</code></li><li>读写毫秒数：getTime() 、 setTime(ms)</li><li>读写毫秒数：getDate() 、 getDay() 、 getFullYear() ，set…</li><li>转换为字符串：toString() 、 toLocaleTimeString() 、 toLocaleDateString()</li></ul><h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><ul><li>常见Date对象创建方式：<code>var reExp=/pattern/flags</code>和<code>var reExp=new RegExp(&quot;pattern&quot;[,&quot;flags&quot;])</code></li><li>flags表示有以下几个：<ul><li>g：设定当前匹配为全局模式</li><li>i：忽略匹配中的大小写检测</li></ul></li><li>创建对象示例：<code>var reg=/^\d{3,6}$/</code>或者<code>var reg=new RgeExp(&quot;^\d{3,6}$&quot;)</code></li><li>方法：RegExpObject.test(string)，检测string是否含有与RegExpObject匹配的文本，返回布尔</li><li>方法：RegExpObject.exec(string)，如果string中有与RegExpObject匹配的文本，将该文本返回</li></ul><h3 id="Function对象"><a href="#Function对象" class="headerlink" title="Function对象"></a>Function对象</h3><ul><li>方法对象，具体创建与使用可以参考上方，方法的创建方式</li><li>内置arguments对象，是一种特殊的对象，表示函数的参数数组，用于访问参数</li><li>arguments.length：函数的参数个数</li><li>arguments[i]：第i个参数</li><li>可以利用arguments实现可变参数的函数</li><li>可以通过<code>func.apply([thisObj [,argArray]])</code>方法或<code>call([thisObject[,arg1 [,arg2 [,...,argn]]]])</code>方法调用函数</li><li>以上参数1是函数运行的作用域，另一个是参数数组/参数罗列</li></ul><h3 id="Object自定对象"><a href="#Object自定对象" class="headerlink" title="Object自定对象"></a>Object自定对象</h3><ul><li>语法：<code>var obj = new object()</code> 或 <code>var obj = {}</code> 或 <code>var obj = {key:”value”,key2:”value”}</code></li><li>使用属性：<code>obj.key</code> 和 <code>obj[&quot;key&quot;]</code></li><li>删除属性：<code>delete obj.key</code></li><li>增设方法：<code>obj.key = fun();</code> 、 <code>obj.key();</code></li></ul><h2 id="JavaScript外部对象概述"><a href="#JavaScript外部对象概述" class="headerlink" title="JavaScript外部对象概述"></a>JavaScript外部对象概述</h2><h3 id="外部对象结构"><a href="#外部对象结构" class="headerlink" title="外部对象结构"></a>外部对象结构</h3><p><img src="/Web%E5%9F%BA%E7%A1%80-JavaScript%E8%AF%AD%E8%A8%80/bomdom" alt=""></p><h3 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h3><ul><li>BOM(Browser Object Model)：浏览器对象模型，用来访问和操作浏览器窗口，使JavaScript有能力与浏览器”对话”</li><li>通过使用BOM，可移动窗口、更改状态栏文本、执行其他不与页面内容发生直接联系的操作</li><li>没有相关标准，但被广泛支持</li><li>BOM对象包含整个浏览器中的所有对象，其中根对象为window</li><li>window对象，window的属性称为全局属性，方法称为全局方法，访问时可以省略掉window</li><li>window对象包含：document、frames[]、history、location、navigator、screen</li><li>其中document对象整体视为DOM对象</li></ul><h3 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h3><ul><li>DOM(Document Object Model)：文档对象模型，用来操作文档</li><li>定义了访问和操作HTML文档的标准方法</li><li>应用程序通过对DOM树的操作，来实现对HTML文档数据的操作</li></ul><h2 id="浏览器对象BOM"><a href="#浏览器对象BOM" class="headerlink" title="浏览器对象BOM"></a>浏览器对象BOM</h2><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><table><thead><tr><th>对象内容</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>方法</td><td>alert(内容)</td><td>弹窗</td></tr><tr><td></td><td>parseInt()/parseFloat()</td><td>都懂</td></tr><tr><td></td><td>isNaN()</td><td>判断是否是NaN(Not a Number)，返回T/F</td></tr><tr><td></td><td>eval(code)</td><td>将code字符串视为js代码，并执行</td></tr><tr><td></td><td>confirm(内容)</td><td>弹窗是否返回T/F</td></tr><tr><td></td><td>prompt(内容，默认值)</td><td>弹窗返回输入值，取消返回null</td></tr><tr><td></td><td>Open(URL,Name,features)</td><td>目标地址，新窗口名称或窗口目标，新窗口标准<br>窗口目标：_blanck新建窗口,_parent当前窗口<br>窗口标准：width,height,top,left</td></tr><tr><td></td><td>Close()</td><td>关闭当前窗口</td></tr><tr><td></td><td>setInterval(fun,ms)</td><td>定时器(循环执行)，返回定时器ID</td></tr><tr><td></td><td>setTimeout(fun,ms)</td><td>定时器(只执行一次)，返回定时器ID</td></tr><tr><td></td><td>clearInterval(id)</td><td>定时器-清除</td></tr><tr><td></td><td>clearTimeout(id)</td><td>定时器-清除</td></tr><tr><td>属性</td><td>innerWidth</td><td>文档显示区宽度</td></tr><tr><td></td><td>innerHeight</td><td>文档显示区高度</td></tr><tr><td></td><td>prompt(内容，默认值)</td><td>弹窗返回输入值，取消返回null</td></tr></tbody></table><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><ul><li>浏览过窗口的历史记录对象</li></ul><table><thead><tr><th>对象内容</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>方法</td><td>back()</td><td>回到上一个页面</td></tr><tr><td></td><td>forward()</td><td>进入下一个页面</td></tr><tr><td></td><td>go(Num)</td><td>进入相对当前页面的第N个(Num=-1上一个)l</td></tr><tr><td>属性</td><td>length</td><td>当前窗口所打开的页面数</td></tr></tbody></table><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><ul><li>窗口文件地址对象</li></ul><table><thead><tr><th>对象内容</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>方法</td><td>assign(URL)</td><td>加载新的文档—一般用于跳转</td></tr><tr><td></td><td>reload()</td><td>重新加载当前文档</td></tr><tr><td></td><td>replace(URL)</td><td>加载新的文档，与第一个类似，区别是不会产生history</td></tr><tr><td>属性</td><td>href</td><td>设置或返回完整的URL</td></tr><tr><td></td><td>host</td><td>主机名和当前端口号</td></tr></tbody></table><h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><ul><li>当前屏幕对象</li></ul><table><thead><tr><th>对象内容</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>属性</td><td>availHeight</td><td>返回屏幕高度，除Windows任务栏外</td></tr><tr><td></td><td>availWidth</td><td>返回屏幕宽度，除Windows任务栏外</td></tr><tr><td></td><td>Height</td><td>返回屏幕高度</td></tr><tr><td></td><td>Width</td><td>返回屏幕宽度</td></tr></tbody></table><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><ul><li>浏览器相关信息</li></ul><table><thead><tr><th>对象内容</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>属性</td><td>appCodeName</td><td>返回浏览器名称</td></tr><tr><td></td><td>uerAgent</td><td>获取浏览器版本信息</td></tr></tbody></table><h2 id="HTML对象DOM"><a href="#HTML对象DOM" class="headerlink" title="HTML对象DOM"></a>HTML对象DOM</h2><h3 id="DOM选择元素方法"><a href="#DOM选择元素方法" class="headerlink" title="DOM选择元素方法"></a>DOM选择元素方法</h3><ul><li>属性readyState(加载状态)：uninitialized还未开始载入 loading载入中 interactive已加载 complete载入完成</li><li>通过document打点使用方法查询</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getElementById()</td><td>获取元素对象，ID</td></tr><tr><td>getElementsByName()</td><td>获取元素对象组，Name</td></tr><tr><td>getElementsByClassName()</td><td>获取元素对象组，Class</td></tr><tr><td>getElementsByTagName()</td><td>获取元素对象组，TagName标签名称div,input,h1,a</td></tr><tr><td>querySelector(“selectors”)</td><td>查找元素、第一个selectors为css选择器</td></tr><tr><td>querySelectorAll(“selectors”)</td><td>查找元素集合selectors为css选择器</td></tr></tbody></table><h3 id="更改使用元素"><a href="#更改使用元素" class="headerlink" title="更改使用元素"></a>更改使用元素</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>document.write()</td><td>向文档写HTML或JavaScript，注意加载完后使用会覆盖原文档</td></tr><tr><td>element.innerHTML</td><td>设置或返回元素的内容</td></tr><tr><td>element.tagName</td><td>返回元素标签名</td></tr><tr><td>element.id/className/title/value</td><td>设置或返回元素的各种属性</td></tr><tr><td>element.style.color/…</td><td>设置或返回元素style的各种属性，原下划线去掉将第二个单词首字母大写</td></tr><tr><td>===元素属性操作===</td><td></td></tr><tr><td>element.getAttribute(“key”)</td><td>返回元素的key属性的值</td></tr><tr><td>element.setAttribute(“key”,”value”)</td><td>设置元素的key属性为value</td></tr><tr><td>element.removeAttribute(“key”)</td><td>删除元素的key属性的值</td></tr></tbody></table><h3 id="元素操作其他元素"><a href="#元素操作其他元素" class="headerlink" title="元素操作其他元素"></a>元素操作其他元素</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>createElement()</td><td>创建元素节点</td></tr><tr><td>element.appendChild()</td><td>向元素添加新的子节点作为最后一个子节点</td></tr><tr><td>element.removeChild()</td><td>从元素中移出子节点</td></tr><tr><td>element.nodeName</td><td>返回节点名称</td></tr><tr><td>===元素选择元素===</td><td></td></tr><tr><td>element.nodeType</td><td>返回节点类型—元素节点1、属性节点2、文本节点3</td></tr><tr><td>element.nodeValue</td><td>返回元素值—元素节点没有value</td></tr><tr><td>element.parentNode</td><td>返回元素的父节点</td></tr><tr><td>element.childNodes</td><td>返回元素子节点的NodeList（包含空格文本节点）</td></tr><tr><td>element.children</td><td>返回元素的子元素节点（只有元素节点）</td></tr><tr><td>element.firstChild</td><td>返回元素的第一个子节点（包含空格文本节点）</td></tr><tr><td>element.firstElementChild</td><td>返回元素的第一个子元素节点（只有元素节点）</td></tr><tr><td>element.lastChild</td><td>返回元素的最后一个子节点（包含空格文本节点）</td></tr><tr><td>element.lastElementChild</td><td>返回元素的最后一个子元素节点（只有元素节点）</td></tr><tr><td>element.previousSibling</td><td>返回元素上一个节点</td></tr><tr><td>element.previousElementSibling</td><td>返回元素上一个元素节点</td></tr><tr><td>element.nextSibling</td><td>返回元素下一个节点</td></tr><tr><td>element.nextElementSibling</td><td>返回元素下一个元素节点</td></tr><tr><td>element.attributes</td><td>返回元素的属性节点名集合NamedNodeMap</td></tr><tr><td>element.insertBefore(new,old)</td><td>在指定的子节点前插入新节点(新节点，某节点前)</td></tr><tr><td>element.replaceChild(new,old)</td><td>替换元素中的子节点(新节点，旧节点)</td></tr></tbody></table><h2 id="JavaScrip事件"><a href="#JavaScrip事件" class="headerlink" title="JavaScrip事件"></a>JavaScrip事件</h2><h3 id="键鼠事件"><a href="#键鼠事件" class="headerlink" title="键鼠事件"></a>键鼠事件</h3><ul><li>鼠标事件：click、dblclick、contextmenu点击右键、mousedown、mousemove、mouseout、mouseover、mouseup</li><li>键盘事件：keydowm、keypress、keyup，keypress不适用系统按键</li></ul><h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><ul><li>load、unload、abort图像加载被中断、blur失去焦点、change、error、fouces、select文本被选择、scroll</li><li>通过选择器选择后，onclick=func，或其他各种事件进行绑定</li></ul><h3 id="事件对象event"><a href="#事件对象event" class="headerlink" title="事件对象event"></a>事件对象event</h3><ul><li>事件发生后会将事件的现场传入到event对象中，可以通过event的属性与子对象获取事件的现场信息</li><li>子对象target/srcElement：获取事件目标，两种写法是因为浏览器是否兼容，都可，相同</li><li>子对象事件目标对象：常用属性，nodeName存储事件目标的标签名称</li></ul><table><thead><tr><th>event属性</th><th>说明</th></tr></thead><tbody><tr><td>clientX</td><td>鼠标指针的水平坐标</td></tr><tr><td>screenX</td><td>鼠标指针的水平坐标</td></tr><tr><td>clientY</td><td>鼠标指针的垂直坐标</td></tr><tr><td>screenY</td><td>鼠标指针的垂直坐标</td></tr><tr><td>ctrlKey</td><td>CTRL键是否被按下</td></tr><tr><td>altKey</td><td>ALT键是否被按下</td></tr><tr><td>shiftKey</td><td>SHIFT键是否被按下</td></tr><tr><td>code</td><td>按键的预定名称</td></tr><tr><td>keyCode</td><td>按键的ASCII值</td></tr><tr><td>key</td><td>按下的具体哪个键</td></tr></tbody></table><h3 id="JavaScrip事件的触发"><a href="#JavaScrip事件的触发" class="headerlink" title="JavaScrip事件的触发"></a>JavaScrip事件的触发</h3><ul><li><p>常规触发方式：element.click() 、 element.dblclick()</p></li><li><p>通用主动触发(非谷歌)：element.fireEvent(“onchange”);</p></li><li><p>谷歌浏览器则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var evt = document.createEvent(&quot;HTMLEvents&quot;);</span><br><span class="line">evt.initEvent(&quot;click&quot;, false, true);</span><br><span class="line">element.dispatchEvent(evt);</span><br></pre></td></tr></table></figure></li><li><p>事件的传递-冒泡(从内向外)，可以通过目标对象判断是谁</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Web基础-JavaScript语言&quot;&gt;&lt;a href=&quot;#Web基础-JavaScript语言&quot; class=&quot;headerlink&quot; title=&quot;Web基础-JavaScript语言&quot;&gt;&lt;/a&gt;Web基础-JavaScript语言&lt;/h1&gt;&lt;h2 id=&quot;J
      
    
    </summary>
    
    
      <category term="语言编程" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>线性代数笔记</title>
    <link href="http://yoursite.com/2019/12/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/12/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-09T12:00:00.000Z</published>
    <updated>2019-12-09T11:59:31.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性代数笔记"><a href="#线性代数笔记" class="headerlink" title="线性代数笔记"></a>线性代数笔记</h1><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="什么是线性代数"><a href="#什么是线性代数" class="headerlink" title="什么是线性代数"></a>什么是线性代数</h3><ul><li>线性代数就是<strong>高维</strong>的解析几何</li><li>线性代数用到的工具：矩阵、行列式</li><li>本笔记学习主要学习记录矩阵与行列式的定义与使用</li><li>暂不考虑解析几何的计算</li></ul><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><h3 id="行列式-1"><a href="#行列式-1" class="headerlink" title="行列式"></a>行列式</h3><ul><li>等行等列的式子称为<strong>行列式</strong></li><li>二行二列的式子称为 二阶行列式、三行三列的式子称为 三阶行列式、以此类推</li><li>每个行(r)列(c)式都可以计算出一个数(D)</li></ul><h3 id="二元线性方程组与二阶行列式"><a href="#二元线性方程组与二阶行列式" class="headerlink" title="二元线性方程组与二阶行列式"></a>二元线性方程组与二阶行列式</h3><ul><li>计算 a[11]x1 + a[12]x2 = b1</li><li>还有 a[21]x1 + a[22]x2 = b2</li><li>计算消除x2，为 <code>式子① * a[22] - 式子② * a[12]</code> 可以得到，同理可得</li><li>(a[11]a[22] - a[12]a[21]) * x1 = b1 * a[22] - b2 * a[12]</li><li>(a[11]a[22] - a[12]a[21]) * x1 = b2 * a[11] - b2 * a[21]</li><li>如果 <code>a[11]a[22] - a[12]a[21]</code> 不等于零，则可以除过去</li><li>x1 = (b1 * a[22] - b2 * a[12]) / (a[11]a[22] - a[12]a[21])</li><li>x2 = (b2 * a[11] - b2 * a[21]) / (a[11]a[22] - a[12]a[21])</li><li>两个不同的分子，一个相同的分母，可以用三个矩阵表示</li><li>| a[11] a[12] | - - | b1 a[12] | - - | a[12] b1 |</li><li>| a[21] a[22] | - - | b2 a[22] | - - | a[22] b2 |</li><li>三个矩阵分别是 D D1 D2 ， D1 D2 分别是 b1 b2 替换掉 D 的第一列第二列实现的</li><li>则二元线性方程组的两个解为 x1 = D1 / D ; x2 = D2 / D</li><li></li><li>二阶行列式的值 = 主对角线各元素乘积 - 负对角线各元素乘积</li></ul><h3 id="n阶行列式的基本推算"><a href="#n阶行列式的基本推算" class="headerlink" title="n阶行列式的基本推算"></a>n阶行列式的基本推算</h3><ul><li>排列：由正整数 1,2，…，n 按一定次序排成一列，叫做这n各元素的全排列</li><li>逆序对：该元素与之后的各元素对比，如果小于某元素，则两个元素称为一个逆序对</li><li>逆序数：逆序对的个数称为逆序数，表示如下：</li><li>τ(i1,i2…in) = τ(i1)+τ(i2)+…+τ(in)</li><li>例如：τ(3,4,2)=τ(3)+τ(4)+τ(2)=1+1+0=2 –&gt; [32]、[42]</li><li>相邻对换：排列中，两个元素对调，其余元素不变，会改变排列的奇偶性</li><li>特殊行列式：下三角行列式(主对角线上方都是0)、上三角行列式(主对角线下方都是0)、对角行列式(主对角线上下方都是0) 计算方式为主对角线各元素的乘积</li><li>M = (-1)^τ(i1,i2…in) * a[1i]a[2i]…a[ni]</li></ul><h3 id="行列式性质推论"><a href="#行列式性质推论" class="headerlink" title="行列式性质推论"></a>行列式性质推论</h3><ol><li>行列式中，如果每行、每列进行转置，行列式的值不变：D = D^T ； 通过基本公式可以拆分获得</li><li>行列式中的两行(列)进行交换，行列式变号 ； 根据 τ 次序变化获得<ul><li>推论：行列式中，如果有两行(列)相同，则行列式的值 D = 0 ；两行(列)相同的进行互换，行列式变号，D=-D，则D为0</li></ul></li><li>行列式中某一行(列)有公因子k，则k可以提到行列式前面。也就是说，k乘行列式，等于用k乘行列式的某一行 ； 根据基本公式拆分，提取公共项k可得<ul><li>推论：若行列式存在某一行(列)的元素都为零，则行列式的值D = 0 ； 提取此行公因数0,0*D=0</li></ul></li><li>如果行列式有两行(列)成比例，则行列式D = 0 ； 提取比例公因数k，两行相同M=0，答案为：K*M = K*0 = 0</li><li>行列式的拆分定理，如果某行每个可以拆为a+b，可以直接分为两个 此行为a的行列式 + 此行为b的行列式</li><li>行列式某行(列)的倍数加到另一行(列)，值不变 ； 根据定理5，原式+某行倍数(D+Dk)，其中某行倍数根据定理4，Dk=0，所以D+Dk=D</li></ol><h3 id="行列式的特殊式子"><a href="#行列式的特殊式子" class="headerlink" title="行列式的特殊式子"></a>行列式的特殊式子</h3><ul><li>余子式M ：a[ij]的余子式，就是行列式删去i行，j列的所有元素，剩余元素组成的行列式，记做 M[ij]</li><li>代数余子式A ：元素a[ij]的代数余子式就是 A[ij] = (-1)^(i+j) M[ij]</li><li>行列式中，第i行，除了a[ji]以外其他元素都为0，则 D=a[ij]*A[ij]</li><li>D = a[i1]A[i1] + a[i2]A[i2] +…+ a[in]A[in] ； 拆分可得，证明上述计算</li></ul><h3 id="行列式的计算技巧"><a href="#行列式的计算技巧" class="headerlink" title="行列式的计算技巧"></a>行列式的计算技巧</h3><ul><li>根据基础公式进行计算</li><li>根据上下三角进行计算 ： 凑三角</li><li>根据余子式进行计算 ： a[ij]所在行(列)其他元素凑0</li></ul><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="线性方程组与矩阵"><a href="#线性方程组与矩阵" class="headerlink" title="线性方程组与矩阵"></a>线性方程组与矩阵</h3><ul><li>计算 a[11]x1 + a[12]x2 +…+ a[1n]xn = b1</li><li>还有 a[21]x1 + a[22]x2 +…+ a[2n]xn = b2</li><li>等等</li><li>最后 a[m1]x1 + a[m2]x2 +…+ a[mn]xn = bm</li><li>计算这样的式子，去除x和计算符，剩下的矩阵与方程组息息相关，所以我们定义了矩阵</li><li>称为：m*n矩阵，矩阵常用A、B、C来表示，记做 A = (a[ij])m*n</li><li><strong>矩阵定义</strong>：矩阵是由m*n个数，排成m行n列的<strong>表格</strong>；而行列式是n行n列的<strong>数</strong></li><li>复矩阵：由复数构成的矩阵</li><li>实矩阵：由实数构成的矩阵(常使用)</li><li>同型矩阵：两个矩阵的行数相等、列数也相等，则称为同型矩阵</li><li>矩阵相等：如果两个同型矩阵，他们对应的每个元素都相等，则这两个矩阵相等</li><li><strong>矩阵与行列式的区别</strong>：矩阵是表，行列式是数；他们的计算法则不同；表示不同，矩阵是大括弧，行列式是两个直线</li></ul><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><ul><li>零矩阵：矩阵中每个元素都为0，常记做0</li><li>行矩阵(行向量α)：行数为1的矩阵</li><li>列矩阵(列向量β)：列数为1的矩阵</li><li>方阵：行数与列数相等的矩阵</li></ul><h4 id="特殊方阵"><a href="#特殊方阵" class="headerlink" title="特殊方阵"></a>特殊方阵</h4><ul><li>上三角阵：主对角线下方都是零元素</li><li>下三角阵：主对角线上方都是零元素</li><li>对角阵：主对角线以外元素都为零</li><li>单位阵：主对角线元素都为1，其余元素都为0，常记做E[n] (n*n的方阵)</li></ul><h3 id="矩阵的基本计算"><a href="#矩阵的基本计算" class="headerlink" title="矩阵的基本计算"></a>矩阵的基本计算</h3><ul><li>同型矩阵的加法：两个矩阵的对应元素相加，记做A+B</li><li>矩阵与常数乘法：kA = ka[ij] k乘以矩阵 等于 每个元素都乘以k</li><li>负矩阵：-A=(-1)A=(-a[ij])</li><li>矩阵与矩阵乘法：A=(a[ij])m*n ,B=(b[ij])n*p ,结果为 C=(a[ij])m*p，记做C=AB<ul><li>要求：前式的列数 等于 后式的行数，才可以使用矩阵乘法</li><li>计算：前者的元素与后者的列元素相乘的和</li><li>结果：结果矩阵的大小是 前式的行数 乘 后式的列数</li></ul></li><li>矩阵乘法的注意特点：<ol><li>注意：不满足乘法交换律：AB≠BC</li><li>注意：两个非零矩阵乘积可能是零矩阵，由AB=0不可以得到A=0或B=0</li><li>注意：不满足消去率，若AB=AC=0且A≠0，不可以得到B=C</li></ol></li><li>A^k = A*A*…*A 记做 A的k次幂，幂公式通用</li><li>转置矩阵：AT，其运算规律：<code>(AT)T=A</code>、<code>(A+B)T=AT+BT</code>、<code>(λA)T=λAT</code>、<code>(AB)T=BTAT</code> (注意顺序AB变BA)</li><li>设A是n阶方针，如果AT=A，则乘A为对称矩阵，简称对称阵；它的元素以主对角线为对称轴对应相等</li><li>设A是n阶方针，如果AT=-A，则乘A为反对称矩阵，简称反对称阵；它的元素关于主对角线异号，并且主对角线上元素全为零</li></ul><h3 id="向量矩阵的计算"><a href="#向量矩阵的计算" class="headerlink" title="向量矩阵的计算"></a>向量矩阵的计算</h3><ul><li>列向量 * 行向量 = <strong>方阵</strong></li><li>行向量 * 列向量 = <strong>数</strong>(上述方阵的<strong>迹</strong>(主对角元素之和))</li></ul><h3 id="矩阵的性质推论"><a href="#矩阵的性质推论" class="headerlink" title="矩阵的性质推论"></a>矩阵的性质推论</h3><h3 id="矩阵的行列式"><a href="#矩阵的行列式" class="headerlink" title="矩阵的行列式"></a>矩阵的行列式</h3><ul><li>由n阶方阵A的元素所构成的行列式(各元素的位置不变)，称为方阵A的行列式，记为detA 或 |A|</li><li>矩阵的行列式的性质：<ol><li><code>|AT| = |A|</code></li><li><code>|kA| = K^n|A|</code></li><li><code>|AB| = |A|*|B|</code></li></ol></li></ul><h2 id="线性代数进一步学习"><a href="#线性代数进一步学习" class="headerlink" title="线性代数进一步学习"></a>线性代数进一步学习</h2><h3 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h3><h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><h3 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h3><h3 id="初等变换与初等矩阵"><a href="#初等变换与初等矩阵" class="headerlink" title="初等变换与初等矩阵"></a>初等变换与初等矩阵</h3><h3 id="…"><a href="#…" class="headerlink" title="…"></a>…</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性代数笔记&quot;&gt;&lt;a href=&quot;#线性代数笔记&quot; class=&quot;headerlink&quot; title=&quot;线性代数笔记&quot;&gt;&lt;/a&gt;线性代数笔记&lt;/h1&gt;&lt;h2 id=&quot;线性代数&quot;&gt;&lt;a href=&quot;#线性代数&quot; class=&quot;headerlink&quot; title=&quot;线
      
    
    </summary>
    
    
      <category term="结构算法" scheme="http://yoursite.com/categories/%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java实践-WebServer(仿Tomcat)</title>
    <link href="http://yoursite.com/2019/12/09/Java%E5%AE%9E%E8%B7%B5-WebServer(%E4%BB%BFTomcat)/"/>
    <id>http://yoursite.com/2019/12/09/Java%E5%AE%9E%E8%B7%B5-WebServer(%E4%BB%BFTomcat)/</id>
    <published>2019-12-09T11:59:17.000Z</published>
    <updated>2019-12-09T11:58:51.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java实践-WebServer-仿Tomcat"><a href="#Java实践-WebServer-仿Tomcat" class="headerlink" title="Java实践-WebServer(仿Tomcat)"></a>Java实践-WebServer(仿Tomcat)</h1><h2 id="项目解析"><a href="#项目解析" class="headerlink" title="项目解析"></a>项目解析</h2><h3 id="什么是WebServer"><a href="#什么是WebServer" class="headerlink" title="什么是WebServer"></a>什么是WebServer</h3><ul><li>WebServer也称Web容器，用于存放WebApp，一个WebServer可以存放多个WebApp</li><li>Server服务器，WebServer就是Web服务器，就是支持HTTP应用协议的服务器</li><li>其工作流程一般三部分：解析请求、处理请求、发送响应</li><li>注意浏览器(客户端)在连接到服务端后会立即发送一个请求到服务端确认</li><li>WebApp储存：网页，其他素材，程序代码等</li></ul><h3 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h3><ul><li>做到类似 Tomcat 可以响应浏览器的各种请求，并做到应答处理</li><li>在业务方面，完成注册和登录的实现（用户名、密码、昵称、年龄）</li></ul><h3 id="需求分析-方向"><a href="#需求分析-方向" class="headerlink" title="需求分析(方向)"></a>需求分析(方向)</h3><ul><li>通过HTTP协议建立浏览器客户端与服务器之间的连接，完成WebServer任务</li><li>主要事务有两种，一个是资源请求，一个是业务处理</li><li>资源请求的两种情况：资源存在–&gt;发送资源；资源不存在–&gt;响应404页面</li><li>业务处理有多种，这里暂时实现注册和登录两个业务</li></ul><h3 id="需求分析-细节"><a href="#需求分析-细节" class="headerlink" title="需求分析(细节)"></a>需求分析(细节)</h3><ul><li>熟悉HTTP协议，在C/S沟通过程中，正确解析消息信息，正确响应响应信息</li><li>熟悉XML的使用，尤其是 MimeMapping 必须XML导入</li><li>使用线程池、超类、封装等，优化项目性能，增强其可扩展性</li><li>在构建此项目时，最重要的是学习该编程思想</li></ul><h2 id="项目搭建-准备"><a href="#项目搭建-准备" class="headerlink" title="项目搭建 - 准备"></a>项目搭建 - 准备</h2><h3 id="项目准备工作"><a href="#项目准备工作" class="headerlink" title="项目准备工作"></a>项目准备工作</h3><ul><li>创建 Maven Project ，设置好项目参数</li><li>导入后期会用到的 dom4j Jar包</li><li>创建三个包：<code>core</code> 核心代码包、<code>http</code> HTTP相关代码包、<code>servlet</code> 存放各servlet的包</li><li>项目根目录创建两个文件夹：<code>conf</code> 存放各配置文件、<code>webapps</code> 存放Web资源</li><li>向 <code>conf</code> 文件夹中导入所需的 MimeMapping XML配置文件</li><li>在 <code>webapps</code> 文件夹下创建 <code>myweb</code>和<code>root</code> 文件夹，前者创建各网页资源，后者创建一个公用的404页面</li><li>目录<code>myweb</code>文件：index主页、注册/注册成功/注册失败页面、登录/登录成功/登录失败页面</li></ul><h3 id="核心代码：实现连接"><a href="#核心代码：实现连接" class="headerlink" title="核心代码：实现连接"></a>核心代码：实现连接</h3><ul><li>创建 <code>WebServer</code> 类作为主类，定义线程池，申请8088端口，并且循环等待连接获取Socket，传入 ‘ClientHandler’ 类生成线程任务，放入线程池</li><li>创建 ‘ClientHandler’ 类作为处理事务类，通过主类传过来的Socket进行工作，注意Socket的关闭(写在finally中)</li></ul><h3 id="创建HTTP相关类"><a href="#创建HTTP相关类" class="headerlink" title="创建HTTP相关类"></a>创建HTTP相关类</h3><ul><li><code>HttpContext</code>工具类、<code>EmptyRequestException</code>空请求类、<code>HttpRequst</code>请求类、<code>HttpResponse</code>响应类</li><li>创建 <code>HttpContext</code> 类，主要用作工具类，存储查询MimeMapping，静态块中初始化MimeMapping，并提供公用方法 根据后缀 查询 Mime-Type</li><li>web.xml 文件结构说明：每个二级标签<code>&lt;mime-mapping&gt;</code>下存有：<code>&lt;extension&gt;</code>中的文本作为文件后缀，<code>&lt;mime-type&gt;</code>中的文本作为MimeType</li><li>创建 <code>EmptyRequestException</code> 类，自定义的空请求类，因为浏览器会时不时发送空请求</li><li>创建 <code>HttpRequst</code> 类，完成请求的解析，并储存到成员变量中</li><li>注意空请求情况的处理，以及业务参数的解析</li><li>创建 <code>HttpResponse</code> 类，构造方法初始化参数，编写get/set方法，提供一个 flush() 方法暂不编写</li></ul><h3 id="创建Server-Context类"><a href="#创建Server-Context类" class="headerlink" title="创建Server Context类"></a>创建Server Context类</h3><ul><li>创建’ServerContext’类，主要用作工具类，存储查询ServletMapping，静态块中初始化ServletMapping，并提供公用方法 根据请求方式 查询对应Servlet</li><li>注意前提先创建 <code>HttpServlet</code>类 <code>RegServlet</code>类 <code>LoginServlet</code>类，内容可以为空，为了配合ServletMapping中的value类型</li><li>注意前提先创建一个servlet.xml文件，存放uri对应业务的servlet类全名，储存好这次需求两个业务的值</li></ul><h2 id="项目搭建-事务"><a href="#项目搭建-事务" class="headerlink" title="项目搭建 - 事务"></a>项目搭建 - 事务</h2><h3 id="响应请求资源"><a href="#响应请求资源" class="headerlink" title="响应请求资源"></a>响应请求资源</h3><ul><li><code>ClientHandler</code> 类中的 run() 方法开始编写事务，初始化请求类、响应类，根据获取的servlet判定(是否为null)是什么事务</li><li>先处理资源事务：判断是否存在资源，决定返回什么资源，最后进行 flush() 响应资源</li><li>进一步编写 <code>Response</code> 类中的 setEntity() 方法 和 flush() 方法</li></ul><h3 id="响应请求业务"><a href="#响应请求业务" class="headerlink" title="响应请求业务"></a>响应请求业务</h3><ul><li>创建对应业务处理，完善 <code>HttpServlet</code> 抽象超类</li><li>完善 <code>RegServlet</code> 注册类</li><li>完善 <code>LoginServlet</code> 登录类</li><li>优化代码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java实践-WebServer-仿Tomcat&quot;&gt;&lt;a href=&quot;#Java实践-WebServer-仿Tomcat&quot; class=&quot;headerlink&quot; title=&quot;Java实践-WebServer(仿Tomcat)&quot;&gt;&lt;/a&gt;Java实践-WebSer
      
    
    </summary>
    
    
      <category term="语言编程" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Java实践-聊天室(C/S网络编程)</title>
    <link href="http://yoursite.com/2019/12/09/Java%E5%AE%9E%E8%B7%B5-%E8%81%8A%E5%A4%A9%E5%AE%A4(C-S%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B)/"/>
    <id>http://yoursite.com/2019/12/09/Java%E5%AE%9E%E8%B7%B5-%E8%81%8A%E5%A4%A9%E5%AE%A4(C-S%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B)/</id>
    <published>2019-12-09T11:58:17.000Z</published>
    <updated>2019-12-09T11:58:09.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java实践-聊天室-C-S网络编程"><a href="#Java实践-聊天室-C-S网络编程" class="headerlink" title="Java实践-聊天室(C/S网络编程)"></a>Java实践-聊天室(C/S网络编程)</h1><h2 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java实践-聊天室-C-S网络编程&quot;&gt;&lt;a href=&quot;#Java实践-聊天室-C-S网络编程&quot; class=&quot;headerlink&quot; title=&quot;Java实践-聊天室(C/S网络编程)&quot;&gt;&lt;/a&gt;Java实践-聊天室(C/S网络编程)&lt;/h1&gt;&lt;h2 id=
      
    
    </summary>
    
    
      <category term="项目练习" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java练习-随机读写/顺序读写</title>
    <link href="http://yoursite.com/2019/12/09/Java%E7%BB%83%E4%B9%A0-%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99-%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99/"/>
    <id>http://yoursite.com/2019/12/09/Java%E7%BB%83%E4%B9%A0-%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99-%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99/</id>
    <published>2019-12-09T11:57:17.000Z</published>
    <updated>2019-12-09T11:56:53.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java练习-随机读写-顺序读写"><a href="#Java练习-随机读写-顺序读写" class="headerlink" title="Java练习-随机读写/顺序读写"></a>Java练习-随机读写/顺序读写</h1><h2 id="随机读写复制文件"><a href="#随机读写复制文件" class="headerlink" title="随机读写复制文件"></a>随机读写复制文件</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul><li>随机读写使用 java.io.RandomAccessFile 类实现</li><li>随机打开两个文件，一个读取，一个写入</li><li>由于读写是字节读写，效率不高，所以通过定义数组来提高读写性能</li></ul><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile src = new RandomAccessFile(&quot;./demo.zip&quot;,&quot;r&quot;);  //通过随机读写打开源文件，定义权限只读即可</span><br><span class="line">RandomAccessFile desc = new RandomAccessFile(&quot;./demo_cp.zip&quot;,&quot;rw&quot;);  //通过随机读写打开目标文件，定义权限读写</span><br><span class="line"></span><br><span class="line">byte[] buf = new byte[1024*10];  //为了提高速率使用字节数组</span><br><span class="line">int len = -1;  //定义每次实际读取到的字节</span><br><span class="line"></span><br><span class="line">while((len = src.read(buf))!=-1) &#123;</span><br><span class="line">desc.write(buf,0,len);  //只要读取到数据，就往目标文件中写入读取到长度的数据</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;复制完毕!&quot;);</span><br><span class="line">src.close();  //记得关闭文件</span><br><span class="line">desc.close();  //记得关闭文件</span><br></pre></td></tr></table></figure><h2 id="顺序读写复制文件"><a href="#顺序读写复制文件" class="headerlink" title="顺序读写复制文件"></a>顺序读写复制文件</h2><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><ul><li>顺序读写是通过 IO 流实现的，java.io.InputStream , java.io.OutputStream</li><li>通过IO连接到两个文件，一个使用输入流，一个使用输出流</li><li>由于读写是字节读写，效率不高，所以通过缓冲流的高级流来提高效率</li></ul><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = new FileInputStream(&quot;demo.zip&quot;);  //定义输入流，连接到源文件</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(fis);  //定义缓冲流，连接到输入流上，提高效率</span><br><span class="line"></span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;demo_cp.zip&quot;);  //定义输出流，连接到目标文件</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(fos);  //定义缓冲流，连接到输出流上，提高效率</span><br><span class="line"></span><br><span class="line">int d = -1;  //定义每次实际读取到的字节</span><br><span class="line"></span><br><span class="line">while((d=bis.read())!=-1) &#123;</span><br><span class="line">bos.write(d);  //将读到的字节存储到缓冲流中</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;复制完毕!&quot;);</span><br><span class="line">bis.close();  //只需要关闭最高层高级流即可，连接到后面的流会逐级关闭</span><br><span class="line">bos.close();  //执行缓冲流的flush()方法 或 缓冲区满了 或 缓冲流关闭时，缓冲流会向文件按缓冲大小写数据</span><br></pre></td></tr></table></figure><h2 id="随机读写存取用户信息"><a href="#随机读写存取用户信息" class="headerlink" title="随机读写存取用户信息"></a>随机读写存取用户信息</h2><h3 id="练习需求"><a href="#练习需求" class="headerlink" title="练习需求"></a>练习需求</h3><ul><li>实现1：完成用户注册功能，程序启动后顺序输入：用户名，密码，昵称，年龄，然后将其写入文件user.dat中保存</li><li>实现2：修改昵称功能，程序启动后要求用户输入用户名和新昵称，然后将user.dat文件中对应的记录进行修改，如果输入的用户名在user.dat文件中不存在，则输出：查无此人</li></ul><h3 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h3><ul><li>分析：设置用户名、密码、昵称为String类型，年龄为int类型</li><li>定义格式：每条记录占用100字节，其中用户名，密码，昵称各占32字节，年龄占4字节</li><li>操作：通过随机读写的指针对文件进行增改查操作</li></ul><h3 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//通过控制台输入，获取注册信息</span><br><span class="line">System.out.println(&quot;欢迎注册&quot;);</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入用户名&quot;);</span><br><span class="line">String user = scan.next();</span><br><span class="line">System.out.println(&quot;请输入密码&quot;);</span><br><span class="line">String pwd = scan.next();</span><br><span class="line">System.out.println(&quot;请输入昵称&quot;);</span><br><span class="line">String nick = scan.next();</span><br><span class="line">System.out.println(&quot;请输入年龄&quot;);</span><br><span class="line">int age = scan.nextInt();</span><br><span class="line">scan.close();</span><br><span class="line">//随机打开用户文件，并将文件指针指向最后</span><br><span class="line">RandomAccessFile raf = new RandomAccessFile(&quot;user.dat&quot;,&quot;rw&quot;);</span><br><span class="line">raf.seek(raf.length());</span><br><span class="line">//定义字节数组存放数据</span><br><span class="line">byte[] data;</span><br><span class="line">//储存用户信息</span><br><span class="line">data= user.getBytes(&quot;utf-8&quot;);  //将用户信息根据utf-8拆为字节数组</span><br><span class="line">data = Arrays.copyOf(data, 32);  //将该数组扩容到32字节</span><br><span class="line">raf.write(data);  //写入该数组</span><br><span class="line">//同上</span><br><span class="line">data = pwd.getBytes(&quot;utf-8&quot;);</span><br><span class="line">data = Arrays.copyOf(data, 32);</span><br><span class="line">raf.write(data);</span><br><span class="line">//同上</span><br><span class="line">data = nick.getBytes(&quot;utf-8&quot;);</span><br><span class="line">data = Arrays.copyOf(data, 32);</span><br><span class="line">raf.write(data);</span><br><span class="line">//直接通过 writeInt() 方法将int值存入到文件中</span><br><span class="line">raf.writeInt(age);</span><br><span class="line">raf.close();  //关闭文件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//通过控制台输入，获取修改信息</span><br><span class="line">System.out.println(&quot;**修改昵称**&quot;);</span><br><span class="line">Scanner scan = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入用户名：&quot;);</span><br><span class="line">String name = scan.nextLine();</span><br><span class="line">System.out.println(&quot;请输入新昵称：&quot;);</span><br><span class="line">String nick = scan.nextLine();</span><br><span class="line">scan.close();</span><br><span class="line">//随机打开用户文件</span><br><span class="line">RandomAccessFile raf = new RandomAccessFile(&quot;user.dat&quot;,&quot;rw&quot;);</span><br><span class="line">for(int i=0;i&lt;raf.length()/100;i++) &#123;  //通过遍历查找用户，循环条件为条数</span><br><span class="line">raf.seek(i*100);  //确定指针位置</span><br><span class="line">    //定义并读取32字节数据，返回字符串并清除空白</span><br><span class="line">byte[] data = new byte[32];  </span><br><span class="line">raf.read(data);</span><br><span class="line">String user = new String(data).trim();</span><br><span class="line">//判断是否为本条信息中的用户</span><br><span class="line">if(user.equals(name)) &#123;</span><br><span class="line">raf.seek(raf.getFilePointer()+32);  //指针指向本条信息昵称位置</span><br><span class="line">        //同上的写入操作</span><br><span class="line">data = nick.getBytes();</span><br><span class="line">data = Arrays.copyOf(data, 32);</span><br><span class="line">raf.write(data);</span><br><span class="line">System.out.println(&quot;修改完成&quot;);</span><br><span class="line">break;  //完成任务，退出循环</span><br><span class="line">&#125;</span><br><span class="line">    //如果指针到了最后一条还是找到用户</span><br><span class="line">if(raf.getFilePointer()==raf.length()-100+32) &#123;</span><br><span class="line">System.out.println(&quot;查无此人&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">raf.close();  //关闭文件</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java练习-随机读写-顺序读写&quot;&gt;&lt;a href=&quot;#Java练习-随机读写-顺序读写&quot; class=&quot;headerlink&quot; title=&quot;Java练习-随机读写/顺序读写&quot;&gt;&lt;/a&gt;Java练习-随机读写/顺序读写&lt;/h1&gt;&lt;h2 id=&quot;随机读写复制文件&quot;
      
    
    </summary>
    
    
      <category term="项目练习" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java实践-飞机大战</title>
    <link href="http://yoursite.com/2019/12/09/Java%E5%AE%9E%E8%B7%B5-%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/"/>
    <id>http://yoursite.com/2019/12/09/Java%E5%AE%9E%E8%B7%B5-%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/</id>
    <published>2019-12-09T11:56:46.000Z</published>
    <updated>2019-12-09T11:56:04.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java实践-飞机大战"><a href="#Java实践-飞机大战" class="headerlink" title="Java实践-飞机大战"></a>Java实践-飞机大战</h1><h2 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java实践-飞机大战&quot;&gt;&lt;a href=&quot;#Java实践-飞机大战&quot; class=&quot;headerlink&quot; title=&quot;Java实践-飞机大战&quot;&gt;&lt;/a&gt;Java实践-飞机大战&lt;/h1&gt;&lt;h2 id=&quot;待更新&quot;&gt;&lt;a href=&quot;#待更新&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="项目练习" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>XML可扩展标记语言</title>
    <link href="http://yoursite.com/2019/12/09/XML%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2019/12/09/XML%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/</id>
    <published>2019-12-09T11:55:00.000Z</published>
    <updated>2019-12-09T11:55:09.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XML可扩展标记语言"><a href="#XML可扩展标记语言" class="headerlink" title="XML可扩展标记语言"></a>XML可扩展标记语言</h1><h2 id="XML基本名词"><a href="#XML基本名词" class="headerlink" title="XML基本名词"></a>XML基本名词</h2><ul><li>XML(Extensible Markup Language)主要用于web开发的许多方面，常用语简化数据的存储和共享</li><li>XML文档包含XML元素，元素拥有属性，通过属性名=属性值实现，属性值可以用单引号包裹，但是常用双引号</li><li>XML元素内可包含其他元素、文本或两者的混合物</li><li>XML大小写敏感，标签必须有开始标签对应结束标签，特殊的：标签缩写<code>&lt;Letter /&gt;</code></li><li>XML要求必须只有一个根标签</li></ul><h2 id="XML的语法"><a href="#XML的语法" class="headerlink" title="XML的语法"></a>XML的语法</h2><h3 id="XML文档声明"><a href="#XML文档声明" class="headerlink" title="XML文档声明"></a>XML文档声明</h3><ul><li>XML文档声明如：<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</code></li><li>语法以<code>&lt;?</code>开始，以<code>?&gt;</code>结束，内容包含version encoding standalone</li><li>standalone表示是否允许外部声明(是否是独立存在的XML文档),yes|no,yes表示不使用外部声明，自己是一个独立的XML文档</li></ul><h3 id="XML实体引用、CDATA段"><a href="#XML实体引用、CDATA段" class="headerlink" title="XML实体引用、CDATA段"></a>XML实体引用、CDATA段</h3><ul><li>由于XML中有很多字符有特殊含义，在XML中有时实体内包含一些字符，如<code>&gt; &lt; &quot; 等</code>，这些字符需要进行转义才可以正常显示</li><li>有时可能实体内特殊字符特别多，这时候可以使用CDATA段，无论在段内写什么，都会被当做一个文本</li><li><code>&lt;![CDATA[----段内文本----]]&gt;</code></li></ul><table><thead><tr><th>实体引用</th><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>&lt;</td><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>&gt;</td><td>大于</td></tr><tr><td>&amp;</td><td>&amp;</td><td>And</td></tr><tr><td>&apos;</td><td>‘</td><td>单引号</td></tr><tr><td>&quot;</td><td>“</td><td>双引号</td></tr></tbody></table><h3 id="特殊指令"><a href="#特殊指令" class="headerlink" title="特殊指令"></a>特殊指令</h3><ul><li>XML处理指令，简称PI(processing instruction)，用来指挥解析引擎如何解析XML文档内容</li><li>例如在XML文档中可以使用xml-stylesheet指令，通知XML解析引擎，应用css文件显示xml文档内容</li><li><code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;1.css&quot;?&gt;</code></li><li>语法以<code>&lt;?</code>开始，以<code>?&gt;</code>结束，XML文档声明就是最常见的一种处理指令</li></ul><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li>属性 子标签 的区别使用</li><li>标签与标签之间有从属关系</li><li>属性特指的是该标签的属性</li></ul><h2 id="XML：DTD约束文档：简单约束文档"><a href="#XML：DTD约束文档：简单约束文档" class="headerlink" title="XML：DTD约束文档：简单约束文档"></a>XML：DTD约束文档：简单约束文档</h2><h3 id="DTD约束文档"><a href="#DTD约束文档" class="headerlink" title="DTD约束文档"></a>DTD约束文档</h3><ul><li>DTD主要用来约束xml文件，本身也是XML语法书写的，后缀名为dtd</li><li>DTD可以单独写在文件中，也可以直接定义在xml中，可以在xml中引入第三方的公共DTD</li></ul><h3 id="DTD导入方式"><a href="#DTD导入方式" class="headerlink" title="DTD导入方式"></a>DTD导入方式</h3><ol><li>本地引入方式：<code>&lt;!DOCTYPE 文档根结点名称 SYSTEM &quot;DTD文件路径&quot;&gt;</code></li><li>公共文档引入方式：<code>&lt;!DOCTYPE 文档根结点名称 PUBLIC &quot;DTD名称&quot; &quot;DTD文件的URL&quot;&gt;</code></li><li>在XML中直接书写DTD方式：<code>&lt;!DOCTYPE 文档根结点名称 [具体的标签的约束]&gt;</code></li></ol><h3 id="DTD语法"><a href="#DTD语法" class="headerlink" title="DTD语法"></a>DTD语法</h3><ul><li><code>&lt;!ELEMENT 标签类型名&gt;</code>：声明可以在XML中出现的标签类型名</li><li><code>&lt;!ATTLIST 标签类型名 属性名&gt;</code>：声明可以在当前标签内部使用的属性名</li><li><code>&lt;!ELEMENT 标签类型名 (子标签名?)&gt;</code>：子标签出现在父标签内0-1次</li><li><code>&lt;!ELEMENT 标签类型名 (子标签名+)&gt;</code>：子标签出现在父标签内至少1次</li><li><code>&lt;!ELEMENT 标签类型名 (#PCDATA)&gt;</code>：当前标签没有子标签</li><li><code>&lt;!ELEMENT 标签类型名 (子标签名*)&gt;</code>：子标签出现在父标签内任意次0-∞</li><li><code>&lt;!ELEMENT 标签类型名 (子标签名)&gt;</code>：子标签必须出现在父标签内，且只能出现一次，并且有顺序问题</li><li><code>&lt;!ELEMENT 标签类型名 (子标签名1|子标签名2)+&gt;</code>：两个必须有一个出现在父标签至少一次，且不能同时出现</li><li>子标签与子标签之间使用<code>,</code>分隔</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!ELEMENT users (user+) &gt;</span><br><span class="line">&lt;!ELEMENT user (name,age,addr) &gt;</span><br><span class="line">&lt;!ELEMENT name (#PCDATA) &gt;    #PCDATA：本节点可包含任何字符数据，但不能在其中包含任何子元素</span><br><span class="line">&lt;!ELEMENT age EMPTY &gt;    EMPTY：本结点不包含任何结点和文本，仅可使用属性</span><br><span class="line">&lt;!ELEMENT addr (#PCDATA) &gt;</span><br><span class="line">&lt;!ATTLIST user id ID #REQUIRED &gt;    ID：表示必须使用唯一值；#REQUIRED：属性值是必需的</span><br></pre></td></tr></table></figure><h2 id="XML：Schema约束文档：高级约束文档"><a href="#XML：Schema约束文档：高级约束文档" class="headerlink" title="XML：Schema约束文档：高级约束文档"></a>XML：Schema约束文档：高级约束文档</h2><h3 id="Schema约束文档"><a href="#Schema约束文档" class="headerlink" title="Schema约束文档"></a>Schema约束文档</h3><ul><li>Schema是用来代替DTD来约束xml文档的，本身也是XML语法书写的，后缀名为xsd，根元素必须是[前缀名:]schema</li><li>相比之下，DTD在约束xml的时候一个xml中只能引入一个DTD，同时DTD它无法对属性以及标签中的数据做数据类型的限定</li><li>因为不同的Schema可以有不同的前缀名，所以可以多个文件共同约束一个XML(XML中的标签使用：前缀名:标签名 来区分使用哪个schema规则)</li><li>学习Schema主要来学习W3C组织定义的如何在Schema中去约束xml的<strong>标签以及属性</strong>，还有<strong>属性的数据类型</strong>，以及标签中<strong>子标签的顺序</strong></li></ul><h3 id="Schema导入方式"><a href="#Schema导入方式" class="headerlink" title="Schema导入方式"></a>Schema导入方式</h3><ul><li>导入方式及书写语法并非每个掌握，只需要读懂约束内容即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;[Schema前缀名:]根标签名称 xmlns=&quot;http://www.itcast.org/book&quot;   它是schema文件中的targetNamespace 属性后面的值</span><br><span class="line">        xsi:schemaLocation=&quot;http://xxxx/xxxx my.xsd&quot;   这个是在引入当前的schema文件的真实路径</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   说明当前的xml是schema一个实例文档</span><br><span class="line">        version=&quot;2.5&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>由于Schema文档也是受W3C约束的，所以Schema文档也要引入W3C约束</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;[Schema前缀名:]schema  xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;   引入W3C定义的schema书写的规范</span><br><span class="line">targetNamespace=&quot;http://xxxx/xxxx&quot; 给当前的Schema文件起名字（命名空间）</span><br></pre></td></tr></table></figure><h3 id="Schema语法"><a href="#Schema语法" class="headerlink" title="Schema语法"></a>Schema语法</h3><ul><li><code>element</code>标签：name代表当前的xml中可以书写标签名称  type数据类型  maxOccurs最多出现次数</li><li><code>complexType</code>标签：[element子标签]当前的element声明的标签是复杂标签时，需要使用complexType来声明子标签</li><li><code>complexType</code>标签：mixed属性值为true，元素间就可以出现字符文本数据了</li><li><code>sequence</code>标签：[element子标签]复杂标签是指有属性，或者有子标签，或者有属性有子标签的标签，简单标签是指只有文本内容的标签</li></ul><h2 id="解析XML"><a href="#解析XML" class="headerlink" title="解析XML"></a>解析XML</h2><ul><li>解析XML的底层接口：DOM、SAX</li><li>jdom和dom4j是基于底层api的更高级封装</li><li>DOM是通用的，jdom和dom4j则是面向java语言的</li></ul><h3 id="DOM解析方式"><a href="#DOM解析方式" class="headerlink" title="DOM解析方式"></a>DOM解析方式</h3><ul><li>DOM(Document Object Model，文档对象模型)：是W3C组织推荐的处理XML的一种方式。DOM解析器在解析XML文档时，会把文档中的所有元素按照其出现的层次关系，解析成一个个Node对象(结点)</li><li>优点：把xml文件在内存中构造树结构，可以遍历和修改结点</li><li>缺点：先读取完毕后再解析，如果文件过大，会有内存压力，解析的时间较长(尤其是大网络文件)</li></ul><h3 id="SAX解析方式"><a href="#SAX解析方式" class="headerlink" title="SAX解析方式"></a>SAX解析方式</h3><ul><li>SAX(Simple API for XML)：是一种XML解析的代替方法。相比DOM其速度更快，它逐行扫描，逐行解析。而且相比DOM，SAX可以在解析文档的任意时刻(当解析中寻找到需要的数据时)停止解析</li><li>优点：解析可以立即开始，速度快，无内存压力，相比DOM对于大文件更有优势</li><li>缺点：无法掌控结构，不能对结点做修改</li></ul><h3 id="DOM4J解析XML文档"><a href="#DOM4J解析XML文档" class="headerlink" title="DOM4J解析XML文档"></a>DOM4J解析XML文档</h3><ul><li>使用DOM4J需要导入<code>dom4j-full.jar</code>包</li><li>dom4j(dom for java)：是一个Java的XML API，类似于jdom，用来读取XML文件的</li><li>SAXReader类：常用其无参构造进行实例化对象</li><li>SAXReader类：常用方法<code>Document read(File file)</code>返回一个Document树文件对象</li><li>Document类：常用方法<code>Element getRootElement()</code>用于获取根元素</li><li>Element类：类的一个实例用于表示XML文档中的一个元素(一对标签)</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getName()</td><td>获取标签的名字</td></tr><tr><td>String getText()</td><td>获取标签中间的文本</td></tr><tr><td>Element element(String name)</td><td>获取标签中指定名字的子标签</td></tr><tr><td>Attribute attribute(String name)</td><td>返回指定名字的属性对象，该对象有两个常用方法<br><code>String getName()</code>和<code>String getValue()</code></td></tr><tr><td>List elements()</td><td>获取当前标签中所有子标签</td></tr><tr><td>List elements(String name)</td><td>获取所有同名子标签</td></tr><tr><td>String getText()</td><td>获取标签中间的去除两边空白的文本</td></tr><tr><td>String elementText(String name)</td><td>获取指定名字的子标签的中间文本</td></tr><tr><td>String elementTextTrim(String name)</td><td>获取指定名字的子标签的中间文本并trim</td></tr><tr><td>String attributeValue(String name)</td><td>获取属性中指定名字属性的值</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XML可扩展标记语言&quot;&gt;&lt;a href=&quot;#XML可扩展标记语言&quot; class=&quot;headerlink&quot; title=&quot;XML可扩展标记语言&quot;&gt;&lt;/a&gt;XML可扩展标记语言&lt;/h1&gt;&lt;h2 id=&quot;XML基本名词&quot;&gt;&lt;a href=&quot;#XML基本名词&quot; class
      
    
    </summary>
    
    
      <category term="语言编程" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="XML" scheme="http://yoursite.com/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>Maven入门与认识</title>
    <link href="http://yoursite.com/2019/12/09/Maven%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2019/12/09/Maven%E5%85%A5%E9%97%A8%E4%B8%8E%E8%AE%A4%E8%AF%86/</id>
    <published>2019-12-09T11:52:00.000Z</published>
    <updated>2019-12-09T11:51:38.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven入门与认识"><a href="#Maven入门与认识" class="headerlink" title="Maven入门与认识"></a>Maven入门与认识</h1><h2 id="Maven有什么用"><a href="#Maven有什么用" class="headerlink" title="Maven有什么用"></a>Maven有什么用</h2><ol><li>Maven可以管理jar包，解决jar包之间冲突，版本冲突，解决人工手动导jar包等麻烦问题</li><li>Maven可以像Eclipse、IDEA等，实现Java文件的实时编译</li><li>Maven可以替开发者做各种单元测试，直接找出bug所在，快速测试检验代码</li><li>maven可以快速整合打包项目资源</li></ol><h2 id="Maven核心功能"><a href="#Maven核心功能" class="headerlink" title="Maven核心功能"></a>Maven核心功能</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><ul><li>依赖管理就是Maven工程对jar包的管理过程</li><li>由于多个项目，每个项目都会导入多个Jar包，会产生每个项目可能会有重复Jar包，所以Maven具有一个Jar包仓库，用于管理所有项目会用到的Jar包，Maven工程中只需要储存jar包坐标即可(pom.xml)</li><li>Maven通过Jar包的坐标在Jar包仓库中寻找对应的Jar包</li></ul><h3 id="一键构建"><a href="#一键构建" class="headerlink" title="一键构建"></a>一键构建</h3><ul><li>使用自身集成的Tomcat插件，完成编译、测试、运行、打包、安装、部署等一系列过程</li><li>CMD进入Maven工程根目录下使用命令<code>mvn tomcat:run</code>即可运行本项目</li></ul><h2 id="Maven环境配置"><a href="#Maven环境配置" class="headerlink" title="Maven环境配置"></a>Maven环境配置</h2><ol><li><p>登录 <a href="http://maven.apache.org/" target="_blank" rel="noopener">http://maven.apache.org/</a> 下载并解压安装Apache Maven，<a href="http://doc.tedu.cn/resource/apache-maven-3.5.2-bin.zip" target="_blank" rel="noopener">达内内网立即下载</a></p></li><li><p>解压Maven到没有空格、没有中文的目录下</p></li><li><p>【可选】打开<code>maven目录/conf/settings.xml</code>配置文件，配置阿里镜像地址(配置到<code>&lt;mirrors&gt;</code>标签里)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;aliyun&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;aliyun Maven&lt;/name&gt;</span><br><span class="line">    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量：新建<code>MAVEN_HOME:Maven根目录</code>，修改Path添加<code>5MAVEN_HOME%\bin</code>(注意：Maven依赖环境变量中有JAVA_HOME)，CMD输入<code>mvn -v</code>验证</p></li><li><p>【Eclipse】配置Maven，<code>Preferences--&gt;Maven--&gt;User Setting--&gt;Global Setting</code>中选择Maven/conf下的setting.xml文件</p></li><li><p>【Eclipse】接着点击下方按钮<code>Update Settings</code>，进行更新Maven设置</p></li><li><p>【Eclipse】验证镜像地址可以通过<code>Window--&gt;Show View--&gt;Other...--&gt;Maven视图</code></p></li><li><p>【Eclipse】项目强制更新程序依赖jar包，项目右键<code>Maven--&gt;Update Project</code>，勾选Force Update of Snapshots/Releases选项确定</p></li><li><p>【IDEA】配置Maven，<code>Settings--&gt;Maven--&gt;Maven home directory</code>中设置Maven根目录</p></li><li><p>【IDEA】接着下面<code>User Setting file</code>选择Maven/conf下的setting.xml文件，下方本地仓库路径会自动更新</p></li><li><p>【IDEA】进入<code>Settings--&gt;Maven--&gt;Runner--&gt;VM Options</code>添加参数<code>-DarchetypeCatalog=internal</code></p></li></ol><h2 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h2><ul><li>Maven中有三种仓库：本地仓库、中央仓库、远程仓库(私服)</li><li>Maven默认在系统用户目录下<code>\.m2\repository</code>设置本地仓库，在网络中存在中央仓库</li><li>Maven项目默认在本地仓库寻找jar包，如果本地仓库没有的话，就会去中央仓库寻找</li><li>公司中一般会配置远程仓库(也叫私服)，寻找jar包如果本地仓库不存在，则会去远程仓库(私服)寻找</li><li>远程仓库(私服)如果也没有，私服就会去中央仓库下载，或者通过本地上传</li></ul><h2 id="Maven项目标准目录结构"><a href="#Maven项目标准目录结构" class="headerlink" title="Maven项目标准目录结构"></a>Maven项目标准目录结构</h2><ul><li>传统的项目在创建和测试过程中，一定会产生四种文件部分：核心代码部分、配置文件部分、测试代码部分、测试配置文件</li><li>但是传统的目录结构仅仅是<code>项目名\src\</code>，如果需要另外储存其他文件，自己创建文件夹名称差异化特别大，所以Maven规范化了项目目录结构</li><li>Maven项目标准目录结构：</li></ul><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>src/main/java</td><td>核心代码部分</td></tr><tr><td>src/main/resources</td><td>配置文件部分</td></tr><tr><td>src/test/java</td><td>测试代码部分</td></tr><tr><td>src/test/resources</td><td>测试配置文件</td></tr><tr><td>src/main/webapp</td><td>页面资源,js,css,图片等</td></tr></tbody></table><h2 id="Maven常用命令"><a href="#Maven常用命令" class="headerlink" title="Maven常用命令"></a>Maven常用命令</h2><ul><li>mvn clean ：把已经编译好的项目的所有信息</li><li>mvn compile ：把核心代码部分编译后，放置在target目录下</li><li>mvn test ：把测试代码部分编译后，放置在target目录下(同时执行了compile)</li><li>mvn package ：将Maven项目进行打包，放置在target目录下(同时执行了test)</li><li>mvn install ：将刚刚项目打完的包安装到本地仓库(同时执行了package)</li></ul><h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><ul><li>清理生命周期：清楚项目编译信息(clean)</li><li>默认生命周期：编译(compile)、测试(test)、打包(package)、安装(install)、发布(deploy)</li><li>站点生命周期：—</li></ul><h2 id="Maven概念模型图"><a href="#Maven概念模型图" class="headerlink" title="Maven概念模型图"></a>Maven概念模型图</h2><ul><li>项目对象模型(POM)：储存了三类信息<ol><li>项目自身信息</li><li>项目运行所依赖的jar包信息</li><li>项目运行环境信息，如jdk,tomcat等</li></ol></li><li>依赖管理模型(Dependency)：Jar包坐标信息<ol><li>公司组织名称–groupId</li><li>项目名–artifactId</li><li>版本号–version</li></ol></li><li>Build lifecycle &amp; phases ：默认生命周期命令对应的各种插件</li></ul><h2 id="Maven导入jar包"><a href="#Maven导入jar包" class="headerlink" title="Maven导入jar包"></a>Maven导入jar包</h2><ul><li>阿里在线搜索添加Jar组件”坐标”网址： <a href="https://maven.aliyun.com/mvn/search" target="_blank" rel="noopener">https://maven.aliyun.com/mvn/search</a></li><li>在pom.xml文件中添加Jar组件：在<code>&lt;dependencies&gt;</code>标签内添加Jar坐标</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Maven入门与认识&quot;&gt;&lt;a href=&quot;#Maven入门与认识&quot; class=&quot;headerlink&quot; title=&quot;Maven入门与认识&quot;&gt;&lt;/a&gt;Maven入门与认识&lt;/h1&gt;&lt;h2 id=&quot;Maven有什么用&quot;&gt;&lt;a href=&quot;#Maven有什么用&quot; c
      
    
    </summary>
    
    
      <category term="工具环境" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
      <category term="Environment" scheme="http://yoursite.com/tags/Environment/"/>
    
  </entry>
  
  <entry>
    <title>Web基础-CSS语言</title>
    <link href="http://yoursite.com/2019/12/09/Web%E5%9F%BA%E7%A1%80-CSS%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2019/12/09/Web%E5%9F%BA%E7%A1%80-CSS%E8%AF%AD%E8%A8%80/</id>
    <published>2019-12-09T11:51:06.000Z</published>
    <updated>2019-12-09T11:51:04.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web基础-CSS语言"><a href="#Web基础-CSS语言" class="headerlink" title="Web基础-CSS语言"></a>Web基础-CSS语言</h1><h2 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h2><h3 id="什么是CSS"><a href="#什么是CSS" class="headerlink" title="什么是CSS"></a>什么是CSS</h3><ul><li>CSS(Cascading Style Sheets)层叠样式表</li><li>CSS是修饰美化HTML的</li></ul><h3 id="导入CSS方法"><a href="#导入CSS方法" class="headerlink" title="导入CSS方法"></a>导入CSS方法</h3><ul><li>总共有三种方式：内联方式、内部样式表、外部样式表</li><li>内联方式：定义在单个的HTML元素中，元素的style属性</li><li>内部样式表：定义在HTML的头元素中<ul><li>头部<code>style</code>标签，属性<code>type=&quot;text/css&quot;</code>，在标签体内书写</li><li>例如：<code>&lt;style type=&quot;text/css&quot;&gt;css代码&lt;/style&gt;</code></li></ul></li><li>外部样式表：定义在一个外部的CSS文件中，HTML页面引用<ul><li>头部<code>link</code>标签，属性<code>rel=&quot;stylesheet&quot; href=&quot;css文件&quot;</code></li><li>例如：<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css文件&quot; /&gt;</code></li><li>个别规定，属性中还要写入<code>style=&quot;text/css&quot;</code></li></ul></li><li>样式优先级：以最后一次定义的为准，所以内联方式优先级最高，外部与内部样式表根据其代码定义先后，定义在后者的优先级高于前者</li><li>某样式表内如果有css冲突，则根据选择器优先级判断优先</li><li>强制优先级规定：某句样式代码后面增加语句 <code>!important</code> 可使此样式优先级最高，但是<strong>不建议使用</strong>，会混乱代码</li></ul><h3 id="CSS规则特性"><a href="#CSS规则特性" class="headerlink" title="CSS规则特性"></a>CSS规则特性</h3><ul><li>语法规则：<code>选择器{声明1;声明2}</code>，声明的内容<code>属性:值</code></li><li>继承性：元素可以继承上级元素<strong>文本</strong>和<strong>字体</strong>相关的样式，部分标签自带效果不受继承影响，比如：超链接的字体颜色，h1-h6字体大小</li><li>层叠性：同一个元素若存在多个css规则，对于不冲突的声明可以叠加</li><li>优先级：各个选择器之间的优先级，作用越小，优先级越高，ID选择器&gt;类选择器&gt;元素选择器&gt;继承(简介选中)</li><li>选择器组：多个选择器公用一段css代码，选择器与选择器使用逗号隔开</li></ul><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="常用选择器"><a href="#常用选择器" class="headerlink" title="常用选择器"></a>常用选择器</h3><h4 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h4><ul><li>使用井号加ID名进行选择</li><li>例如：<code>#id{}</code></li><li>根据元素的id属性进行选择</li></ul><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><ul><li>使用一个点加类名进行选择</li><li>例如：<code>.className{}</code></li><li>根据元素的class属性进行选择</li><li>组合示例：<code>div.className{}</code> 选择的是所有类名为className的div标签</li></ul><h4 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h4><ul><li>也叫标签名选择器：通过标签的名字进行选择</li><li>例如：<code>body{}</code> 或 <code>div{}</code></li></ul><h4 id="选择器组"><a href="#选择器组" class="headerlink" title="选择器组"></a>选择器组</h4><ul><li>多个选择器公用一段css代码，选择器与选择器使用逗号隔开</li><li>例如：<code>div.className,#id{}</code> 同时选择了：名为id的元素，所有类名为className的div元素</li></ul><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ul><li>根据元素属性进行选择</li><li>例如：<code>[attribute]</code>带有指定属性的元素 或 <code>[attribute 符号 value]</code>带有指定属性和值某种关系的元素</li></ul><table><thead><tr><th>选择器</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>[attribute]</td><td></td><td>用于选取带有指定属性的元素</td></tr><tr><td>[attribute=value]</td><td><code>=</code></td><td>用于选取带有指定属性和值的元素</td></tr><tr><td>[attribute~=value]</td><td><code>~=</code></td><td>用于选取属性值中包含指定词汇的元素</td></tr><tr><td>[attribute</td><td>=value]</td><td>`</td></tr><tr><td>[attribute^=value]</td><td><code>^=</code></td><td>匹配属性值以指定值开头的每个元素</td></tr><tr><td>[attribute$=value]</td><td><code>$=</code></td><td>匹配属性值以指定值结尾的每个元素</td></tr><tr><td>[attribute*=value]</td><td><code>*=</code></td><td>匹配属性值中包含指定值的每个元素</td></tr></tbody></table><h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>父标签 后代标签{}</td><td>父标签下所有后代标签（使用空格）</td></tr><tr><td>父标签&gt;子标签{}</td><td>只是子标签，不包含孙标签等（注意样式继承）</td></tr><tr><td>E元素+F元素{}</td><td>紧跟着E元素后的那一个F元素的样式</td></tr><tr><td>E元素~F元素{}</td><td>紧跟着E元素后的所有F元素的样式（无论中间有其他）</td></tr></tbody></table><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><table><thead><tr><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>元素名:first-letter{}</td><td>该元素的第一个字</td></tr><tr><td>元素名:first-line{}</td><td>第一行的元素</td></tr><tr><td>元素名:before {content}</td><td>元素之前插入内容</td></tr><tr><td>元素名:after{content}</td><td>元素之后插入内容</td></tr><tr><td>元素名:selection{}</td><td>元素被选择后的样式</td></tr></tbody></table><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><table><thead><tr><th><strong>结构性伪类选择器</strong></th><th>说明</th></tr></thead><tbody><tr><td>*{}</td><td>选择所有的元素</td></tr><tr><td>：root{}</td><td>选择文档的跟元素</td></tr><tr><td>E:first-child{}</td><td>第一个子元素E</td></tr><tr><td>E:last-child{}</td><td>最后一个子元素E</td></tr><tr><td>E:only-child{}</td><td>唯一一个子元素E</td></tr><tr><td>E:only-of-type{}</td><td>唯一个类型的子元素E</td></tr><tr><td>E:nth-child(n) {}</td><td>第n个子元素E—-n可以数字，可以公式，可以奇odd偶even</td></tr><tr><td>E:nth-last-child(n) {}</td><td>第n个子元素E</td></tr><tr><td>E:first-of-type{}</td><td>同类型第一个元素E</td></tr><tr><td>E:last-of-type{}</td><td>同类型最后一个元素E</td></tr><tr><td>E:nth-of-type(n){}</td><td>同类型第n个元素E</td></tr><tr><td>E:nth-last-of-type(n){}</td><td>同类型倒数第n个元素E</td></tr><tr><td>E:empty{}</td><td>选择没有任何子元素的元素E（内容也不可以有 空的元素E）</td></tr></tbody></table><table><thead><tr><th><strong>UI伪类选择器及其他</strong></th><th>说明</th></tr></thead><tbody><tr><td>E:active{}</td><td>被激活的(鼠标按下时)</td></tr><tr><td>E:hover{}</td><td>鼠标悬浮时</td></tr><tr><td>E:link{}</td><td>未被访问过的</td></tr><tr><td>E:visited{}</td><td>已被访问过的</td></tr><tr><td>E:hover{}</td><td>鼠标悬浮时</td></tr><tr><td>E:focus{}</td><td>获取焦点时</td></tr><tr><td>E:lang(){}</td><td>带有lang属性的元素E</td></tr><tr><td>Input:checked {}</td><td>被选中的input</td></tr><tr><td>Input:disable {}</td><td>被禁用的input</td></tr><tr><td>Input:enable {}</td><td>启用的input</td></tr><tr><td>Input:checked {}</td><td>鼠标悬浮时</td></tr><tr><td>#E:target{}</td><td>当前活动的元素，被链接的元素</td></tr><tr><td>:not(E)</td><td>除了元素E以外的所有元素</td></tr></tbody></table><h2 id="CSS声明-样式"><a href="#CSS声明-样式" class="headerlink" title="CSS声明 - 样式"></a>CSS声明 - 样式</h2><h3 id="CSS基本单位与对象"><a href="#CSS基本单位与对象" class="headerlink" title="CSS基本单位与对象"></a>CSS基本单位与对象</h3><ul><li>样式单位：<code>%</code>百分比；<code>in</code>英寸；<code>cm</code>厘米；<code>mm</code>毫米；<code>pt</code>磅；<code>px</code>像素；<code>em</code>字体尺寸；</li><li>颜色常量：对应英文单词表示</li><li>颜色RGB表示：根据rbg值，红蓝绿，各255；十进制表示<code>rgb(255,0,255)</code>、十六进制表示<code>#ff00ff</code>或<code>#f0f</code>、百分比表示<code>rgb(100%,0%,100%)</code></li><li>颜色RGBA表示：同上，多一个透明值，十进制表示<code>rgba(255,0,255,0.5)</code> a∈[0,1]</li><li>颜色HSL表示：根据hsl值，色调 饱和度 亮度；十进制表示<code>hsl(100,0.5,0.5)</code> 分别取值范围是[0,360] [0,1] [0,1]</li><li>颜色HSLA表示：同上上</li></ul><h3 id="文本格式化"><a href="#文本格式化" class="headerlink" title="文本格式化"></a>文本格式化</h3><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>text-align</td><td>center/left/right<br>justify/inherit</td><td>水平对齐方式，后两个效果为两段对齐、继承父元素的属性值</td></tr><tr><td>text-decoration</td><td>none/underline/overline<br>line-through/blink/inherit</td><td>文本的装饰效果：没有，文本上下中的一条线，闪烁的文本，继承父元素的属性值</td></tr><tr><td>color</td><td>对应颜色值</td><td>文本颜色</td></tr><tr><td>text-shadow</td><td>[color][length][lenth][opacity]</td><td>颜色，水平off，垂直off，模糊效果；后三者单位常用px</td></tr><tr><td>line-height</td><td>normal/百分比/value</td><td>定义行高</td></tr><tr><td>font-size</td><td>absolute-size/relative-size<br>相对父元素百分比</td><td>设置字体大小</td></tr><tr><td>font-weight</td><td>normal/bold/value</td><td>定义字体粗体</td></tr><tr><td>font-style</td><td>normal/italic/oblique</td><td>定义字体倾斜，正常，倾斜，倾斜的字体(无斜体变量特殊字体使用)</td></tr><tr><td>font-family</td><td>字体名称1，字体名,2…</td><td>设置字体名称，可以写多个字体，从第一个匹配，如果系统没有改字体，向下寻找</td></tr><tr><td>font</td><td>[size] [family]</td><td>简易书写方式</td></tr><tr><td>Letter-spacing</td><td></td><td>设置中文字间距</td></tr><tr><td>word-spacing</td><td></td><td>设置单词词间距</td></tr><tr><td>Text-transform:uppercase</td><td></td><td>转换大小写lowercase,首字母大写capitalize</td></tr><tr><td>Text-shadow</td><td>length length len color</td><td>设置文字阴影 x偏移量 y偏移量 模糊度 颜色</td></tr><tr><td>White-space</td><td></td><td>空白处理方式 pre空白保留,nowrap不会换行，pre-wrap保留空白会换行,pre-line合并空白会换行</td></tr><tr><td>Direction</td><td></td><td>ltr左对齐，rtl右对齐</td></tr><tr><td>Word-wrap</td><td></td><td>break-word当某行单词超过宽度，将自己分割</td></tr><tr><td>Word-break</td><td></td><td>break-all当某单词太长，将自己分割</td></tr><tr><td>Text-stroke</td><td>length color</td><td>字体描边-宽度 颜色</td></tr><tr><td>Text-fill-color</td><td></td><td>填充颜色</td></tr><tr><td>Text-overflow</td><td></td><td>当内容被裁减的解决方式，cllixi显示省略号……</td></tr></tbody></table><h3 id="背景色-图background"><a href="#背景色-图background" class="headerlink" title="背景色/图background"></a>背景色/图background</h3><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>background-color</td><td>表示颜色的表达式</td><td>设置背景颜色</td></tr><tr><td>background-image</td><td>url(“路径”)</td><td>设置背景图片</td></tr><tr><td>background-size</td><td>width值 height值</td><td>设置背景图片大小</td></tr><tr><td>background-repeat</td><td>(repeat)默认 / no-repeat<br>repeat-x / repeat-y</td><td>设置背景图片是否可重复</td></tr><tr><td>background-position</td><td>两种方式如下</td><td>设置背景图片显示位置</td></tr><tr><td>background-attachment</td><td>scroll/fixed</td><td>scroll(默认):背景会随文档滚动<br>fixed:背景图像固定，并不会随着页面的其余部分滚动，常用实现称为水印的图像</td></tr></tbody></table><ul><li>背景图片位置取值：<ol><li>位置值：left、center、right、top、bottom</li><li>分量值：水平位置 垂直位置；这里的位置可以使用百分比，也可使用绝对值</li></ol></li></ul><h3 id="显示方式display"><a href="#显示方式display" class="headerlink" title="显示方式display"></a>显示方式display</h3><ul><li>元素都有自己的默认的显示方式：<ul><li>块元素(block)：可设置宽高，独占一行，如：h1、p、div 等</li><li>行内元素(inline)：不可设置宽高，共享一行，如：span、a 等(模型盒特殊)</li><li>行内块(inline-block)：可设置宽高，共享一行，如：input、img 等</li></ul></li><li>属性值display：可用于更改显示方式，取值为 none 、 block 、 inline 、 inline-block</li><li>分别对应，不显示该元素、块元素、行内元素、行内块</li></ul><h2 id="CSS声明-模型盒"><a href="#CSS声明-模型盒" class="headerlink" title="CSS声明 - 模型盒"></a>CSS声明 - 模型盒</h2><h3 id="模型盒概念"><a href="#模型盒概念" class="headerlink" title="模型盒概念"></a>模型盒概念</h3><ul><li>CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式</li><li>其中他们的排列顺序是：宽高&gt;内边距(padding)&gt;边框(border)&gt;外边距(margin)</li><li>注意行内元素：<ul><li>margin在水平方向有效，垂直方向无效</li><li>padding在水平方向有效，垂直方向可以有视觉效果，但是不影响其他元素，不会撑开盒子</li><li>高度height和宽度width的设置是无效的，高度可用line-height设置</li></ul></li><li>特别的：img元素的padding、margin是有效的</li></ul><h3 id="边框border"><a href="#边框border" class="headerlink" title="边框border"></a>边框border</h3><ul><li>border属性：用来设置元素的边框</li><li>语法：<code>border值: width值 style值 color值</code><ul><li>border值：border四边设置、border-left左边设置、border-right右边设置、border-top顶边设置、border-bottom底边设置</li><li>width值：根据样式单位进行设置，常用px像素值表示，也可用none</li><li>style值：none/hidden定义无边框 solid实线 dotted点状边框dashed虚线 double双线</li><li>color值：根据上述颜色设置方式赋值</li></ul></li><li>border-radius属性：用来设置边框圆角，数值越大，曲度越大，单位px</li></ul><h3 id="内边距padding"><a href="#内边距padding" class="headerlink" title="内边距padding"></a>内边距padding</h3><ul><li>高度与宽度外侧还有多个属性</li><li>设置属性内边距：<ul><li>padding 简写属性：作用是在一个声明中设置元素的所内边距属性</li><li>padding-bottom：设置元素的下内边距</li><li>padding-left：设置元素的左内边距</li><li>padding-right：设置元素的右内边距</li><li>padding-top：设置元素的上内边距</li></ul></li><li>简写方式中：一个值为四周，两个值分别为上下、右左，三个值分别表示上、右左、下，四个值分别为上右下左顺时针赋值</li><li>值赋值为auto：表示水平居中长度</li><li>模型盒溢出属性：overflow  overflow-x  overflow-y Visible<ul><li>overflow对应值：Visible 默认值不裁剪；hidden 裁剪；scroll 直接加滚动条；auto 自动判断是否滚动条</li></ul></li><li><font color="red">添加内边距会影响元素的宽高</font></li></ul><h3 id="外边距margin"><a href="#外边距margin" class="headerlink" title="外边距margin"></a>外边距margin</h3><ul><li>高度与宽度外侧还有多个属性</li><li>设置属性外边距：<ul><li>margin 简写属性：在一个声明中设置所有外边距属性</li><li>margin-bottom：设置元素的下外边距</li><li>margin-left：设置元素的左外边距</li><li>margin-right：设置元素的右外边距</li><li>margin-top：设置元素的上外边距</li></ul></li><li>简写方式中：一个值为四周，两个值分别为上下、右左，三个值分别表示上、右左、下，四个值分别为上右下左顺时针赋值</li><li>值赋值为auto：表示水平居中长度</li><li>模型盒溢出属性：overflow  overflow-x  overflow-y Visible<ul><li>overflow对应值：Visible 默认值不裁剪；hidden 裁剪；scroll 直接加滚动条；auto 自动判断是否滚动条</li></ul></li><li><font color="red">div套div，内层div的margin-top会无法识别</font>，解决方案：让父元素生成一个块级格式化范围（BFC） 一个BFC是一个HTML盒子并且至少<strong>满足下列条件中的任何一个</strong>：<ol><li>float的值不为none</li><li>position的值不为static或者relative</li><li>display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个</li><li>overflow的值不为visible</li></ol></li><li>我们常用，使父元素添加属性<code>overflow:hidden;</code></li></ul><h2 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h2><h3 id="position静态定位-文档流定位"><a href="#position静态定位-文档流定位" class="headerlink" title="position静态定位(文档流定位)"></a>position静态定位(文档流定位)</h3><ul><li>元素默认的定位方式，特点：块级元素从上到下排列，行内元素从左到右排序</li><li>其通过外边距控制元素所在位置</li><li>格式：position:static</li></ul><h3 id="position相对定位"><a href="#position相对定位" class="headerlink" title="position相对定位"></a>position相对定位</h3><ul><li>特点：元素不脱离文档流(元素移动位置，原来文档流中的位置保留，新位置不影响其他元素)</li><li>通过使用 left属性、right属性、top属性、bottom属性 相对于原元素初始位置做偏移</li><li>格式：position:relative</li><li>唯一一个不脱离文档流的定位方式</li></ul><h3 id="position绝对定位"><a href="#position绝对定位" class="headerlink" title="position绝对定位"></a>position绝对定位</h3><ul><li>特点：元素脱离文档流</li><li>通过  left属性、right属性、top属性、bottom属性 相对于 <strong>窗口</strong>或<strong>非默认(static)定位的上级元素</strong> 做偏移</li><li>格式：position:absolute</li></ul><h3 id="position固定定位"><a href="#position固定定位" class="headerlink" title="position固定定位"></a>position固定定位</h3><ul><li>特点：元素脱离文档流，固定在相对位置，不随文档滚动而移动位置</li><li>通过  left属性、right属性、top属性、bottom属性 相对于 <strong>窗口</strong>做偏移</li><li>格式：position:fixed</li></ul><h3 id="浮动定位"><a href="#浮动定位" class="headerlink" title="浮动定位"></a>浮动定位</h3><ul><li>特点：元素脱离文档流</li><li>通过属性设定，使元素从所在行位置，向左或向右浮动，当撞到上级元素边框或其他浮动元素时为止</li><li>特殊的：如果当行浮动元素宽度超过上级元素边框，则他会自动换行，换行规则是，先下移，再水平移，所以会出现一种情况：前者高度稍高，会将换行元素卡行</li><li>特殊的：如果元素全部浮动，则上级标签自动识别的高度为0，通过<code>overflow:hidden;</code>解决问题</li><li>格式：float:none/left/right</li><li>属性clear：定义了元素的哪个边不允许出现浮动元素，取值为none、left、right、both</li><li>应用场景：当纵向排列的元素需要横向排列的时候使用，如一行几个div、无序列表导航栏等</li></ul><h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><ul><li>属性z-index：控制元素框出现的重叠顺序，数值越大，表示离用户越近</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Web基础-CSS语言&quot;&gt;&lt;a href=&quot;#Web基础-CSS语言&quot; class=&quot;headerlink&quot; title=&quot;Web基础-CSS语言&quot;&gt;&lt;/a&gt;Web基础-CSS语言&lt;/h1&gt;&lt;h2 id=&quot;CSS基础&quot;&gt;&lt;a href=&quot;#CSS基础&quot; class
      
    
    </summary>
    
    
      <category term="语言编程" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Web基础-HTML语言</title>
    <link href="http://yoursite.com/2019/12/09/Web%E5%9F%BA%E7%A1%80-HTML%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2019/12/09/Web%E5%9F%BA%E7%A1%80-HTML%E8%AF%AD%E8%A8%80/</id>
    <published>2019-12-09T11:50:05.000Z</published>
    <updated>2019-12-09T11:50:20.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web基础-HTML语言"><a href="#Web基础-HTML语言" class="headerlink" title="Web基础-HTML语言"></a>Web基础-HTML语言</h1><h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><h3 id="HTML介绍"><a href="#HTML介绍" class="headerlink" title="HTML介绍"></a>HTML介绍</h3><ul><li>HTML(HyperText Markup Language)：超文本标记语言，一种纯文本类型的语言</li><li>一种特殊的XML文件，以 .html .htm 为后缀</li><li></li><li>由浏览器解释执行，可以嵌套脚本语言编写程序段(JavaScript)</li></ul><h3 id="HTML工作原理"><a href="#HTML工作原理" class="headerlink" title="HTML工作原理"></a>HTML工作原理</h3><ul><li>HTML是部署在服务器上的文本文件</li><li>根据HTTP协议，浏览器发出请求给服务器，服务器给出响应，给浏览器返回一个HTML</li><li>浏览器解释执行HTML，从而显示出内容</li><li><strong>HTML部署在服务器上，运行在浏览器上</strong></li></ul><h2 id="HTML语法"><a href="#HTML语法" class="headerlink" title="HTML语法"></a>HTML语法</h2><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><ul><li>HTML标记通常也称为HTML标签(HTML tag)</li><li>由于HTML是XML的一种扩展，所以基本的，标签要有闭合</li><li>特殊的，HTML也有对XML的一些扩展，个别标签允许没有闭合，如：meta input img等</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>由于HTML是XML的一种扩展，所以HTML的注释语法与XML的注释语法相同</li><li>语法：<code>&lt;!--注释的内容--&gt;</code></li><li>通过以上语法进行编辑注释</li></ul><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul><li>文档声明，告诉浏览器使用哪个版本的HTML标准进行解析</li><li><code>&lt;!DOCTYPE html&gt;</code>表示使用HTML5标准进行解析</li><li>文档声明常写在HTML文件中的第一行</li><li><code>&lt;!DOCTYPE&gt;</code>声明不是HTML标签，它为浏览器提供一项信息</li></ul><h2 id="HTML中各种标签"><a href="#HTML中各种标签" class="headerlink" title="HTML中各种标签"></a>HTML中各种标签</h2><h3 id="结构标签"><a href="#结构标签" class="headerlink" title="结构标签"></a>结构标签</h3><ul><li><code>&lt;html&gt;</code> 根标签，是HTML文档中最外层的跟标签</li><li><code>&lt;head&gt;</code> 头标签，是所有头部元素的容器<ul><li>头标签提示浏览器在何处可以找到样式表，包含的脚本，等等</li><li>头标签下常用子标签：<code>&lt;title&gt; &lt;meta&gt; &lt;link&gt; &lt;style&gt; &lt;script&gt;</code></li></ul></li><li><code>&lt;body&gt;</code> 体标签，定义文档的主体，默认距离四个边框留白8个像素</li></ul><h3 id="head标签子标签"><a href="#head标签子标签" class="headerlink" title="head标签子标签"></a>head标签子标签</h3><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td>title</td><td>定义在标签内，表明浏览器工具栏中的标题</td></tr><tr><td>meta</td><td>提供关于HTML文档的元数据，元数据不会显示在页面上，是对机器可读的<br>常用属性有<code>content</code>、<code>http-equiv</code>、<code>charset</code>其中charset字符集最常用</td></tr><tr><td>link</td><td>定义文档与外部资源的关系，最常见的用途是链接样式表<br>常用属性<code>href</code>表示被链接文档位置；<code>type</code>规定被链接文档的MIME_type</td></tr><tr><td>style</td><td>用于为HTML文档定义样式信息，<code>type</code>属性是必需的，定义style元素的内容。唯一可能的值是 “text/css”</td></tr><tr><td>script</td><td>用于定义客户端脚本，<code>type</code>属性是必需的，定义style元素的内容。唯一可能的值是 “text/css”<br>其既可以包含脚本语句，也可以使用外部脚本文件，使用属性<code>src</code>指向文件位置；</td></tr></tbody></table><h3 id="块行标签"><a href="#块行标签" class="headerlink" title="块行标签"></a>块行标签</h3><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td><strong>h1</strong></td><td>标题标签 独占一行，自带上下间距</td></tr><tr><td><strong>div</strong></td><td>块分区标签 独占一行 常一个页面分为三大区</td></tr><tr><td><strong>p</strong></td><td>段落标签 独占一行，自带上下间距</td></tr><tr><td><strong>span</strong></td><td>行内分区标签，设置同一行文字内的不同格式(将文字包裹，属性设置CSS样式)</td></tr><tr><td><strong>a</strong></td><td>超链接标签</td></tr></tbody></table><ul><li><strong>br</strong>：换行标签、<strong>hr</strong>：水平分割线、<strong>b</strong>：加粗标签、<strong>i</strong>：斜体标签、<strong>small</strong>：小字标签 </li><li>通用属性：align 对齐方式，其值为：left、right、center、justify，<strong>不建议使用</strong>，建议用样式取代它</li><li>实体引用：<code>&amp;nbsp;</code>空格、<code>&amp;lt;</code>小于号、<code>&amp;gt;</code>大于号 记忆方法：你不是P 老铁 干他</li><li>HTML5新增块分许标签：header 头部、footer 底部、article 正文、section 区块、nav 导航</li></ul><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td><strong>ul</strong>(unordered list)</td><td>无序列表 列表内每条为li标签</td></tr><tr><td></td><td>常用属性 1.<code>type</code>(每条信息前显示的样式) circle 空心圆/disc 实心圆/square 方框，<strong>不建议使用</strong>，建议用样式取代它</td></tr><tr><td><strong>ol</strong>(ordered list)</td><td>有序列表 列表内每条为li标签</td></tr><tr><td></td><td>常用属性 1.<code>type</code>(每条信息前显示的样式) 1/A/a/I/i 2.<code>start</code>(规定起始值) 3.<code>reversed</code>(设置倒序)</td></tr><tr><td><strong>dl</strong>(definition list)</td><td>定义列表 列表内标题与描述不同如下</td></tr><tr><td>dl内子标签<strong>dt</strong></td><td>在定义列表下，定义一个标题</td></tr><tr><td>dl内子标签<strong>dd</strong></td><td>在定义列表下，定义一个描述</td></tr></tbody></table><h3 id="图片元素img"><a href="#图片元素img" class="headerlink" title="图片元素img"></a>图片元素img</h3><ul><li>语法定义：<code>&lt;img&gt;</code>无闭合，支持图片格式 jpg jpeg png gif</li><li>属性<code>alt</code>：规定代替该资源的文本，当图片不能正常显示的时候文字代替</li><li>属性<code>title</code>：设定鼠标停留时显示的提示文本</li><li>常用属性<code>width height</code>：规定资源宽度、高度，可以使用<strong>像素</strong>或<strong>上级标签量的百分比</strong>表示，如”50%”，表示是上级标签长度的一般像素</li><li>必须属性<code>src</code>：规定资源路径，有两种方式：相对路径、绝对路径<ul><li>相对路径：相对于同级目录可以直接写资源名，相对于上级目录使用<code>../资源名</code>，相对于下级目录使用<code>目录名/资源名</code></li><li>绝对路径：一般访问站外资源使用，直接填入网址即可，可以节省本站资源但有找不到图片风险</li></ul></li></ul><h3 id="超链接a"><a href="#超链接a" class="headerlink" title="超链接a"></a>超链接a</h3><ul><li>语法定义：<code>&lt;a&gt;</code>正常闭合，如果设置了href属性，未访问为蓝色，访问过为紫色，带有下划线的连接为红色；否则没有默认颜色(黑色)</li><li>属性<code>href</code>(hypertext reference)：同样两种方式表示，可以表示站内或站外网站、本网页锚点、内外站资源等</li><li>属性<code>target</code>：规定在何处打开 action URL，其值：_blank/_self/_parent/_top/framename/#id(锚点)</li><li>a标签的锚点使用方式：设置锚点 <code>&lt;a name=&quot;anchorname&quot;&gt;锚点&lt;/&gt;</code>；使用锚点 <code>&lt;a href=&quot;#anchorname&quot;&gt;&lt;/a&gt;</code></li></ul><h3 id="表格table"><a href="#表格table" class="headerlink" title="表格table"></a>表格table</h3><ul><li>语法定义：<code>&lt;table&gt;</code>正常闭合，内部使用<code>&lt;caption&gt;</code>表示标题，<code>&lt;th&gt;</code>表示表头，<code>&lt;tr&gt;</code>表示一行，<code>&lt;td&gt;</code>表示一列</li><li>属性<code>border</code>：规定表格(外)边框的宽度，注意会有内格边框和外表边框间距，使用以下属性设置</li><li>属性<code>cellspacing</code>：规定单元格之间的间距，设置为0则没有边距</li><li>标签<code>&lt;td&gt;</code>属性<code>colspan</code>：规定单元格可横跨的列数</li><li>标签<code>&lt;td&gt;</code>属性<code>rowspan</code>：规定单元格可横跨的行数</li><li>标签<code>&lt;td&gt;</code>属性<code>nowrap</code>：规定单元格中的内容是否折行，<strong>不建议使用</strong>，建议用样式取代它</li></ul><h3 id="表单form"><a href="#表单form" class="headerlink" title="表单form"></a>表单form</h3><ul><li>语法定义：<code>&lt;form&gt;</code>正常闭合，获取用户输入的各种信息，提交到服务器</li><li>表单能够包含 input 元素，比如文本字段、复选框、单选框、提交按钮等等</li><li>表单还可以包含 menus、textarea、fieldset、legend 和 label 元素</li><li>属性<code>action</code>：规定当提交表单时向何处发送表单数据</li><li>属性<code>method</code>：规定用于发送 form-data 的 HTTP 方法(get/post)</li></ul><h3 id="输入控件input"><a href="#输入控件input" class="headerlink" title="输入控件input"></a>输入控件input</h3><ul><li>语法定义：<code>&lt;input&gt;</code>无闭合，通过其 type 属性设置其功能</li></ul><table><thead><tr><th>属性</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>必须<code>type</code></td><td>多种</td><td><code>button</code>按钮 <code>checkbox</code>多选框 <code>file</code>选择文件 <code>hidden</code>隐藏域 <code>image</code>图片按钮 <code>password</code>密码框 <code>radio</code>单选框 <code>reset</code>重置表单 <code>submit</code>执行表单 <code>text</code>输入框 <code>date</code>日期选择器</td></tr><tr><td><code>name</code></td><td>String</td><td>定义 input 元素的名称，提交表单时，是提交数据=左侧key值。在单选多选框中，name相同的控件为一组</td></tr><tr><td><code>value</code></td><td>String</td><td>规定 input 元素的值，提交表单时，是提交数据=右侧value值。常用做输入框的默认值 或 单选多选框的提交值</td></tr><tr><td><code>placeholder</code></td><td>Stirng</td><td>规定帮助用户填写输入字段的提示</td></tr><tr><td><code>id</code></td><td>String</td><td>规定该控件的id名称，有时用于lable标签的for属性指向该id</td></tr><tr><td><code>autocomplete</code></td><td>on(默认)/off</td><td>浏览器是否记录本次输入信息</td></tr><tr><td><code>checked</code></td><td>不写/“checked”</td><td>规定此 input 元素首次加载时应当被选中</td></tr><tr><td><code>accept</code></td><td>mime_type值</td><td>规定通过文件上传来提交的文件的类型。常用做上传文件</td></tr><tr><td><code>multiple</code></td><td>不写/“multiple”</td><td>如果使用该属性，则允许一个以上的值。常用做上传文件</td></tr></tbody></table><h3 id="下拉控件select"><a href="#下拉控件select" class="headerlink" title="下拉控件select"></a>下拉控件select</h3><ul><li>语法定义：<code>&lt;select&gt;</code>正常闭合，内部标签<code>&lt;option&gt;</code>添加下拉菜单</li><li>常用属性<code>name</code>，子标签<code>&lt;option&gt;</code>常用属性<code>&lt;value&gt;</code>表示选中的值，如果不写则默认标签内部值</li></ul><h2 id="HTML各种标签2"><a href="#HTML各种标签2" class="headerlink" title="HTML各种标签2"></a>HTML各种标签2</h2><ul><li><p>datalist标签：文本框下三角候选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;&quot; list=&quot;mydatalist&quot;&gt;</span><br><span class="line">&lt;datalist id=&quot;mydatalist&quot;&gt;</span><br><span class="line">&lt;option&gt;&lt;/option&gt;</span><br><span class="line">&lt;option&gt;&lt;/option&gt;</span><br><span class="line">&lt;option&gt;&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure></li><li><p>label标签：for=”ID”绑定到某的标签</p><ul><li>label也可以输入属性</li></ul></li><li><p>textarea标签：多行显示文本</p></li><li><p>output标签：JS可以设置其值</p></li><li><p>progress标签：进度条</p></li><li><p>meter标签：度量条</p></li><li><p>fieldset元素：类似控件组框 ，legend元素设定其标题</p></li><li><p>Keygen元素：建立一个密钥生成器</p></li><li><p>details元素：将闭合标签内容合在一起，open元素可以默认打开。summary元素给其添加标题</p></li><li><p>video元素，audio元素，source元素为子元素，解决兼容问题。</p></li><li><p>embed元素：嵌入对象比如flash—object也是嵌入对象</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Web基础-HTML语言&quot;&gt;&lt;a href=&quot;#Web基础-HTML语言&quot; class=&quot;headerlink&quot; title=&quot;Web基础-HTML语言&quot;&gt;&lt;/a&gt;Web基础-HTML语言&lt;/h1&gt;&lt;h2 id=&quot;HTML简介&quot;&gt;&lt;a href=&quot;#HTML简介&quot;
      
    
    </summary>
    
    
      <category term="语言编程" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Java基础-JavaSE(下)</title>
    <link href="http://yoursite.com/2019/12/09/Java%E5%9F%BA%E7%A1%80-JavaSE(%E4%B8%8B)/"/>
    <id>http://yoursite.com/2019/12/09/Java%E5%9F%BA%E7%A1%80-JavaSE(%E4%B8%8B)/</id>
    <published>2019-12-09T11:48:04.000Z</published>
    <updated>2019-12-09T11:48:45.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础-JavaSE-下"><a href="#Java基础-JavaSE-下" class="headerlink" title="Java基础-JavaSE(下)"></a>Java基础-JavaSE(下)</h1><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><ul><li>主线程：JVM启动主线程,主线程运行main()方法</li><li>用户线程：开启的新的线程，也称为子线程。子线程默认优先级为父线程优先级</li><li>守护线程：守护线程是为其他线程提供服务的线程，不能独立运行，当JVM中只有守护线程时，守护线程全部结束，JVM退出</li></ul><h3 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h3><ul><li><p>通过继承Thread类，重写run()方法，实例化创建线程</p></li><li><p>通过实现Runnable接口，重写run()方法，实例化Thread时传入Thread的构造函数</p></li><li><p>一般使用以上两种，还有一种如下，但不常用，一般用在线程池</p></li><li><p>通过实现Callable<T>接口，重写call()方法；call()方法相比run()方法有返回值，通过Callable的泛型指定返回值类型</p><ul><li>不可以直接实例化Thread时传入Thread的构造函数，因为自己并不继承Runnable接口</li><li>通过FutureTask<T>类，将自己的实例对象传入到Thread的构造方法中(因为FutureTask<T>类实现了Runnable接口)</li><li>创建时构造函数传入Callable的实现类对象<code>FutureTask&lt;T&gt; task = new FutureTask&lt;&gt;(Callable的实现类对象)</code> 通过调用<code>task.get()</code>方法，获得返回结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;String&gt; callable = new Callable&lt;&gt;()&#123;</span><br><span class="line">    public String call()throws Exception&#123;return &quot;&quot;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">FutureTask&lt;T&gt; task = new FutureTask&lt;&gt;(callable);</span><br><span class="line">Thread t = new Thread(task);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>Runnable接口</code>与<code>Callable&lt;T&gt;接口</code>的区别：1.Callable主要用在线程池；2.在于不同执行体的方法：run()与call(),前者没有返回值且不抛出异常，后者有返回值且抛出异常</p></li></ul><h3 id="java-lang-Thread"><a href="#java-lang-Thread" class="headerlink" title="java.lang.Thread"></a>java.lang.Thread</h3><ul><li>优先级，1-10级，10最高，类中提供3个敞亮表示低高默认</li><li>Thread.MIN_PRIORITY/Thread.MAX_PRIORITY/Thread.NORM_PRIORITY</li><li><code>Thread(ThreadGroup GroupName,Runnable target,String name)</code></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>long getId()</td><td>返回该线程的标识符(标识符是唯一的)</td></tr><tr><td>String getName()</td><td>返回该线程的名称</td></tr><tr><td>int getPriority()</td><td>返回线程的优先级</td></tr><tr><td>void setPriority(int priority)</td><td>设置线程的优先级</td></tr><tr><td>static int activeCount()</td><td>返回当前活动线程的数量</td></tr><tr><td>static Thread currentThread()</td><td>返回当前线程</td></tr><tr><td>Thread.state getState()</td><td>获取当前线程的状态，可以拼接字符串使用</td></tr><tr><td>boolean isAlive()</td><td>新建、死亡返回false；就绪、运行、阻塞返回true</td></tr><tr><td>boolean isDaemon()</td><td>测试线程是否为守护线程</td></tr><tr><td>static void sleep(long millis)</td><td>静态方法，线程休眠，有中断异常会被interrupt()方法中断</td></tr><tr><td>void interrupt()</td><td>中断线程，中断处于睡眠/等待中的线程</td></tr><tr><td>static boolean interrupt()</td><td>测试线程是否被中断</td></tr><tr><td>boolean isInterrupted()</td><td>测试线程是否已经被中断</td></tr><tr><td>void setDaemon(boolean b)</td><td>将调用该方法的线程设置为守护进程，只能在start()方法之前使用，否则无效</td></tr><tr><td>void join()</td><td>线程加入，等待调用该方法的线程执行完毕后，当前线程再继续执行</td></tr><tr><td>static void yield()</td><td>线程让步，主动让出CPU，当前进程进入就绪状态，重新争取CPU使用权(可能还是它)</td></tr><tr><td>ClassLoader getContextClassLoader()</td><td>返回线程的上下文加载器</td></tr><tr><td>void run()</td><td>线程执行体</td></tr><tr><td>void start()</td><td>开启线程</td></tr><tr><td>void stop()</td><td>终止线程，过时语法，不建议使用</td></tr></tbody></table><ul><li>wait([long timeout])、notify()、notifyAll()方法是Object类的方法，他们需要在同步代码块中，通过锁对象调用</li><li>如果调用wait()包含超时时间的方法，则时间过后会抛出超时异常</li><li>Thread.state：枚举定义的数据类型，包含：NEW、RUNNABLE、BLOCKED、WAITTING、TIMED_WATTING、TERMINATED</li><li>BLOCKED：等待锁对象时的状态。WAITTING：wait和join方法没有超时时。TIMED_WATTING：sleep方法或wait和join方法超时时</li></ul><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><ul><li>Java线程的生命周期存在：创建（<strong>New</strong>）、就绪（<strong>Runnable</strong>）、运行（<strong>Running</strong>）、阻塞（<strong>Blocked</strong>）和死亡（<strong>Terminated</strong>）五种状态</li><li>新建–&gt;就绪&lt;–&gt;运行–&gt;死亡</li><li>就绪&lt;–阻塞&lt;–运行</li></ul><h4 id="新建状态New"><a href="#新建状态New" class="headerlink" title="新建状态New"></a>新建状态New</h4><ul><li>使用new关键字新建一个线程后，处于新建状态，仅仅分配了内存，线程对象不会表现出任何线程的动态特征</li><li>新建状态的线程不可以重复调用start()方法，否则报错IllegalThreadStateException</li></ul><h4 id="就绪状态Runnable"><a href="#就绪状态Runnable" class="headerlink" title="就绪状态Runnable"></a>就绪状态Runnable</h4><ul><li>当对象调用了start()方法后，线程进入就绪状态，等待线程调度</li><li>注意：start()只表明线程准备完毕，并不一定立即执行</li></ul><h4 id="运行状态Running"><a href="#运行状态Running" class="headerlink" title="运行状态Running"></a>运行状态Running</h4><ul><li>当就绪状态线程获取到了CPU后进入运行状态</li><li>运行状态会执行run()方法，执行run()方法内的代码块</li></ul><h4 id="阻塞状态Blocked"><a href="#阻塞状态Blocked" class="headerlink" title="阻塞状态Blocked"></a>阻塞状态Blocked</h4><ul><li>线程调用sleep()方法、join()方法，使线程进入等待状态(等待时间/线程执行完毕)</li><li>调用wait()方法使对象进入等待池(释放锁对象)，当调用notify()方法、notifyAll()方法，线程进入等待锁对象池</li><li>线程试图获得一个同步监视器，但该监视器被其他线程持有，线程进入等待同步锁对象池，进入阻塞状态(BLOCKED)</li><li>线程调用了一个阻塞式IO方法，在该方法返回以前，该线程被阻塞</li><li>线程调用suspend()方法将该线程挂起。但这个方法容易导致死锁，不建议使用。后期使用resume()方法可以恢复</li></ul><h4 id="死亡状态Terminated"><a href="#死亡状态Terminated" class="headerlink" title="死亡状态Terminated"></a>死亡状态Terminated</h4><ul><li>run()/call()方法执行完成，线程正常结束</li><li>线程抛出一个未捕获的Exception或Error</li><li>直接调用线程的stop()方法结束该线程——该方法容易导致死锁，通常不建议使用</li><li>死亡状态的线程不可以再调用start()方法，否则报错IllegalThreadStateException</li></ul><h3 id="线程同步锁"><a href="#线程同步锁" class="headerlink" title="线程同步锁"></a>线程同步锁</h3><ul><li>多个线程同时访问修改：栈区(实例变量)、方法区(静态变量)</li><li>使用关键字<code>synchronized</code>实现同步</li><li>同步代码块：<code>synchronized(同步监视器对象) {需要多线程同步执行的代码片段}</code></li><li>同步方法：synchronized作为修饰词修饰方法，默认同步监视器对象为this</li><li>同步监视器常使用常量作为锁对象，有时使用this或当前类对象作为锁对象</li><li>同步监视器为this时，同步为对象同步，但是静态方法上的synchronized是类同步(监视器对象为该类的类对象)</li><li>注意:静态方法中的同步代码块指定的同步监视器对象不能用this，一般使用Boo.class</li></ul><h3 id="Timer计时器类"><a href="#Timer计时器类" class="headerlink" title="Timer计时器类"></a>Timer计时器类</h3><ul><li>构造方法：无参构造 或 传入布尔值构造，布尔为true时设置定时器为守护线程</li><li>方法：<code>timer.schedule(task,time)</code> 在指定的时间time实行任务task</li><li>方法：<code>timer.schedule(task,delay)</code> 延迟dalay毫秒后，执行任务task</li><li>方法：<code>timer.schedule(task,firstTime,period)</code> 指定task任务第一次执行的时间，以后每间隔period执行一次task</li></ul><h2 id="线程池技术"><a href="#线程池技术" class="headerlink" title="线程池技术"></a>线程池技术</h2><h3 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h3><ul><li>线程在Java中是一个对象，每一个Java线程都需要一个操作系统线程支持</li><li>线程创建、销毁需要时间，如果 创建时间+销毁时间&gt;执行任务时间 就很不合算</li><li>系统调度频繁切换上下文，过多线程的调度影响性能，所以要使用线程池技术</li><li>线程池常用在tomcat、dubbo、spring等</li></ul><h3 id="线程池相关类与接口"><a href="#线程池相关类与接口" class="headerlink" title="线程池相关类与接口"></a>线程池相关类与接口</h3><ul><li>java.util.concurrent.Executors（类）:是线程池的一个工具类，常用<code>static ExecutorService newFixedThreadPool(int nThreads)</code>创建固定最大数量的线程池</li><li>java.util.concurrent.Executor（接口）：是线程池的顶级接口，内部只有一个抽象方法 <code>void execute(Runnable command)</code></li><li>java.util.concurrent.ExecutorService（接口）：继承上面这个接口</li><li>java.util.concurrent.ThreadPoolExecutor（类）：实现了以上两个接口，构造方法 corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue</li></ul><h3 id="ThreadPoolExecutor构造含义"><a href="#ThreadPoolExecutor构造含义" class="headerlink" title="ThreadPoolExecutor构造含义"></a>ThreadPoolExecutor构造含义</h3><ul><li>java.util.concurrent.ThreadPoolExecutor（类）：构造方法 corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue</li><li>例：<code>ThreadPoolExecutor pool = new ThreadPoolExecutor(5, 10, 3, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(10));</code></li><li>建立了一个线程池，其中：核心线程数5 最大线程数10 线程存活时间3 存活时间单位second 任务队列最大长度为10</li><li>使用其重写Executor接口的<code>void execute(Runnable command)</code>方法，向任务队列中添加任务</li></ul><h4 id="其运行过程"><a href="#其运行过程" class="headerlink" title="其运行过程"></a>其运行过程</h4><ul><li>当任务队列数量没有达到队列最大值时，最多运行的线程数为5</li><li>当任务队列数量达到队列最大值时，此时开始启用临时线程，但控制所有线程数量最多为10<ul><li>当临时线程没有任务时，存活3s，销毁掉临时线程，核心线程一直存在</li></ul></li><li>特殊的：如果任务投入超过队列最大长度，且此时线程总数已经达到了最大线程数，则再进入的任务，线程池拒绝服务(抛出异常)</li><li>比如这个例子中：execute 10个任务，会启用5个线程；execute 20个任务，会启用10个线程；execute 超过20个任务，则从第21个任务开始决绝服务</li></ul><h3 id="ThreadPoolExecutor内部原理剖析"><a href="#ThreadPoolExecutor内部原理剖析" class="headerlink" title="ThreadPoolExecutor内部原理剖析"></a>ThreadPoolExecutor内部原理剖析</h3><ul><li>内部类worker继承Thread来创建线程</li><li>worker内部的线程任务，通过不停的调用自身<code>run()</code>方法进行循环</li><li>循环过程中通过绝对线程安全Queue队列的<code>take()</code>阻塞方法，等待取出任务 new 自己 进行执行该任务</li><li><code>execute()</code>方法中含有判断队列，线程数等方法，new worker 或者 向队列插入 task任务</li></ul><h2 id="集合Collection"><a href="#集合Collection" class="headerlink" title="集合Collection"></a>集合Collection</h2><ul><li>JDK1.5新增特性For each，泛型都是编译器认可，源码中foreach还是迭代器，泛型还是会造型操作</li><li>泛型只能使用引用数据类型，如果是基本数据类型使用包装类</li><li>Arrays类中 static List asList()方法，将数组作为List操作，所以：<ul><li>集合只能引用数据类型，不能使用基本数据类型（byte,short,int,long,float,double,boolean）</li><li>因为是将数组作为List操作，该方法将数组与列表连接起来，Map或Array操作他们其中之一时，相当于也在操作另一个(数据相通)</li><li>又因为数组是定长的，所以List不支持add和remove方法</li></ul></li></ul><h3 id="java-util-Collection"><a href="#java-util-Collection" class="headerlink" title="java.util.Collection"></a>java.util.Collection</h3><ul><li>Colletion接口实现Iterator接口，下面有两个常用的子接口：java.util.List、java.util.Set</li><li>Collection是集合框架顶级接口，里面定义了所有集合都应当具备的相关操作方法</li><li>构造方法中可以直接传入一个Collection,将传入的集合的元素传入新建的集合中</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>向集合添加给定元素，成功返回true</td></tr><tr><td>int size()</td><td>返回当前集合的元素个数</td></tr><tr><td>boolean isEmpty()</td><td>是否为空集，当集合不含有任何原属时为空集(并非集合为null)</td></tr><tr><td>void clear()</td><td>清空当前元素</td></tr><tr><td>boolean contains(Object o)</td><td>根据equals查找有没有该元素</td></tr><tr><td>boolean remove(Object o)</td><td>根据equals删除该元素(如果为list只删除第一个)</td></tr><tr><td>boolean addAll(collection c)</td><td>将给定集合中的所有元素添加到当前集合,Set中不会重复</td></tr><tr><td>boolean containsAll(collection c)</td><td>判断当前集合是否包含给定集合中的所有元素</td></tr><tr><td>boolean removeAll(Collection c)</td><td>删除当前集合中与给定集合的共有元素,参数给定的集合元素不受影响</td></tr><tr><td>Iterator iterator()</td><td>该方法返回一个Iterator的实现类，迭代器</td></tr><tr><td>Object[] toArray()</td><td>该方法可以将集合返回数组，注意为对象数组</td></tr><tr><td>T[] toArray(T[] array)</td><td>将元素存入传入的某类型数组中,并返回</td></tr><tr><td></td><td>数组长度不足则toArray方法另外new数组返回，长度超过则会填null</td></tr></tbody></table><h3 id="java-util-Iterator"><a href="#java-util-Iterator" class="headerlink" title="java.util.Iterator"></a>java.util.Iterator</h3><ul><li>java.util.Iterator 接口</li><li>不同的集合实现类都提供了一个迭代器实现类用于遍历自身元素</li><li>迭代器在集合遍历的过程中是不可以通过<strong>集合的方法</strong>增删元素的</li><li>游标概念：用于指向元素的指针，当新建对象的时候，游标恢复默认</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean hasNext()</td><td>判断是否有下一个元素</td></tr><tr><td>E next()</td><td>获取下一个元素</td></tr><tr><td>void remove()</td><td>删除next()方法取出的元素</td></tr></tbody></table><h3 id="java-util-List"><a href="#java-util-List" class="headerlink" title="java.util.List"></a>java.util.List</h3><ul><li>java.util.List 接口：实现Collection接口，线性表。是一组可以放重复元素的集合，特点是有序，可以通过下标操作元素</li><li>常用实现类：ArrayList,Vector,LinkedList</li><li>List中contains()、remove()等方法都要用到equals()方法，重写必须的</li><li>ArrayList,Vector底层都是数组实现的，新建时长度为10，但扩容时前者扩大1.5倍，后者2倍，并且后者是线程安全的</li><li>LinkedList是链表形式，可以当做List，可以当做Queue/Deque，也可以当做栈使用</li><li>性能要求不大，常用ArrayList，线程安全现在常用CopyOnWriteArrayList类</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>E get(int i)</td><td>获取指定下标处对应的元素</td></tr><tr><td>E set(int index,E e)</td><td>将给定的元素设置到指定位置，返回值为原位置对应的元素（替换元素操作）</td></tr><tr><td>void add(int index,E e)</td><td>将给定元素插入到指定位置</td></tr><tr><td>E remove(int index)</td><td>删除并返回给定位置的元素</td></tr><tr><td>List subList(int fromIndex, int toIndex)</td><td>List可以返回指定范围内的子集[的引用],更改后原集合也会改动</td></tr><tr><td>subList()特性</td><td>快速去除中间某段元素，可以使用subList()获取子集后clear()</td></tr></tbody></table><h3 id="java-util-Set"><a href="#java-util-Set" class="headerlink" title="java.util.Set"></a>java.util.Set</h3><ul><li>java.util.Set 接口：实现Collection接口，不可重复集.大部分实现类是无序的，常用类：HashSet</li><li>无序：添加顺序有可能和排列顺序不同</li><li>Set与HashSet并没有其他特殊方法，HashSet的底层其实是HashMap，将值添加到Key中</li></ul><h3 id="java-util-TreeSet"><a href="#java-util-TreeSet" class="headerlink" title="java.util.TreeSet"></a>java.util.TreeSet</h3><ul><li>java.util.TreeSet 类：Set接口&lt;–SortedSet接口&lt;–NavigableSet接口&lt;–TreeSet类</li><li>TreeSet具有元素自然排序的集合，所以在创建时可以添加一个比较器(优先) 或 添加的元素都实现了Comparable接口</li><li>TreeSet的底层其实是TreeMap，将值添加到Key中</li><li>注意：因为Set不可添加相同元素，TreeSet中会根据<font color="red">排序结果</font>是否相同判断是否为相同元素</li></ul><h3 id="java-util-Queue"><a href="#java-util-Queue" class="headerlink" title="java.util.Queue"></a>java.util.Queue</h3><ul><li>java.util.Queue 接口(队列)：实现Collection接口，规定了队列出入队的相关方法，队列储存元素必须遵循先进先出原则，常用类：LinkedList</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean offer()</td><td>入队操作,添加元素的方法</td></tr><tr><td>E poll()</td><td>出队操作,将队首元素移除并返回</td></tr><tr><td>E pick()</td><td>引用队首元素</td></tr></tbody></table><h3 id="java-util-Deque"><a href="#java-util-Deque" class="headerlink" title="java.util.Deque"></a>java.util.Deque</h3><ul><li>java.util.Deque 接口(双端队列)：实现Queue接口，是两段都可以做进出队的队列。常用实现类：LinkedList</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean offerFirst()</td><td>入队操作,从队首添加元素的方法</td></tr><tr><td>boolean offerLast()</td><td>入队操作,从队尾添加元素的方法(等同offer)</td></tr><tr><td>E pollFirst()</td><td>出队操作,将队首元素移除并返回(等同poll)</td></tr><tr><td>E pollLast()</td><td>出队操作,将队尾元素移除并返回</td></tr><tr><td>E pickFirst()</td><td>引用队首元素(等同pick)</td></tr><tr><td>E pickLast()</td><td>引用队尾元素</td></tr><tr><td>如果看做栈</td><td>当做栈来使用的话</td></tr><tr><td>void push()</td><td>入栈操作(等同offerFirst)</td></tr><tr><td>E pop()</td><td>出栈操作(等同poll)</td></tr></tbody></table><h3 id="java-util-Collections"><a href="#java-util-Collections" class="headerlink" title="java.util.Collections"></a>java.util.Collections</h3><ul><li>java.util.Collections 类，是集合框架的工具类</li><li>提供了很多把集合转为线程安全的集合的方法<code>synchronizedXXX(XXX)</code>,但现不常用改用java.until.concurrent包内的线程安全集合，比如：List集合用CopyonWriteArrayList,Set集合用concurrentSkipListSet</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static void sort(List<T> list)</td><td>该方法是用来对List集合进行自然排序的（从小到大<br>排序元素必须实现Comparable接口才可编译通过</td></tr><tr><td>static void sort(List<T> list,Comparator<T> c)</td><td>通过比较器来比较两元素，重写compare方法，返回正负零值代表大小</td></tr></tbody></table><h2 id="集合Map"><a href="#集合Map" class="headerlink" title="集合Map"></a>集合Map</h2><ul><li>查找表Map成对保存数据（key-value对），并且是根据key来获取对用的value，常用Map总实现类：HashMap,TreeMap,LinkedHashMap</li><li><code>Map</code>接口&lt;–<code>ConcurrentMap</code>接口(应用于多线程环境，常用实现类:ConcurrentHashMap)&lt;–<code>ConcurrentNavigableMap</code>接口(具有自然排序功能，其常用实现类:ConcurrentSkipListMap),因为其也实现了<code>NavigableMap</code>接口</li><li><code>Map</code>接口&lt;–<code>SortedMap</code>接口(自然排序功能)&lt;–<code>NavigableMap</code>接口(具有自然排序功能，其常用实现类:TreeMapp)</li><li>不需要根据键排序，一般使用HashMap；需要根据键来排序，一般使用TreeMap</li><li>特别注意自然排序的实例其比较键是否相同是根据比较方法比较后是否为0决定的</li></ul><h3 id="java-util-Map"><a href="#java-util-Map" class="headerlink" title="java.util.Map"></a>java.util.Map</h3><ul><li>java.util.Map 接口，所有查找表的顶级接口，查找表</li><li>常用实现类：<code>HashMap</code>和<code>HashTable</code></li><li>Map没有重复Key元素，如果有重复Key元素，该key对应的value将会被替换</li><li>内部类Entry，具有方法<code>K getKey()</code>、<code>V getValue()</code>、<code>V setValue(V value)</code></li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>V put(K key,V value)</td><td>将给定的key-value对保存到Map中，若key存在返回替换掉的原value,若不重复返回null</td></tr><tr><td>V get(K key)</td><td>根据key获取对应的value，若给定的key在Map中不存在，则返回null</td></tr><tr><td>V remove(Object keyp[,Object value])</td><td>根据给定的key[和value]删除这组键值对，返回为该key对应的value</td></tr><tr><td>V replace(K keyp,V value)</td><td>根据给定的key替换value并返回旧value</td></tr><tr><td>boolean replace(K key,V oldValue,V newValue)</td><td>替换匹配到的&lt;键，值&gt;对</td></tr><tr><td>Set<K> keySet()</td><td>将当前Map中所有的key以一个Set集合形式返回</td></tr><tr><td>Set<Entry> entrySet()</td><td>返回Entry实例，Entry的每一个实例表示当前Map中的一组键值对</td></tr><tr><td>Collection values()</td><td>将当前Map中所有的value以一个集合的形式返回</td></tr><tr><td>boolean containsKey(Object key)</td><td>判断是否包含指定的键</td></tr><tr><td>boolean containsValue(Object value)</td><td>判断是否包含指定的值</td></tr><tr><td>void clear()</td><td>清除所有的&lt;键，值&gt;对</td></tr><tr><td>boolean isEmpty()</td><td>判断是否为空</td></tr><tr><td>int size()</td><td>返回&lt;键，值&gt;对的数量</td></tr></tbody></table><h3 id="java-util-HashMap-HashTable"><a href="#java-util-HashMap-HashTable" class="headerlink" title="java.util.HashMap/HashTable"></a>java.util.HashMap/HashTable</h3><ul><li>java.util.HashMap 类，实现Map接口</li><li>有个常用的子类：java.util.LinkedHashMap，其特点是存储的数据具有顺序性，添加顺序就是存储顺序</li><li>java.util.HashTable 类，实现Map接口</li><li>有个常用的子类：java.util.Properties，其特点是键值对类型都是String,常用作设置/读取属性</li></ul><h4 id="HashMap工作原理"><a href="#HashMap工作原理" class="headerlink" title="HashMap工作原理"></a>HashMap工作原理</h4><ul><li>底层是哈希表(散列表)，哈希就是一个数组，数组的每个元素指向一个单向链表，其储存该单向链表第一个结点的引用</li><li>每个单向链表中有多个结点，每个结点由四部分组成，<code>hash,key,value,next</code>分别是哈希值，键，值，下一个结点的引用</li></ul><h5 id="hashmap-put-“key”-value"><a href="#hashmap-put-“key”-value" class="headerlink" title="hashmap.put(“key”,value)"></a>hashmap.put(“key”,value)</h5><ol><li>根据key的哈希码，即key的hashCode()方法的返回值，计算在数组中的索引值,i=2(如何计算的先不管)</li><li>访问table[i]，如果该元素为null，就会根据&lt;”key”,value&gt;键值对生成一个新的结点，存储到table[i]这个位置</li><li>如果数组中该元素不为null，就会遍历table[i]单向链表中的每个结点<ul><li>当有个结点的键与当前键”key”equals相等，就使用新的值value替换结点原来的value值</li><li>如果遍历完单向链表所有结点都没有匹配的结点，就会创建一个新的结点插入到链表的头部，table[i]储存的引用改为刚刚新结点的引用</li></ul></li></ol><h5 id="hashmap-get-“key”"><a href="#hashmap-get-“key”" class="headerlink" title="hashmap.get(“key”)"></a>hashmap.get(“key”)</h5><ol><li>根据key的哈希码，即key的hashCode()方法的返回值，计算在数组中的索引值,i=2(如何计算的先不管)</li><li>访问table[i]，如果该元素为null，就返null</li><li>如果数组中有table[i]这个元素，则会遍历table[i]中链表的每个结点<ul><li>当有个结点的键与当前键”key”equals相等，就把结点的value值返回</li><li>如果完单向链表中所有结点都没有匹配，就返回null</li></ul></li></ol><h4 id="装载因子HashMap优化"><a href="#装载因子HashMap优化" class="headerlink" title="装载因子HashMap优化"></a>装载因子HashMap优化</h4><ul><li>Capacity：容量，hash表里bucket(桶)的数量，也就是散列数组大小</li><li>Initaial capacity：初始容量，创建hash表时，初始bucket的数量，默认构建容量是16，也可以使用特定数量</li><li>Size：大小，当前散列表中储存数据的数量</li><li>Load factor：加载因子，默认值0.75(就是75%)，当向散列表增加数据时，如果size/capacity的值大于Load factor则发生扩容并重新散列</li><li>性能优化：加载因子较小时，散列查找性能会提高，同时也浪费了散列桶空间容量。0.75时性能和红箭相对平衡的结果。在创建散列表时指定合理容量，减少rehash提高性能</li></ul><h4 id="HashMap与HashTable的对比"><a href="#HashMap与HashTable的对比" class="headerlink" title="HashMap与HashTable的对比"></a>HashMap与HashTable的对比</h4><ol><li>底层都是哈希表(散列表)，HashTable是线程安全的，而HashMap不是线程安全的</li><li>HashMap的父类是AbstractMap，HashTable的父类是Dictionary</li><li>HashMap的默认初始值：16，HashTable的默认初始值：11</li><li>加载因子：0.75，当&lt;键，值&gt;对的数量 大于 数组的容量(哈希桶的容量) * 加载因子时，数组要扩容</li><li>HashMap扩容默认：2倍大小； HashTable扩容：2倍+1</li><li>HashMap的键与值可以为null，HashTable的键与值不能为null</li><li>HashMap在创建时，可以制定一个初始化容量，系统会调整为2的幂次方(比如21会返回32，因为16&lt;21&lt;32)(为了快速计算出数组的下标：2的幂次方减1与hash相与)，HashTable也可以指定初始化容量，系统不调整</li></ol><h3 id="java-util-properties"><a href="#java-util-properties" class="headerlink" title="java.util.properties"></a>java.util.properties</h3><ul><li>java.util.properties 类：是HashTable类的常用子类，特点是键值对类型都是String，其常用作设置/读取属性</li><li>一般单独创建一个资源包(resources)，在该包中添加后缀名为properties配置文件来进行操作，文件中的键值表示为<code>key value/key=value/key:value</code>空格或:或=</li><li>有两个常用方法<code>String getProperties(String key)</code>和<code>Object putProperties(String key, String value)</code>（替换返回旧值，否则null）</li><li>读取配置文件的方法有两种：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = new Properties()//不需要泛型</span><br><span class="line">InputStream inStream = XXX.class.getResourceAsStream(&quot;/XXX&quot;);//XXX是src以下的相对路径</span><br><span class="line">InputStream inStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;XXX&quot;)//注意这个开头没有&quot;/&quot;</span><br><span class="line">//以上第一种常为一般用途，第二种常用在多线程中</span><br><span class="line">properties.load(inStream)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResourceBundle bundle = ResourceBundle.getBundle(&quot;XXX&quot;)</span><br><span class="line">//注意这个开头没有&quot;/&quot;,且不需要写扩展名，但是文件必须是properties类型</span><br><span class="line">//关于&quot;/&quot;写不写的问题，可以试，如果报错找不到文件，那应该就是路径中&quot;/&quot;的问题</span><br></pre></td></tr></table></figure><h3 id="java-util-TreeMap"><a href="#java-util-TreeMap" class="headerlink" title="java.util.TreeMap"></a>java.util.TreeMap</h3><ul><li>TreeMap 类：实现了SortedMap接口，可以根据键自然排序，排序原理是二叉树原理，采用的是中序遍历</li></ul><h2 id="涉及到的专业术语"><a href="#涉及到的专业术语" class="headerlink" title="涉及到的专业术语"></a>涉及到的专业术语</h2><p>这里流连接的操作分别为：</p><ol><li>先将给定对象通过对象流写出，此时对象流会将该对象转换为一组字节这个过程称为<strong>对象序列化</strong></li><li>序列化后的字节再通过文件流写入了文件，即：写入磁盘中，这个过程称为<strong>数据持久化</strong></li><li>签名接口：<code>java.io.Serializable//java.lang.Cloneable</code>编译器敏感，编译器发现时，自动添加功能方法，从而完成功能</li><li>侵入性：当我们使用某个API时，他要求我们为其修改其他额外代码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java基础-JavaSE-下&quot;&gt;&lt;a href=&quot;#Java基础-JavaSE-下&quot; class=&quot;headerlink&quot; title=&quot;Java基础-JavaSE(下)&quot;&gt;&lt;/a&gt;Java基础-JavaSE(下)&lt;/h1&gt;&lt;h2 id=&quot;多线程基础&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="语言编程" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础-JavaSE(上)</title>
    <link href="http://yoursite.com/2019/12/09/Java%E5%9F%BA%E7%A1%80-JavaSE(%E4%B8%8A)/"/>
    <id>http://yoursite.com/2019/12/09/Java%E5%9F%BA%E7%A1%80-JavaSE(%E4%B8%8A)/</id>
    <published>2019-12-09T11:47:03.000Z</published>
    <updated>2019-12-09T11:48:09.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础-JavaSE-上"><a href="#Java基础-JavaSE-上" class="headerlink" title="Java基础-JavaSE(上)"></a>Java基础-JavaSE(上)</h1><h2 id="JavaSE基础"><a href="#JavaSE基础" class="headerlink" title="JavaSE基础"></a>JavaSE基础</h2><h3 id="Java包结构"><a href="#Java包结构" class="headerlink" title="Java包结构"></a>Java包结构</h3><table><thead><tr><th>包名</th><th>功能</th></tr></thead><tbody><tr><td>java.lang</td><td>最基础的类JVM默认导入可以直接使用的</td></tr><tr><td>java.util</td><td>常用工具，如集合、随机数、日历、时钟等</td></tr><tr><td>java.io</td><td>文件操作、输入/输出操作</td></tr><tr><td>java.net</td><td>网络操作</td></tr><tr><td>java.math</td><td>数学运算相关操作</td></tr><tr><td>java.security</td><td>安全相关操作</td></tr><tr><td>java.sql</td><td>数据库访问</td></tr><tr><td>java.text</td><td>处理文字、日期、数字、信息的格式</td></tr></tbody></table><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>使用<code>/** */</code>进行标注</p><table><thead><tr><th>常用</th><th>说明</th></tr></thead><tbody><tr><td>@author</td><td>作者，一般英文名</td></tr><tr><td>@since</td><td>始于某JDK开发环境</td></tr><tr><td>@version</td><td>版本号，如1.0</td></tr><tr><td>@see</td><td>与某些类有关系，建议查看类，如java.lang.String</td></tr><tr><td>@param</td><td>用于说明传入的参数信息</td></tr><tr><td>@return</td><td>用于说明返回值</td></tr></tbody></table><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><ul><li>被final修饰，不能被继承</li><li>内部储存的是char数组-char[]</li><li>储存的对象不可更改-final<blockquote><p>源代码<code>private final char value[]</code></p></blockquote></li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>Java推荐我们使用字面量形式创建字符串对象，因为只有使用字面量创建时才会检查要不要被重用</li><li>new String()创建对象时一定会新生成一个对象，而且字符串对象在改变时(计算)时一定会创建新的字符串对象(就算值相同，就算在创建时，都不会重用)</li><li>编译器：在编译期会计算好能确定一个计算表达式结果的值，并将结果编译到class文件中，不会影响执行性能，如<code>String s=&quot;123&quot;+&quot;abc&quot;</code>编译到class是<code>String s=&quot;123abc&quot;</code></li><li>一定注意char与int的加减再与String拼接问题（注意单双引号），如：<code>&#39;a&#39;+1+&quot;b&quot; : 98b</code></li></ol><h3 id="java-lang-String"><a href="#java-lang-String" class="headerlink" title="java.lang.String"></a>java.lang.String</h3><ul><li>构造方法：<code>String 名 = &quot;xx&quot;</code></li><li>构造方法：<code>String 名 = new String(String str)</code></li><li>构造方法：<code>String 名 = new String(Byte data[,int start,int length][,String cs])</code>默认/cs指定字符集将字节数组转为String</li></ul><table><thead><tr><th>String类的API名称</th><th>说明</th></tr></thead><tbody><tr><td>int length()</td><td>获取当前字符串长度(字符个数)</td></tr><tr><td>int indexOf(String str[,int index])</td><td>[从index位置开始]查找str在字符串中首位的位置，如果没有返回-1</td></tr><tr><td>int lastIndexOf(String str)</td><td>查找str在字符串中最后出现的首位的位置，如果没有返回-1</td></tr><tr><td>String substring(int start[,int end])</td><td>截取范围内的字符串，含头不含尾;不写end直接截取到末尾</td></tr><tr><td>String trim()</td><td>去除当前字符串两边的空白字符</td></tr><tr><td>char charAt(int index)</td><td>获取当前字符串中指定位置的字符</td></tr><tr><td>boolean startsWith(String str)<br>boolean endsWith(String str)</td><td>判断当前字符是否是以给定的字符串开始或结尾的</td></tr><tr><td>String toUpperCase()<br>String toLowerCase()</td><td>将当前字符串中的英文部分转换为全大写或全小写</td></tr><tr><td>String static valueOf()</td><td>转化为字符串，还有一种方法<code>+&quot;&quot;</code>，但代码性能更好</td></tr><tr><td>byte[] getBytes([String cs])</td><td>将当前字符串按照系统默认/cs指定字符集转换为字节</td></tr><tr><td>boolean matches(RegEx)</td><td>将一个字符串与正则表达式匹配</td></tr><tr><td>String[] split(String RegEx)</td><td>将字符串根据正则表达式拆分分隔成字符串数组</td></tr><tr><td>String replaceAll(String RegEx,String replacecement)</td><td>将字符串中匹配到的字符串替换成replacecement</td></tr></tbody></table><h3 id="java-lang-StringBuilder-StringBuffer"><a href="#java-lang-StringBuilder-StringBuffer" class="headerlink" title="java.lang.StringBuilder/StringBuffer"></a>java.lang.StringBuilder/StringBuffer</h3><p>String字符串只要一改变就会创建新对象，Java对String的优化<strong>只针对重用不针对修改</strong>，因此java提供了一个类：java.lang.StringBuilder，该类内部维护了一个可变的字符数组，修改都在这里进行，因此解决了字符串修改带来的问题。</p><blockquote><p>注：StringBuilder本身不是字符串类，只是用来修改字符串的API,提供了修字符串的操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = new StringBuilder([String])</span><br><span class="line">String s = builder.toString();</span><br></pre></td></tr></table></figure><table><thead><tr><th>StringBuilder类的API名称</th><th>说明</th></tr></thead><tbody><tr><td>StringBuilder append(String str)</td><td>追加字符串</td></tr><tr><td>StringBuilder insert(int dstOffset,String s)</td><td>插入字符串</td></tr><tr><td>StringBuilder delete(int start,int end)</td><td>删除字符串</td></tr><tr><td>StringBuilder replace(int start,int end,String str)</td><td>替换字符串</td></tr><tr><td>StringBuilder reverse()</td><td>字符串反转</td></tr></tbody></table><blockquote><p>StringBuilder类型的方法返回的都是StringBuilder的类型，返回的都是自己的引用，所以可以简化连续操作为：<code>builder.append().insert().delete()</code><br>字符串的拼接操作是通过StringBuilder的append方法实现的</p></blockquote><table><thead><tr><th>.</th><th>.</th><th>.</th><th>.</th></tr></thead><tbody><tr><td>StringBuffer</td><td>线程安全的</td><td>同步处理的</td><td>性能稍慢</td></tr><tr><td>StringBuilder</td><td>线程非安全的</td><td>并发处理的</td><td>性能稍快</td></tr></tbody></table><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><table><thead><tr><th>字符集合</th><th>说明</th><th>量词</th><th>说明</th></tr></thead><tbody><tr><td>[abc]</td><td>a或b或c</td><td>{n}</td><td>出现n次</td></tr><tr><td>[^abc]</td><td>不是a/b/c</td><td>{n,m}</td><td>出现n-m次</td></tr><tr><td>[a-zA-Z0-9]</td><td>字母及数字</td><td>{n,}</td><td>出现最少n次</td></tr><tr><td>[a-z&amp;&amp;[^bc]]</td><td>除了b/c的小写字母</td><td>{0,m}</td><td>出现最多m次</td></tr><tr><td>\d</td><td>=[0-9]</td><td>?</td><td>一次或者没有={0,1}</td></tr><tr><td>\w</td><td>=[a-zA-Z0-9_]</td><td>+</td><td>至少出现一次={1,}</td></tr><tr><td>\s</td><td>空白=[\t\n\x0B\f\r]</td><td>*</td><td>出现任意次={0,}</td></tr><tr><td>注意：</td><td><code>.</code>表示任意字符，<code>^</code>、<code>&amp;</code>表示开始与结束<br><code>\D\W\S</code>是与之小写相反的含义</td><td>()</td><td>用于分组同时</td></tr></tbody></table><ul><li>\w  原词：word   含义： 查找单词字符</li><li>\b   原词：border  含义：匹配单词边界</li><li>\d   原词：digital    含义：查找数字</li><li>\s   原词：space    含义：查找空白字符</li><li>\n  原词：newline  含义：查找换行符</li><li>\f   原词：form feed  含义：查找换页符</li><li>\r   原词：retrun 含义：查找回车符</li><li>\t   原词：tab      含义：查找制表符</li><li>\v  原词：Vertical tab  含义：垂直制表符</li></ul><blockquote><p>Java中会看到<code>\\.</code>是因为Java为正则表达式的转义斜线进行了转义<br><code>.</code>在正则表达式中表示所有字符<code>\.</code>是正则表达式来转义为普通的点<code>\\.</code>是因为java认为<code>\.</code>语法有问题，需要把<code>\</code>转义为普通<code>\</code></p></blockquote><h2 id="Object、包装类"><a href="#Object、包装类" class="headerlink" title="Object、包装类"></a>Object、包装类</h2><h3 id="Object-toString"><a href="#Object-toString" class="headerlink" title="Object.toString()"></a>Object.toString()</h3><ul><li>Java语言中很多地方都会默认调用对象的toString方法，如字符串+对象、输出语句、Arrays.toString()等</li><li>toString()方法默认返回的是：类名@地址</li><li>Java自带类基本都重写了该方法，强烈建议自己写的类也重写该方法</li><li>重写toString方法原则上返回的字符串应当包含当前对象的属性信息</li></ul><h3 id="Object-equals"><a href="#Object-equals" class="headerlink" title="Object.equals()"></a>Object.equals()</h3><ul><li>规定用于对比两个对象是否“相同”</li><li>Java自带类基本都重写了该方法，如果不重写，底层相当于使用<code>==</code>判断</li><li><code>==</code>用于比较两者是否相同：基本数据类型的值/引用数据类型的引用</li></ul><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>8种基本类型是以值的形态存在的，不是以对象的形态存在的，所以封装、多态等不适用于基本数据类型，为解决这个问题，Java提供了包装类：</p><ol><li>包装类是final修饰的，没有子类。内部储存值也是final修饰，不可更改</li><li>Integer、Long、Double、Short、Float、Byte、Character、Boolean</li></ol><h4 id="包装类的创建方法："><a href="#包装类的创建方法：" class="headerlink" title="包装类的创建方法："></a>包装类的创建方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = Integer.valueOf(int);</span><br><span class="line">Integer i2 = new Integer(int);</span><br><span class="line">Integer i3 = 120;</span><br></pre></td></tr></table></figure><ul><li>建议使用<code>valueOf()</code>方法创建对象，通过这种方法有些包装类会有类似String那样重用现象：如Integer重用-128～127，但是Double不重用，等同于new</li><li>Byte、Character、Integer、Short、Long可以，另三个否</li><li>JDK1.5及以上可以包装类&lt;–&gt;基本数据类型直接赋值转换，编译期编译器补全代码，叫做自动装箱拆箱特性</li></ul><h4 id="包装类转换为基本类型方法："><a href="#包装类转换为基本类型方法：" class="headerlink" title="包装类转换为基本类型方法："></a>包装类转换为基本类型方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = i1.intValue();</span><br><span class="line">double d = i1.doubleValue();</span><br><span class="line">byte b = i1.byteValue();</span><br></pre></td></tr></table></figure><ul><li>每个数字包装类都有这些类似方法，包括大值转小值</li><li>大转小会精度缺失，二进制高位省略</li></ul><h4 id="包装类的常用API"><a href="#包装类的常用API" class="headerlink" title="包装类的常用API"></a>包装类的常用API</h4><table><thead><tr><th>java.lang.Number类API</th><th>说明</th></tr></thead><tbody><tr><td>int Interger.parseInt(String str)</td><td>将字符串类型转换为对应基本类型，”123.0”在此会报错，只能”123”</td></tr><tr><td>double Double.parseDouble(String str)</td><td>但是注意格式要正确，否则抛出NumberFormatException异常</td></tr></tbody></table><h2 id="日期操作"><a href="#日期操作" class="headerlink" title="日期操作"></a>日期操作</h2><h3 id="java-util-Date"><a href="#java-util-Date" class="headerlink" title="java.util.Date"></a>java.util.Date</h3><ul><li>Date的每一个实例用于表示一个时间，内部维护一个long值，该值保存的是自1970-1-1到当前Date所表示的时间之间经过的毫秒</li><li>注意其Date表示的时间是格林尼治时间，为0时区时间，系统显示时会添加时区时间显示</li><li>Date内部由于存在千年虫和时区的问题，因此大部分方法都被声明为过时的，不再建议使用，大多数Calendar类取代</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>有参构造</td><td>分配 Date 对象并初始化此对象当前时间</td></tr><tr><td>有参构造Date(long date)</td><td>分配 Date 对象并初始化此对象</td></tr><tr><td>void setTime(long time)</td><td>设置此 Date 对象，以表示1970-1-1 00:00:00 GMT以后 time 毫秒的时间点</td></tr><tr><td>long getTime()</td><td>返回自1970-1-1 00:00:00 GMT以来此 Date 对象表示的毫秒数</td></tr><tr><td>boolean after(Date when)</td><td>测试此日期是否在指定日期之后</td></tr><tr><td>boolean before(Date when)</td><td>测试此日期是否在指定日期之前</td></tr><tr><td>Object clone()</td><td>返回此对象的副本</td></tr><tr><td>int compareTo(Date anotherDate)</td><td>比较两个日期的顺序</td></tr></tbody></table><h3 id="java-text-SimpleDateFormat"><a href="#java-text-SimpleDateFormat" class="headerlink" title="java.text.SimpleDateFormat"></a>java.text.SimpleDateFormat</h3><ul><li>该类是用于格式化和解析日期的具体类，主要用于格式化(日期-&gt;文本)，解析(文本-&gt;日期)操作</li><li>构造方法：主要是 无参构造 和 传入一个给定模式的 有参构造，特定模式使用String表示，表示方法如下表</li><li>方法：<code>String format(Date date)</code> 将给定的时间对象按照格式转换为字符串</li><li>方法：<code>Date parse(String source)</code> 将给定的字符串按照格式返回一个Date对象 </li></ul><table><thead><tr><th>字符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>y</td><td>年</td><td>yyyy年：2019年；yy年：19年</td></tr><tr><td>M</td><td>月</td><td>MM月：01月；M月：1月</td></tr><tr><td>d</td><td>日</td><td>dd日：06日；d日：6日</td></tr><tr><td>E</td><td>星期</td><td>有E这个标识 则显示 星期日 或 Sun</td></tr><tr><td>a</td><td>AM或PM标识</td><td>显示 下午(AM) 或 上午(PM)</td></tr><tr><td>H</td><td>小时(24小时制)</td><td></td></tr><tr><td>h</td><td>小时(12小时制)</td><td></td></tr><tr><td>m</td><td>分钟</td><td></td></tr><tr><td>s</td><td>秒</td><td></td></tr></tbody></table><h3 id="java-util-Calendar"><a href="#java-util-Calendar" class="headerlink" title="java.util.Calendar"></a>java.util.Calendar</h3><ul><li>Calendar 抽象类，规定了操作时间的相关方法等</li><li>常用实现类：java.util.GregorianCalendar 格里高利历(阳历)</li><li>我们可以通过Calendar提供的静态方法getInstance来根据当前系统所在地区获取一个使用的实现类，大部分地区获取的都是格里高利历实现类</li><li>特别注意：Calendar中规定<font color="red">月份从0开始的</font>，使用表示记得+1</li><li>特别注意：Calendar中规定<font color="red">星期从周日开始的</font>，使用表示记得更改习惯</li><li>特别注意：Calendar中调用set()方法等设定时间时，<font color="red">底层并未进行计算</font>，只有执行了getTime()或add()方法后才会进行刷新，特别注意防止在刷新前有多个set()方法同时影响同一个值，这样的话后面的方法会覆盖掉前面的方法</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static Calendar getInstance()</td><td>使用默认时区和语言环境获得一个日历</td></tr><tr><td>Date getTime()</td><td>返回一个表示此 Calendar 时间值的 Date 对象</td></tr><tr><td>void setTime(Date date)</td><td>使用给定的 Date 设置此 Calendar 的时间</td></tr><tr><td>int get(int field)</td><td>返回给定日历字段的值</td></tr><tr><td>void set(int field,int value)</td><td>将给定的日历字段设置为给定值</td></tr><tr><td>int getActualMaximum(int field)</td><td>返回指定日历字段可能拥有的最大值</td></tr><tr><td>abstract void add(int field, int amount)</td><td>根据日历的规则，为给定的日历字段添加或减去指定的时间量</td></tr></tbody></table><ul><li>和天有关的时间分量：</li><li>DATE:月中的天</li><li>DATE_OF_MONTH:月中的天，与DATE是一样的</li><li>DATE_OF_WEEK:周中的天，就是星期几</li><li>DATE_OF_YEAR:年中的天，今年的第几天</li></ul><h2 id="文件及随机读写File、RandomAccessFile"><a href="#文件及随机读写File、RandomAccessFile" class="headerlink" title="文件及随机读写File、RandomAccessFile"></a>文件及随机读写File、RandomAccessFile</h2><h3 id="java-io-File"><a href="#java-io-File" class="headerlink" title="java.io.File"></a>java.io.File</h3><ul><li>操作文件或目录（创建，删除）</li><li>访问其表示的文件或目录的属性（名字,大小等）</li><li>访问一个目录的子项内容</li><li>但是<strong>不能访问</strong>文件数据</li><li>绝对路径与相对路径，推荐使用相对路，如<code>[./]src/xxx.java</code>或<code>xx.class.getResource(/img/xx.png)</code>等</li></ul><table><thead><tr><th>File类常用的API名称</th><th>说明</th></tr></thead><tbody><tr><td>File File(String str)</td><td>str为路径名(文件/目录)</td></tr><tr><td>String gerName()</td><td>返回文件名</td></tr><tr><td>Long length()</td><td>返回文件大小，单位大小LONG</td></tr><tr><td>boolean canRead()</td><td>判断是否可读</td></tr><tr><td>boolean canWrite()</td><td>判断是否可写</td></tr><tr><td>boolean isHidden()</td><td>判断是否为隐藏文件</td></tr><tr><td>boolean exists()</td><td>判断文件是否存在</td></tr><tr><td>boolean createNewFile()</td><td>创建新文件-IOException</td></tr><tr><td>boolean delete()</td><td>删除文件</td></tr><tr><td>boolean mkdir()</td><td>创建单个文件夹,父目录没有会失败</td></tr><tr><td>boolean mkdirs()</td><td>创建多层多个文件夹,父目录没有会创建</td></tr><tr><td>boolean delete()</td><td>删除空目录,注意有任何都不成功</td></tr><tr><td>boolean isFile()</td><td>判断是否文件</td></tr><tr><td>boolean isDirectory()</td><td>判断是否目录</td></tr><tr><td>File[] listFiles([FileFilter])</td><td>返回当前目录下[过滤后的]所有文件及目录</td></tr></tbody></table><h3 id="java-io-RandomAccessFile"><a href="#java-io-RandomAccessFile" class="headerlink" title="java.io.RandomAccessFile"></a>java.io.RandomAccessFile</h3><ul><li>专门用来读写文件数据的API，其基于指针对文件进行随机读写操作，读写操作非常灵活</li><li>构造方法常用两个：<code>RandomAccessFile(String name,String mode)</code>和<code>RandomAccessFile(File file,String mode)</code></li><li>模式(mode):”rw”读写模式，”r”只读模式</li><li>如果没有该文件，读写模式会自动创建，只读模式抛异常</li></ul><table><thead><tr><th>RandomAccessFile类常用的API名称</th><th>说明</th></tr></thead><tbody><tr><td>int read()</td><td>读一个字节数据，当读到末位返回-1</td></tr><tr><td>int read(byte[] data)</td><td>块读取，一次读取最多传入数组长度的数据到该数组，返回读取到的长度值，-1为末尾</td></tr><tr><td>void write(int)</td><td>写一个字节数据int的低八位</td></tr><tr><td>void write(byte[] data[,int offset,int len])</td><td>块写入，把数组的内容写入文件，从offset到len，解决最后一次长度问题</td></tr><tr><td>long getFilePointer()</td><td>返回当前RAF的指针位置</td></tr><tr><td>void seek(long pos)</td><td>设置指针位置</td></tr><tr><td>int readInt()</td><td>写4字节数据,readLong(long)写8字节数据,readDouble(double)写16字节数据等等</td></tr><tr><td>void writeInt(int)</td><td>写4字节数据,writeLong(long)写8字节数据,writeDouble(double)写16字节数据等等</td></tr><tr><td>void close()</td><td>关闭文件</td></tr></tbody></table><h2 id="IO流操作"><a href="#IO流操作" class="headerlink" title="IO流操作"></a>IO流操作</h2><ul><li>节点流(低级流)：实际连接程序与数据源，最基础的流</li><li>处理流(高级流)：必须连接在其他流上存在，是对一个已存在的流的连接和封装</li><li>终端流：直接进行操作的流，非终端流一般称为中间流</li><li>流的操作一层一层套用，注意有的高级流可能内嵌了其他高级流或低级流</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = new FileOutputStream(&quot;pw.txt&quot;);</span><br><span class="line">OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;utf-8&quot;);</span><br><span class="line">BufferedWriter bw = new BufferedWriter(osw);</span><br><span class="line">PrintWriter pw = new PrintWriter(bw);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">.</th><th align="center">字节流</th><th align="center">字符流</th></tr></thead><tbody><tr><td align="center">超类</td><td align="center">InputStream/OutputStream</td><td align="center">Reader/Writer</td></tr><tr><td align="center">低级流</td><td align="center">文件流</td><td align="center">\</td></tr><tr><td align="center">高级流</td><td align="center">缓冲流<br>对象流</td><td align="center">字符缓冲流<br>行刷新的缓冲字节流</td></tr></tbody></table><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><ul><li><code>abstract java.io.InputStream</code>：所有字节输入流的抽象超类，规定了读取字节的相关方法，抽象方法：<code>int read()</code>、<code>int read(byte[] data)</code>等</li><li><code>abstract java.io.OutputStream</code>：多有字节输出流的抽象超类，规定了写出字节的相关方法，抽象方法：<code>void write(int d);</code>、<code>void write(byte[] data)</code>等</li></ul><h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><ul><li>文件流是以对节点流(低级流)，用于对文件进行读写的流，功能上与RandomAccessFile一样</li><li>RAF是随机读写形式，文件流是顺序读写形式</li><li>虽然RAF更灵活，但基于流连接可以完成复杂数据的读写</li><li><code>FileInputStream(File file[,boolean append])</code></li><li><code>FileInputStream(String path[,boolean append])</code></li></ul><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><ul><li>缓冲流是一对高级流，在流连接中的作用是加快数据的读写效率</li><li>他们会将读写的数据统一转换为块读写以达到效率提高的目的</li><li><code>java.io.BufferedInputStream(InputStream in)</code></li><li><code>java.io.BufferedOutputStream(OutputStream out)</code></li><li>关闭时会先关闭前面的流最后关闭自己，所以只需要关闭离程序最近的高级流就可以</li><li>输出流中<code>void flush()</code>强制清空缓冲区，缓冲区未满时及时完成工作</li><li>close()方法包含flush()方法，但注意有需求时自己调用flush()</li></ul><h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><ul><li>对象流是一对高级流，可以读写java中任何对象</li><li>他们将对象其结果与一组字节相互转换</li><li><code>java.io.ObjectInputStream(InputStream in)</code></li><li><code>java.io.ObjectInputStream(OutputStream out)</code></li><li>对象所属的类必须实现序列化接口才可使用对象流，否则会抛出异常</li><li>序列化接口：java.io.Serializable</li><li><code>void writeObject(Object o)</code>和<code>Object readObject()</code></li><li><code>transient</code>关键字，在实现了序列化接口的类中，说明该词修饰的不被转换为对象流</li></ul><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><ul><li><code>abstract java.io.Reader</code>：所有字符输入流的抽象超类，规定了读取字符的相关方法，抽象方法：<code>int read()</code>、<code>int read(char[] chs)</code>等</li><li><code>abstract java.io.Writer</code>：多有字符输出流的抽象超类，规定了写出字符的相关方法，抽象方法：<code>void write(int c);</code>、<code>void write(char[] chs[,int offset,int len])</code>、<code>void write(String str)</code>等</li></ul><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><ul><li>转换流是一对高级流，是字符流的一对实现类</li><li>转换流一般不会作为终端流直接操作，但作为文件流与字符流的转换作用其作用十分重要</li><li><code>java.io.InputStreamReader(InputStream in[,String cs])</code></li><li><code>java.io.OutputStreamWriter(OutputStream out[,String cs])</code></li></ul><h3 id="缓冲字符流"><a href="#缓冲字符流" class="headerlink" title="缓冲字符流"></a>缓冲字符流</h3><ul><li>缓冲字符流是一对高级流，块写加速，按行写文本</li><li><code>java.io.BufferedWriter(Writer out)</code>但是一般使用PrintWriter</li><li><code>java.io.BufferedReader(Reader in)</code></li><li>使用<code>String readLine()</code>方法读取一行数据，读到结束返回null</li></ul><h3 id="行刷新缓冲字符流"><a href="#行刷新缓冲字符流" class="headerlink" title="行刷新缓冲字符流"></a>行刷新缓冲字符流</h3><ul><li>PrintWriter内包含了BufferedWriter且有自动刷新换行功能</li><li><code>java.io.PrintWriter(File file/String fileName/Writer writer/OutputStream out)</code></li><li><code>java.io.PrintWriter(String fileName[,String cs])</code>比较方便常用</li><li><code>java.io.PrintWriter(Writer writer[,boolean autoFlush])</code>打开自动行刷新，每输入一行自动flush()一次</li><li>只有在流连接的构造函数中才有自动行刷新的参数</li><li><code>void println()</code>输出字符串后换行方法</li></ul><h2 id="异常处理、异常API"><a href="#异常处理、异常API" class="headerlink" title="异常处理、异常API"></a>异常处理、异常API</h2><h3 id="异常简介"><a href="#异常简介" class="headerlink" title="异常简介"></a>异常简介</h3><ul><li>Throwable 所有异常的超类</li><li>Error、Exception(RuntimeException/IOException) 两种异常总类</li><li>错误、异常(运行时异常、受检异常)</li><li>使用try-catch-finally语句处理异常，或者throws抛出异常</li><li>finally：无论是否有错都会执行的代码部分，特殊情况如果try/catch中有return,会执行完return后半句,去执行finally后再回来return</li><li>但是System.close(0)并不会执行finally，会立即终止程序</li><li>方法内代码块中可以throw抛出一个自定的异常，RuntimeException不会强制处理</li><li>JDK1.7及以后，try()小括号内可以定义实现了<code>autoCloseable</code>接口的类的实例，这样可以不用写close()方法，编译器编译时改回正常书写方式编译。该编写为编译器认可</li><li>所有的流以及某些类都实现了<code>autocloseable</code>，正常书写方式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//因为作用域问题，流在try外面声明定义</span><br><span class="line">FileOutputStream fos = null;</span><br><span class="line">try &#123;</span><br><span class="line">fos = new FileOutputStream(&quot;fos.dat&quot;);</span><br><span class="line">fos.write(1);</span><br><span class="line">&#125;catch(IOException e) &#123;</span><br><span class="line">System.out.println(&quot;出错了&quot;);</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">try &#123;</span><br><span class="line">        //关闭之前判断是否为null</span><br><span class="line">if(fos!=null) &#123;</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ol><li>创建类，定义类名，做到见名知意</li><li>继承Exception或其子类</li><li>由于Exception实现了Serializable，可选定义序列化版本号</li><li>重写Exception定义的所有构造方法</li></ol><h3 id="处理异常方式"><a href="#处理异常方式" class="headerlink" title="处理异常方式"></a>处理异常方式</h3><p>1、JVM执行某句话出现异常<br>2、虚拟机结合情况实例化对应的异常实例<br>3、并将代码执行情况赋值到异常实例中<br>4、然后将异常抛出<br>5、检查catch处理异常的机制<br>6、无catch则继续向外抛出异常<br>7、一直抛出到最后，处理方式为JVM终止程序</p><h2 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h2><h3 id="java-net-Socket"><a href="#java-net-Socket" class="headerlink" title="java.net.Socket"></a>java.net.Socket</h3><ul><li>封装了TCP通讯的传输细节，使得我们使用它就可以完成与远端计算机的TCP连接以及数据传输</li><li>并且完成数据传输是基于两条流的读写</li><li><code>Socket(String host,int port)</code></li><li>Socket实例化的过程就是连接服务端的过程，成功连接则实例化成功，否则会在实例化过程中该抛出异常</li><li>通过<strong>IP地址</strong>找到网络上的服务端所在计算机，通过<strong>端口</strong>找到该机器上的服务端应用程序</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getLocalPort()</td><td>返回本地连接的端口号</td></tr><tr><td>InetAddress getLocalAddress()</td><td>返回一个InetAddress数据对象，套接字绑定的本地地址</td></tr><tr><td>int getPort()</td><td>返回远端使用的端口号</td></tr><tr><td>InetAddress getInetAddress()</td><td>返回一个InetAddress数据对象，套接字绑定的远端地址</td></tr><tr><td>OutputStream getOutputStream()</td><td>返回字节输出流，其写出的字节流可以通过网络发送到远端</td></tr><tr><td>InputStream getInputStream()</td><td>返回字节输入流，其读取通过网络发送过来的字节流</td></tr><tr><td>void close()</td><td>关闭此套接字，同时关闭了输入流与输出流</td></tr></tbody></table><h4 id="java-net-InetAddress"><a href="#java-net-InetAddress" class="headerlink" title="java.net.InetAddress"></a>java.net.InetAddress</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getCanonicalHostName()</td><td>获取此IP地址的完全限定域名</td></tr><tr><td>String getHostAddress()</td><td>返回IP地址字符串(文本形式)</td></tr></tbody></table><h3 id="java-net-ServerSocket"><a href="#java-net-ServerSocket" class="headerlink" title="java.net.ServerSocket"></a>java.net.ServerSocket</h3><ul><li>向系统申请服务端口并监听该端口，客户端进行连接时，ServerSocket会自动创建一个Socket与客户端进行交互</li><li><code>ServerSocket(int port)</code></li><li><code>Socket accept()</code>该方法是一个阻塞方法，一直等待一个客户端连接为止，并返回Socket实例，可多次调用进行接收多个客户端的连接</li></ul><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="反射基础"><a href="#反射基础" class="headerlink" title="反射基础"></a>反射基础</h3><h4 id="获取Class对象的方式"><a href="#获取Class对象的方式" class="headerlink" title="获取Class对象的方式"></a>获取Class对象的方式</h4><ol><li>每个类都有一个class属性，通过 类.class 获取Class对象</li><li>每个对象都有getClass()方法，通过 对象.getClass() 获取Class对象</li><li>Class类的静态方法，Class.forName(完整类名) 获取Class对象</li></ol><ul><li>基本数据类型也有Class对应对象，包括void也有</li><li>包装数据类的静态成员TYPE返回对应基本数据类型类：Class&lt;?&gt; cls=Integer.TYPE;</li><li>通过forName()方法获取Class对象时，会把参数指定的类加载到内存中</li></ul><h3 id="java-lang-Class"><a href="#java-lang-Class" class="headerlink" title="java.lang.Class"></a>java.lang.Class</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static Class forName(String className)</td><td>返回与带有给定字符串名的类或接口相关联的 Class 对象</td></tr><tr><td>String getName()</td><td>返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称</td></tr><tr><td>String getSimpleName()</td><td>返回此 Class 对象的简单名称</td></tr><tr><td>Method[] getMethods()</td><td>返回一个 Method 对象的数组，每个Method对象表示一个方法</td></tr><tr><td>Method getMethod(String name[Class&lt;?&gt;… parameterTypes])</td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法</td></tr><tr><td>Object newInstance()</td><td>实例化该 Class 对象(仅适用于具有无参构造的类)</td></tr><tr><td>int getModifiers()</td><td>返回一个修饰符，是一个整数，可以通过Modifier类中的静态方法转换<br>Modifier：static String toString(int modifier)</td></tr><tr><td>Class&lt;?&gt; getSuperclass()</td><td>返回该 Class 对象父类的 Class 对象</td></tr><tr><td>Class&lt;?&gt;[] getInterfaces()</td><td>返回该 Class 对象实现的接口数组</td></tr><tr><td>Filed getField(String field)</td><td>获取名为field的字段的值(只能返回公共字段)，可以通过Field对象操作<br>Field：void set(Object obj, Object value)<br>Filed：Object get(Object obj) 对Object对象Field属性值的操作</td></tr><tr><td>Filed getDeclareField(String field)</td><td>获取名为field的字段的值(可以返回任意访问权限字段，但只能返回不能访问)<br>Filed：void setAccessible(boolean canAccess) 设置为true时可以访问私有字段值</td></tr></tbody></table><h3 id="java-lang-reflect-Method"><a href="#java-lang-reflect-Method" class="headerlink" title="java.lang.reflect.Method"></a>java.lang.reflect.Method</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getName()</td><td>返回该Method所指方法的方法名</td></tr><tr><td>Object invoke(Object obj[Object… args])</td><td>调用obj对象的该Method对象方法(可传入参数)</td></tr></tbody></table><h2 id="Lambda函数式"><a href="#Lambda函数式" class="headerlink" title="Lambda函数式"></a>Lambda函数式</h2><ul><li>由JDK1.8开始引入的语句，主要是解决了Java缺失函数式编程特点的缺点</li><li>这是编译器认可的语句，编译时会更改为一般代码样式去编译</li><li>其语法为：<code>(参数)-&gt;{方法体}</code></li><li>参数部分：可以为空，表示没有参数；可以多个，表示多个参数；可以不写参数类型，前提是可以推断</li><li>方法体部分：如果方法体内只有一条语句，可以省略花括号{}；但如果这一句是return，则必须把return也省掉</li><li>特别注意：lambda表达式 与 匿名内部类 this关键字的区别！！–&gt;前者的this表示外部类，后者的this表示匿名类</li><li>常用在实现只含有一个抽象方法的接口的时候，Java中 某些接口在类声明上方有个注解 @FunctionalInterface 说明该接口可以用Lambda表达式，没有标注也不一定不可以</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java基础-JavaSE-上&quot;&gt;&lt;a href=&quot;#Java基础-JavaSE-上&quot; class=&quot;headerlink&quot; title=&quot;Java基础-JavaSE(上)&quot;&gt;&lt;/a&gt;Java基础-JavaSE(上)&lt;/h1&gt;&lt;h2 id=&quot;JavaSE基础&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="语言编程" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础-面向对象(OOP)</title>
    <link href="http://yoursite.com/2019/12/09/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(OOP)/"/>
    <id>http://yoursite.com/2019/12/09/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(OOP)/</id>
    <published>2019-12-09T11:45:02.000Z</published>
    <updated>2019-12-09T11:46:10.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础-面向对象-OOP"><a href="#Java基础-面向对象-OOP" class="headerlink" title="Java基础-面向对象(OOP)"></a>Java基础-面向对象(OOP)</h1><h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><ol><li>对象：软件中存在的单个个体</li><li>类：对象的抽象、总结，对象的模板</li><li>成员变量、成员方法</li></ol><h3 id="定义类："><a href="#定义类：" class="headerlink" title="定义类："></a>定义类：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;修饰词&gt; class 类名&#123;</span><br><span class="line">    &lt;成员变量;&gt;</span><br><span class="line">    &lt;成员方法/类函数&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>方法的签名：就是方法名+参数列表；SendMsg(“Hello”);</p></li><li><p>方法重载Overload：<strong>方法名</strong>相同，<strong>参数列</strong>表必须不同(个数、类型)，但<font color="red"><strong>与修饰词、返回值无关</strong></font>，重载选择是编译器编译时决定的</p></li><li><p>构造函数：(可以重载)无返回值,名字和类名相同 一般用于初始化成员变量的值<br><code>&lt;访问修饰符&gt; 类名 (&lt;参数列表&gt;){构造方法体}</code></p><blockquote><p>没写构造函数，编译时会自动添加一个无参的构造函数。但是注意如果写了构造函数，编译时就<font color="red"><strong>不会再自动添加</strong></font>无参的构造函数！！</p></blockquote></li><li><p>this：代表自己本身这个对象，可用于：成员变量 成员函数 构造函数</p><blockquote><p>用this调用构造函数必须放在第一句,且只能放在构造函数中<br>如果子类变量与父类变量重名，this优先本类变量，如果子类没有重名变量，this指向父类变量</p></blockquote></li></ul><blockquote><p>注意内存分配问题，对象的引用与实体，堆栈问题</p></blockquote><h3 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h3><p>类 –&gt; 对象<br><code>&lt;类名&gt; &lt;对象名&gt; = new &lt;类名&gt;(构造函数参数);</code></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的基础概念"><a href="#继承的基础概念" class="headerlink" title="继承的基础概念"></a>继承的基础概念</h3><ul><li>继承其他包中的类,需要先导入此类/包含此类的包，is-a原则</li><li>不写extends默认继承java.lang.Object类，也就是说所有类都时Object类的子类，都拥有Object类的变量及方法</li><li>一个类只能extends一个类，可以implements多个接口</li></ul><h3 id="如何继承类"><a href="#如何继承类" class="headerlink" title="如何继承类"></a>如何继承类</h3><ul><li>使用关键子<code>extends</code>进行继承，例：<code>class son extends farther{}</code></li><li>继承就是继承父类的所有成员函数和成员变量(注意权限问题,private不能直接访问)</li><li><font color="red">子类的<strong><em>属性、方法</em></strong>与父类的属性/方法重名是被Java允许的</font>，但注意区分，用this或super区别调用(如果子类变量与父类变量重名，this优先本类变量，如果子类没有重名变量，this指向父类变量)</li><li>内存结构：子类内存对象中存有父类内存对象的引用(new生成子类对象和父类对象两个)<blockquote><p>super：用法与this相同，在继承中常用在方法重写与构造函数中<br>相同的，用super调用构造函数时，也必须放在第一句,且只能放在构造函数中</p></blockquote></li></ul><h3 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h3><ul><li>子类的构造函数不写super编译器会自动添加super()无参的父类构造函数</li><li>子类的构造函数可以调用父类的其他构造函数，使用super()，但注意super()必须放在子类构造函数的第一句(根据参数列表确定调用的哪个构造函数)</li></ul><blockquote><p><font color="red"><strong>父类没写无参构造</strong></font>，且写了其他有参构造函数，编译器不会再自动添加无参构造函数，会导致<strong>子类构造函数中自动添加的super()报错</strong></p></blockquote><h3 id="继承中的方法重写"><a href="#继承中的方法重写" class="headerlink" title="继承中的方法重写"></a>继承中的方法重写</h3><ul><li><p><strong>方法重写</strong>：子类方法名与父类方法名相同，且形参列表相同，返回值与访问修饰符如下</p><ul><li><strong>返回值</strong>：也要相同，除非返回值类型为引用数据类型时，子类的返回值类型可以是父类返回值类型的子类</li><li><strong>访问修饰符</strong>：子类的访问修饰符 <strong>不能</strong> 比父类访问修饰符更严格</li><li><strong>异常处理</strong>：子类的异常类型要与父类相同，或者是父类异常类型的子类</li></ul></li><li><p>private方法不能被重写成功（不报错但是重写不成功，自我调用还是父类方法）</p></li><li><p>可以使用<code>super.方法名</code>，调用原方法，再另行添加自己的代码</p><blockquote><p>这里的super可以不必第一行，只有构造函数时super/this必须第一行</p></blockquote></li><li><p>@override，表明明确复写父类函数，编译器可检查错误</p></li><li><p>子类重写的内容覆盖父类内存对象中的原方法内容，所以向上转型后的调用是重写后的方法。注意：子类中与父类重名的成员变量不属于重写，在子类内存对象与父类内存对象分别储存着。</p></li></ul><table><thead><tr><th>重载与重写区别</th><th>位置</th><th>方法名</th><th>参数</th><th>返回值</th><th>修饰符</th></tr></thead><tbody><tr><td>重载&emsp;Overload</td><td>同类*</td><td>相同</td><td>不同</td><td><font color="red">无关</font></td><td><font color="red">无关</font></td></tr><tr><td>重写&emsp;Override</td><td>子类</td><td>相同</td><td>相同</td><td>相同*</td><td>相同*</td></tr></tbody></table><h2 id="抽象类、接口、内部类"><a href="#抽象类、接口、内部类" class="headerlink" title="抽象类、接口、内部类"></a>抽象类、接口、内部类</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>用<code>abstract</code>关键字定义<code>public/默认 abstract class 类名{};</code></li><li>抽象类不能生成对象(只能当父类)</li><li>抽象类被继承后需要重写抽象类中所有的抽象方法，如果子类是也抽象类则可以不全部重写父类抽象方法</li><li>抽象方法：用<code>abstract</code>修饰的方法，特点是没有函数体无大括号<code>public abstract void 函数名();</code></li><li>抽象类其他特性与普通类一样，但是注意不可以抽象构造方法。</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><ul><li>用<code>interface</code>关键字定义<code>public/默认 interface 接口名{};</code></li><li>在类的声明后面使用<code>implements</code>加接口名逗号分隔实现</li></ul><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>所有属性只能是公有静态常量,不写/不写全则编译器自动增为<code>public static final</code></li><li>所有方法只能是公有抽象方法,不写/不写全则编译器自动增为<code>public abstract</code></li><li>没有静态块，构造函数(不能实例化)。静态方法和默认方法很少使用，暂时忽略</li></ul><blockquote><p>接口没有构造函数不能实例化对象，has-a原则<br>接口一般是某种功能的总结，接口可以继承多个接口<br>更容易实现程序架构的搭建-面向接口编程</p></blockquote><h3 id="内部类-Inner-！Outer"><a href="#内部类-Inner-！Outer" class="headerlink" title="内部类(Inner)！Outer"></a>内部类(Inner)！Outer</h3><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul><li>在成员变量的位置声明的内部类，可以使用4种<strong>全部的访问修饰符</strong></li><li>实例化内部类对象需要外部类的支持，<code>&lt;内部类&gt; x = &lt;外部类对象&gt;.new &lt;内部类&gt;</code></li><li>当前类如果需要多个方法中使用这个类且只有自己的类使用，定义内部类<hr></li><li>外部类和内部类的私有成员可以相互调用，外部类实例化对象访问，内部类直接访问</li><li>允许内部类和外部类定义同名成员，内部类调用外部类成员时<code>&lt;外部类&gt;.this.&lt;成员&gt;</code></li><li>内部类编译时产生独立的<strong>class文件</strong><code>外类名$内类名.class</code></li></ul><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul><li>继承或实现接口时直接使用：<code>&lt;父类&gt; name = new &lt;父类&gt;{子类代码块}</code></li><li>一个类的某方法临时使用时，更有针对性</li><li>匿名内部类访问定义该匿名内部类的方法的局部变量(参数/变量)时，如果局部变量没有另外修改值则可访问，但一直不可修改(视为final只可访问不可修改)。</li><li>如果方法中/内部类中修改了局部变量值，内部类不可访问该值，所以一般如果这样使用，通称在需要调用的变量声明前使用final(参数变量也可以哦)</li><li>JAR1.8以前如果上方使用，必须添加final否则报错<hr></li><li>外部类和内部类的私有成员可以相互调用，外部类实例化对象访问，内部类直接访问</li><li>允许内部类和外部类定义同名成员，内部类调用外部类成员时<code>&lt;外部类&gt;.this.&lt;成员&gt;</code></li><li>内部类编译时产生独立的<strong>class文件</strong><code>外类名$数字.class</code></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的使用"><a href="#多态的使用" class="headerlink" title="多态的使用"></a>多态的使用</h3><ol><li>向上造型数组储存</li><li>向上造型方法重写</li><li>向下造型调用私有方法<blockquote><p>强制类型转换<code>(需要类型)实例化对象</code>，容易产生ClassCastException错误<br>关键字<code>对象instanceof类型</code>返回布尔判断类型，尽量避免，并不是面向对象思想做法</p></blockquote></li></ol><h3 id="对象转型"><a href="#对象转型" class="headerlink" title="对象转型"></a>对象转型</h3><ul><li><p><strong>向上造型</strong>：f和s指向堆中同一个对象,但f只能调用自己类的变量和方法  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">farther f = new son();</span><br></pre></td></tr></table></figure></li><li><p><strong>向下造型</strong>：（官方没承认的民间说法）一般不可以，例外：前提先向上转型再向下转型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">farther f = new son();</span><br><span class="line">son s = (son)f;</span><br></pre></td></tr></table></figure></li></ul><h2 id="关键字-访问控制-static-final"><a href="#关键字-访问控制-static-final" class="headerlink" title="关键字-访问控制/static/final"></a>关键字-访问控制/static/final</h2><h3 id="访问控制修饰词"><a href="#访问控制修饰词" class="headerlink" title="访问控制修饰词"></a>访问控制修饰词</h3><table><thead><tr><th>权限修饰词</th><th>作用范围</th><th>类内部</th><th>同包</th><th>不同包<br>子类</th><th>其他</th></tr></thead><tbody><tr><td>public(共有)</td><td>其他包可以通过全名调用(导入后可以不写包名)</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>其他包作为子类可以调用,不过只能修饰变量和函数<br>主要用于可以被子类继承使用(只有子类)</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>default(默认不写)</td><td>同一个包才可以使用</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>private(私有)</td><td>同一个类才可以使用</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><blockquote><ul><li>class只有两种修饰方式：默认/public</li><li>通过访问修饰符封装类属性：<ol><li>变量设为pravate私有的</li><li>编写public公有的get/set方法进行判断赋值</li></ol></li></ul></blockquote><h3 id="static静态修饰词"><a href="#static静态修饰词" class="headerlink" title="static静态修饰词"></a>static静态修饰词</h3><table><thead><tr><th>static的使用</th><th>说明</th></tr></thead><tbody><tr><td>Static 变量</td><td>推荐直接<code>类名.静态变量</code>进行访问,等同于<code>实例化.静态变量</code><br>因为静态变量是共享的，是指向同一块内存的</td></tr><tr><td>Static 方法</td><td>推荐直接<code>类名.静态方法</code>进行调用,等同于<code>实例化.静态方法</code><br><strong>静态方法中无法使用实例成员：</strong><br>&emsp;静态方法只能访问静态变量，静态方法只能调用静态方法<br>&emsp;普通方法可以访问所有变量，普通方法可以调用所有方法</td></tr><tr><td>Static 类</td><td>很少使用，暂时忽略</td></tr><tr><td>Static 代码块</td><td>静态代码块 static{} 匿名代码块 {}<br>在类载入内存时执行它,且只运行一次,一般很少用<br>当类被实例化,执行顺序:静态块(1次)&gt;匿名块&gt;构造函数</td></tr></tbody></table><blockquote><p>static修饰的变量和方法不可以用this或super<br>静态方法中无法使用实例成员的<strong>根本原因</strong>是无法this<br>静态方法重写不成功（不报错，但是调用还是父类方法）<br>在类载入内存时：1实例化对象2使用类中静态成员<br>final+static定义的常量声明时赋值被使用，<font color="red"><strong>在编译时调用常量位置会被常量值替换</strong></font>，所以运行时不会加载常量所在类，提高运行效率</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final MY_COUNT = 1;</span><br><span class="line">System.out.println(MyClass.MY_COUNT);</span><br><span class="line">System.out.println(1);</span><br></pre></td></tr></table></figure><p>以上代码编译后，第二行代码会被编译成第三行代码编译的样子。(运行时MyClass类不会被加在)<br>注意final static定义的常量，无法在构造中赋值，只能声明直接赋值 或 在静态代码块中赋值，这样的常量被调用时依然先加载类后使用，并非上述</p><h3 id="final修饰词"><a href="#final修饰词" class="headerlink" title="final修饰词"></a>final修饰词</h3><table><thead><tr><th>final的使用</th><th>说明</th></tr></thead><tbody><tr><td>final 类</td><td>该类不可以被继承,public final class (){}</td></tr><tr><td>final 方法</td><td>该方法不可以被重写,public final static void fuc(){}</td></tr><tr><td>final 变量</td><td>该变量不可以被重新赋值,final int a = 0;</td></tr><tr><td>final 对象</td><td>不能修改其引用(指针),final class obj1 = new class();obj1 = obj2不可以;但可以改变引用(指针)指向的对象的值</td></tr></tbody></table><blockquote><p>final 变量：声明时直接赋值 或 声明后在<strong>每个</strong>构造中赋值。final也可以修饰形参变量</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java基础-面向对象-OOP&quot;&gt;&lt;a href=&quot;#Java基础-面向对象-OOP&quot; class=&quot;headerlink&quot; title=&quot;Java基础-面向对象(OOP)&quot;&gt;&lt;/a&gt;Java基础-面向对象(OOP)&lt;/h1&gt;&lt;h2 id=&quot;对象和类&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="语言编程" scheme="http://yoursite.com/categories/%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/11/26/hello-world/"/>
    <id>http://yoursite.com/2019/11/26/hello-world/</id>
    <published>2019-11-26T04:01:02.092Z</published>
    <updated>2019-12-09T09:57:13.121Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
